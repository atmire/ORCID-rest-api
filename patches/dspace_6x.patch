diff --git a/dspace/config/dspace.cfg b/dspace/config/dspace.cfg
index d17993d4d6386dadc22d72d7432d8a8324278c86..2564bab92b5c1717aa0e29d1f7558ddf92ad62c8 100644
--- a/dspace/config/dspace.cfg
+++ b/dspace/config/dspace.cfg
@@ -648,7 +648,7 @@ event.dispatcher.default.class = org.dspace.event.BasicDispatcher
 # Add doi here if you are using org.dspace.identifier.DOIIdentifierProvider to generate DOIs.
 # Adding doi here makes DSpace send metadata updates to your doi registration agency.
 # Add rdf here, if you are using dspace-rdf to export your repository content as RDF.
-event.dispatcher.default.consumers = versioning, discovery, eperson
+event.dispatcher.default.consumers = authority, versioning, discovery, eperson
 
 # The noindex dispatcher will not create search or browse indexes (useful for batch item imports)
 event.dispatcher.noindex.class = org.dspace.event.BasicDispatcher
@@ -682,7 +682,7 @@ event.consumer.versioning.filters = Item+Install
 
 # authority consumer
 event.consumer.authority.class = org.dspace.authority.indexer.AuthorityConsumer
-event.consumer.authority.filters = Item+Modify|Modify_Metadata
+event.consumer.authority.filters = Item+Modify|Modify_Metadata|Install
 
 # ...set to true to enable testConsumer messages to standard output
 #testConsumer.verbose = true
@@ -950,7 +950,7 @@ webui.strengths.show = false
 ###### ItemCounter Configuration ######
 #
 # Define the DAO class to use. This must correspond to your choice of
-# storage for the browse system (Solr is only option at this time). 
+# storage for the browse system (Solr is only option at this time).
 # By default, the Solr implementation is used.
 #
 # Solr:
@@ -1426,16 +1426,16 @@ sherpa.romeo.url = http://www.sherpa.ac.uk/romeo/api29.php
 # sherpa.romeo.apikey = YOUR-API-KEY
 
 #####  Authority Control Settings  #####
-#plugin.named.org.dspace.content.authority.ChoiceAuthority = \
+;plugin.named.org.dspace.content.authority.ChoiceAuthority = \
 # org.dspace.content.authority.SampleAuthority = Sample, \
 # org.dspace.content.authority.LCNameAuthority = LCNameAuthority, \
 # org.dspace.content.authority.SHERPARoMEOPublisher = SRPublisher, \
 # org.dspace.content.authority.SHERPARoMEOJournalTitle = SRJournalTitle, \
-#  org.dspace.content.authority.SolrAuthority = SolrAuthorAuthority
+;  org.dspace.content.authority.SolrAuthority = SolrAuthorAuthority
 
 #Uncomment to enable ORCID authority control
-#plugin.named.org.dspace.content.authority.ChoiceAuthority = \
-#    org.dspace.content.authority.SolrAuthority = SolrAuthorAuthority
+plugin.named.org.dspace.content.authority.ChoiceAuthority = \
+    org.dspace.content.authority.SolrAuthority = SolrAuthorAuthority
 
 # URL of ORCID API
 # Defaults to using the Public API (pub.orcid.org)
@@ -1478,13 +1478,19 @@ orcid.api.url = https://pub.orcid.org/v2.1
 ## See manual or org.dspace.content.authority.Choices source for descriptions.
 authority.minconfidence = ambiguous
 
+# Uncomment to disable allowing updates of person authority values through the REST api.
+# authority.allow-rest-updates.person = false
+
+# Uncomment to disable allowing updates of ORCIDS authority values through the REST api.
+# authority.allow-rest-updates.orcid = false
+
 # Configuration settings for ORCID based authority control, uncomment the lines below to enable configuration
-#solr.authority.server=${solr.server}/authority
-#choices.plugin.dc.contributor.author = SolrAuthorAuthority
-#choices.presentation.dc.contributor.author = authorLookup
-#authority.controlled.dc.contributor.author = true
+solr.authority.server=${solr.server}/authority
+choices.plugin.dc.contributor.author = SolrAuthorAuthority
+choices.presentation.dc.contributor.author = authorLookup
+authority.controlled.dc.contributor.author = true
 #
-#authority.author.indexer.field.1=dc.contributor.author
+authority.author.indexer.field.1=dc.contributor.author
 
 ## demo: use LC plugin for author
 #choices.plugin.dc.contributor.author =  LCNameAuthority
@@ -1525,6 +1531,10 @@ authority.minconfidence = ambiguous
 # Change number of choices shown in the select in Choices lookup popup
 #xmlui.lookup.select.size = 12
 
+# Putting orcid.connector.url in the config.
+# This property is not only used in the spring config, but also in actual code, so the config is used to link it as well.
+orcid.connector.url =https://orcid.org/
+
 
 #### Ordering of bitstreams ####
 
diff --git a/dspace/config/spring/api/core-services.xml b/dspace/config/spring/api/core-services.xml
index 2c6160f55fd8eea66dcf52ef82b4874223307538..a5fe7c13e656a556dca4bef9e61d2af4353fb386 100644
--- a/dspace/config/spring/api/core-services.xml
+++ b/dspace/config/spring/api/core-services.xml
@@ -28,7 +28,7 @@
     <bean class="org.dspace.authorize.AuthorizeServiceImpl"/>
     <bean class="org.dspace.authorize.ResourcePolicyServiceImpl"/>
 
-    <bean class="org.dspace.authority.AuthorityValueServiceImpl"/>
+    <bean class="com.atmire.dspace.authority.OrcidAuthorityValueServiceImpl"/>
     <bean class="org.dspace.authority.AuthorityServiceImpl"/>
 
     <bean class="org.dspace.checker.ChecksumHistoryServiceImpl"/>
diff --git a/dspace/config/spring/api/discovery.xml b/dspace/config/spring/api/discovery.xml
index d9c377e45ed017dd09904072eb3e76fd0f5347a1..4e3751e0794ec485a164f34b01e56ced94d09135 100644
--- a/dspace/config/spring/api/discovery.xml
+++ b/dspace/config/spring/api/discovery.xml
@@ -25,9 +25,10 @@
     <bean id="solrServiceResourceIndexPlugin" class="org.dspace.discovery.SolrServiceResourceRestrictionPlugin" scope="prototype"/>
     <bean id="SolrServiceSpellIndexingPlugin" class="org.dspace.discovery.SolrServiceSpellIndexingPlugin" scope="prototype"/>
     <bean id="solrServiceMetadataBrowseIndexingPlugin" class="org.dspace.discovery.SolrServiceMetadataBrowseIndexingPlugin" scope="prototype"/>
+    <bean id="orcidIdIndexingPlugin" class="com.atmire.dspace.discovery.ORCIDIdIndexingPlugin"/>
 
     <alias name="solrServiceResourceIndexPlugin" alias="org.dspace.discovery.SolrServiceResourceRestrictionPlugin"/>
-    
+
     <!-- Additional indexing plugin make filtering by has content in original bundle (like pdf's, images) posible via SOLR -->
     <bean id="hasContentInOriginalBundle" class="org.dspace.discovery.SolrServiceContentInOriginalBundleFilterPlugin"/>
 
@@ -115,6 +116,7 @@
 		        <ref bean="searchFilterContentInOriginalBundle"/>
                 <ref bean="searchFilterFileNameInOriginalBundle" />
                 <ref bean="searchFilterFileDescriptionInOriginalBundle" />
+                <ref bean="searchFilterOrcidFromAuthority" />
             </list>
         </property>
         <!--The sort filters for the discovery search-->
@@ -227,6 +229,7 @@
 		        <ref bean="searchFilterContentInOriginalBundle"/>
                 <ref bean="searchFilterFileNameInOriginalBundle" />
                 <ref bean="searchFilterFileDescriptionInOriginalBundle" />
+                <ref bean="searchFilterOrcidFromAuthority" />
             </list>
         </property>
         <!--The sort filters for the discovery search (same as defaultConfiguration above)-->
@@ -423,7 +426,7 @@
         <property name="sortOrderSidebar" value="COUNT"/>
         <property name="sortOrderFilterPage" value="COUNT"/>
     </bean>
-    
+
     <bean id="searchFilterContentInOriginalBundle" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
         <property name="indexFieldName" value="has_content_in_original_bundle"/>
         <property name="metadataFields">
@@ -449,6 +452,16 @@
         </property>
     </bean>
 
+    <bean class="org.dspace.discovery.configuration.DiscoverySearchFilter" id="searchFilterOrcidFromAuthority">
+        <property name="indexFieldName" value="orcidid" />
+        <property name="metadataFields">
+            <list>
+                <value>dc.identifier.orcid</value>
+                <value>orcid_id</value>
+            </list>
+        </property>
+    </bean>
+
     <!--Sort properties-->
     <bean id="sortTitle" class="org.dspace.discovery.configuration.DiscoverySortFieldConfiguration">
         <property name="metadataField" value="dc.title"/>
diff --git a/dspace/config/spring/api/orcid-authority-services.xml b/dspace/config/spring/api/orcid-authority-services.xml
index 1efc8f51bd9e15e60f5766f45a1af15d1dd498ff..70e3058b78cc5b893c50110ca02b1638c9fd9fc2 100644
--- a/dspace/config/spring/api/orcid-authority-services.xml
+++ b/dspace/config/spring/api/orcid-authority-services.xml
@@ -44,6 +44,9 @@
     <alias name="OrcidSource" alias="AuthoritySource"/>
     <bean name="OrcidSource" class="org.dspace.authority.orcid.Orcidv2" init-method="init">
         <constructor-arg value="${orcid.api.url}"/>
+        <constructor-arg value="https://api.orcid.org/oauth/token"/>
+        <constructor-arg value=""/>
+        <constructor-arg value=""/>
     </bean>
 
 
diff --git a/dspace/modules/additions/src/main/java/com/atmire/dspace/authority/OrcidAuthorityValueServiceImpl.java b/dspace/modules/additions/src/main/java/com/atmire/dspace/authority/OrcidAuthorityValueServiceImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..fd65afcef882ee758c7d5494bacde6ef97c6698e
--- /dev/null
+++ b/dspace/modules/additions/src/main/java/com/atmire/dspace/authority/OrcidAuthorityValueServiceImpl.java
@@ -0,0 +1,53 @@
+package com.atmire.dspace.authority;
+
+import org.apache.log4j.Logger;
+import org.apache.solr.client.solrj.SolrQuery;
+import org.apache.solr.client.solrj.response.QueryResponse;
+import org.apache.solr.common.SolrDocument;
+import org.dspace.authority.AuthorityUtil;
+import org.dspace.authority.AuthorityValue;
+import org.dspace.authority.AuthorityValueServiceImpl;
+import org.dspace.authority.PersonAuthorityValue;
+import org.dspace.authority.orcid.Orcidv2AuthorityValue;
+import org.dspace.content.authority.SolrAuthority;
+import org.dspace.core.Context;
+import org.dspace.core.LogManager;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.apache.log4j.Logger.getLogger;
+
+public class OrcidAuthorityValueServiceImpl extends AuthorityValueServiceImpl {
+
+    private Logger log = getLogger(OrcidAuthorityValueServiceImpl.class);
+
+    protected List<AuthorityValue> find(Context context, String queryString) {
+        List<AuthorityValue> findings = new ArrayList<AuthorityValue>();
+        try {
+            SolrQuery solrQuery = new SolrQuery();
+            solrQuery.setQuery(filtered(queryString));
+            log.debug("AuthorityValueFinder makes the query: " + queryString);
+            QueryResponse queryResponse = SolrAuthority.getSearchService().search(solrQuery);
+            if (queryResponse != null && queryResponse.getResults() != null && 0 < queryResponse.getResults().getNumFound()) {
+                for (SolrDocument document : queryResponse.getResults()) {
+                    AuthorityValue authorityValue;
+                    if ("orcid".equals(document.getFieldValue("authority_type"))) {
+                        authorityValue = new Orcidv2AuthorityValue(document);
+                        ((Orcidv2AuthorityValue) authorityValue).setOrcid_id((String) document.getFieldValue("orcid_id"));
+                    } else if (new AuthorityUtil().isPersonAuthority(document.getFieldValue("field") + "")) {
+                        authorityValue = new PersonAuthorityValue(document);
+                    } else {
+                        authorityValue = new AuthorityValue(document);
+                    }
+                    findings.add(authorityValue);
+                    log.debug("AuthorityValueFinder found: " + authorityValue.getValue());
+                }
+            }
+        } catch (Exception e) {
+            log.error(LogManager.getHeader(context, "Error while retrieving AuthorityValue from solr", "query: " + queryString),e);
+        }
+
+        return findings;
+    }
+}
diff --git a/dspace/modules/additions/src/main/java/com/atmire/dspace/discovery/ORCIDIdIndexingPlugin.java b/dspace/modules/additions/src/main/java/com/atmire/dspace/discovery/ORCIDIdIndexingPlugin.java
new file mode 100644
index 0000000000000000000000000000000000000000..a5b043113b2aab420a8006d53a4ad11270130012
--- /dev/null
+++ b/dspace/modules/additions/src/main/java/com/atmire/dspace/discovery/ORCIDIdIndexingPlugin.java
@@ -0,0 +1,67 @@
+package com.atmire.dspace.discovery;
+
+import org.apache.commons.lang.StringUtils;
+import org.apache.solr.common.SolrInputDocument;
+import org.dspace.authority.AuthorityValue;
+import org.dspace.authority.PersonAuthorityValue;
+import org.dspace.authority.factory.AuthorityServiceFactory;
+import org.dspace.content.DSpaceObject;
+import org.dspace.content.Item;
+import org.dspace.content.MetadataValue;
+import org.dspace.content.factory.ContentServiceFactory;
+import org.dspace.core.Constants;
+import org.dspace.core.Context;
+import org.dspace.discovery.SolrServiceIndexPlugin;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Created by jonas - jonas@atmire.com on 07/06/2018.
+ */
+public class ORCIDIdIndexingPlugin implements SolrServiceIndexPlugin {
+
+    private static final String ORCID_ID_FIELD = "orcid_id";
+
+    @Override
+    public void additionalIndex(Context context, DSpaceObject dso, SolrInputDocument document) {
+        if (dso != null && dso.getType() == Constants.ITEM) {
+            Item item = (Item) dso;
+
+            List<String> personAuthorityFields = new ArrayList<>();
+            for (Map.Entry<String, AuthorityValue> fieldDefaults : AuthorityServiceFactory.getInstance().getAuthorTypes().getFieldDefaults().entrySet()) {
+                if (fieldDefaults.getValue() instanceof PersonAuthorityValue) {
+                    personAuthorityFields.add(fieldDefaults.getKey());
+                }
+            }
+
+            for (String personAuthorityFieldKey : personAuthorityFields) {
+                String[] split = personAuthorityFieldKey.split("_");
+                List<MetadataValue> metadata = ContentServiceFactory.getInstance().getItemService().getMetadata(item, split[0], split[1], (split.length > 2) ? split[2] : null, Item.ANY);
+                for (MetadataValue metadataValue : metadata) {
+                    checkAndIndexMetadata(context, document, metadataValue);
+                }
+            }
+
+        }
+    }
+
+    private void checkAndIndexMetadata(Context context, SolrInputDocument document, MetadataValue metadatum) {
+        String authority = metadatum.getAuthority();
+        if (StringUtils.isNotBlank(authority)) {
+
+            AuthorityValue value = AuthorityServiceFactory.getInstance().getAuthorityValueService().findByUID(context, authority);
+            if (value != null) {
+                String orcidId = (String) value.getSolrInputDocument().getFieldValue(ORCID_ID_FIELD);
+                if (StringUtils.isNotBlank(orcidId)) {
+                    Collection<Object> fieldValues = document.getFieldValues(ORCID_ID_FIELD);
+                    if (fieldValues == null || !fieldValues.contains(orcidId)) {
+                        document.addField(ORCID_ID_FIELD, orcidId);
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/dspace/modules/additions/src/main/java/org/dspace/authority/AuthorityUtil.java b/dspace/modules/additions/src/main/java/org/dspace/authority/AuthorityUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..8ebc28a1875be7f1632856ca22ae58b1d782a40a
--- /dev/null
+++ b/dspace/modules/additions/src/main/java/org/dspace/authority/AuthorityUtil.java
@@ -0,0 +1,173 @@
+package org.dspace.authority;
+
+import org.apache.log4j.Logger;
+import org.apache.solr.client.solrj.SolrServerException;
+import org.dspace.authority.factory.AuthorityServiceFactory;
+import org.dspace.authority.indexer.AuthorityIndexingService;
+import org.dspace.authority.orcid.Orcidv2AuthorityValue;
+import org.dspace.authority.service.AuthorityValueService;
+import org.dspace.content.Item;
+import org.dspace.content.MetadataField;
+import org.dspace.content.authority.Choice;
+import org.dspace.content.authority.Choices;
+import org.dspace.content.authority.factory.ContentAuthorityServiceFactory;
+import org.dspace.content.authority.service.MetadataAuthorityService;
+import org.dspace.content.factory.ContentServiceFactory;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Constants;
+import org.dspace.core.Context;
+import org.dspace.utils.DSpace;
+
+import java.io.IOException;
+import java.sql.SQLException;
+import java.util.Date;
+
+import static java.util.Collections.singletonList;
+import static org.apache.commons.lang.StringUtils.isNotBlank;
+import static org.apache.log4j.Logger.getLogger;
+import static org.dspace.content.authority.Choices.CF_ACCEPTED;
+
+public class AuthorityUtil {
+
+    protected static final Logger log = getLogger(AuthorityUtil.class);
+
+    private AuthorityIndexingService indexingService = new DSpace().getServiceManager()
+            .getServiceByName(AuthorityIndexingService.class.getName(), AuthorityIndexingService.class);
+    private AuthorityValueService authorityValueService =
+            AuthorityServiceFactory.getInstance().getAuthorityValueService();
+    private ItemService itemService = ContentServiceFactory.getInstance().getItemService();
+
+    public void addMetadataWithOrcid(Context context, Item item, MetadataField metadataField, String value, String authority, String language) throws SQLException {
+
+        String orcidAuthorityID = null;
+
+        if (isOrcidFormat(authority)) {
+
+            AuthorityValue orcidAuthority = authorityValueService.findByOrcidID(context, authority);
+            if (orcidAuthority == null) {
+
+                orcidAuthorityID = createSolrOrcidAuthority(authority, value, metadataField);
+            } else {
+                orcidAuthorityID = orcidAuthority.getId();
+            }
+        }
+
+        if (orcidAuthorityID != null) {
+            itemService.addMetadata(context, item, metadataField, language, value, orcidAuthorityID, CF_ACCEPTED);
+
+        } else {
+            itemService.addMetadata(context, item, metadataField, language, value);
+        }
+    }
+
+    private String createSolrOrcidAuthority(final String orcidID, String value, MetadataField metadataField) {
+
+        Orcidv2AuthorityValue authorityValue = Orcidv2AuthorityValue.create();
+        authorityValue.setValue(value);
+        authorityValue.setField(metadataField.toString());
+
+        return updateOrcidAuthorityValue(orcidID, authorityValue);
+    }
+
+    public boolean isOrcidFormat(final String authority) {
+
+        return isNotBlank(authority) && authority.matches("\\d{4}-\\d{4}-\\d{4}-(\\d{3}X|\\d{4})");
+    }
+
+    private String updateOrcidAuthorityValue(String orcidID, Orcidv2AuthorityValue value) {
+
+        if (value == null) {
+            return null;
+        }
+
+        value.setOrcid_id(orcidID);
+        Date now = new Date();
+        value.setLastModified(now);
+        value.setCreationDate(now);
+        indexingService.indexContent(value);
+        indexingService.commit();
+        return value.getId();
+    }
+
+    public void addMetadata(Context context, Item dspaceItem, String[] field, String value, String language) throws SQLException {
+
+        MetadataField metadataField = ContentServiceFactory.getInstance().getMetadataFieldService()
+                .findByElement(context, field[0], field[1], field[2]);
+
+        String[] splitAuthority = splitAuthority(value);
+        if (splitAuthority.length > 1) {
+
+            String authority = splitAuthority[1];
+            if (isOrcidFormat(authority)) {
+                addMetadataWithOrcid(context, dspaceItem, metadataField, splitAuthority[0], authority, language);
+            } else {
+                addMetadataWithAuthority(context, dspaceItem, metadataField, splitAuthority[0], authority, language);
+            }
+        } else {
+            addMetadataWhenNoAuthorityIsProvided(context, dspaceItem, metadataField, splitAuthority[0], language);
+        }
+    }
+
+    private String[] splitAuthority(final String value) {
+        return value.split("::");
+    }
+
+    public void addMetadataWithAuthority(Context context, Item item, MetadataField metadataField, String value, String authority, String language) throws SQLException {
+
+        AuthorityValue authorityValue = authorityValueService.findByUID(context, authority);
+
+        if (authorityValue != null) {
+            itemService.addMetadata(context, item, metadataField, language,
+                    authorityValue.getValue(), authority, CF_ACCEPTED);
+        } else {
+            itemService.addMetadata(context, item, metadataField, language, value);
+        }
+    }
+
+    public void addMetadataWhenNoAuthorityIsProvided(Context context, Item item, MetadataField metadataField, String value, String language) throws SQLException {
+        MetadataAuthorityService mam = ContentAuthorityServiceFactory.getInstance().getMetadataAuthorityService();
+        String fieldKey = mam.makeFieldKey(metadataField);
+
+        boolean fieldAdded = false;
+
+        if (mam.isAuthorityControlled(fieldKey)) {
+            if (isPersonAuthority(metadataField)) {
+
+                Choices c = ContentAuthorityServiceFactory.getInstance().getChoiceAuthorityService()
+                        .getMatches(fieldKey, value, null, 0, 0, null);
+
+                for (Choice choice : c.values) {
+                    AuthorityValue matchedAuthority = authorityValueService.findByUID(context, choice.authority);
+                    if (!(matchedAuthority instanceof Orcidv2AuthorityValue)) {
+                        itemService.addMetadata(context, item, metadataField, language, value,
+                                c.values[0].authority, c.confidence);
+
+                        fieldAdded = true;
+                        break;
+                    }
+                }
+            }
+        }
+
+        // make sure the field is always added to the metadata
+        if (!fieldAdded){
+            itemService.addMetadata(context, item, metadataField, language, singletonList(value), null, null);
+        }
+    }
+
+    public boolean isPersonAuthority(MetadataField metadataField) {
+
+        return isPersonAuthority(metadataField.toString());
+    }
+
+    public boolean isPersonAuthority(String metadataField) {
+
+        return AuthorityServiceFactory.getInstance().getAuthorTypes().getFieldDefaults()
+                .get(metadataField) instanceof PersonAuthorityValue;
+    }
+
+    public void deleteAuthorityValueById(String id) throws IOException, SolrServerException {
+        ((AuthoritySolrServiceImpl) indexingService).getSolr().deleteByQuery("id:\"" + id + "\"");
+        indexingService.commit();
+    }
+}
diff --git a/dspace/modules/additions/src/main/java/org/dspace/authority/AuthorityValueFinder.java b/dspace/modules/additions/src/main/java/org/dspace/authority/AuthorityValueFinder.java
new file mode 100644
index 0000000000000000000000000000000000000000..ed4a9b4491670004043d5ab7bc9d64228c056cf0
--- /dev/null
+++ b/dspace/modules/additions/src/main/java/org/dspace/authority/AuthorityValueFinder.java
@@ -0,0 +1,133 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.authority;
+
+import org.apache.commons.lang.StringUtils;
+import org.apache.log4j.Logger;
+import org.apache.solr.client.solrj.SolrQuery;
+import org.apache.solr.client.solrj.response.QueryResponse;
+import org.apache.solr.common.SolrDocument;
+import org.dspace.authority.orcid.Orcidv2AuthorityValue;
+import org.dspace.content.authority.SolrAuthority;
+import org.dspace.core.Context;
+import org.dspace.core.LogManager;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ *
+ * @author Antoine Snyers (antoine at atmire.com)
+ * @author Kevin Van de Velde (kevin at atmire dot com)
+ * @author Ben Bosman (ben at atmire dot com)
+ * @author Mark Diggory (markd at atmire dot com)
+ */
+public class AuthorityValueFinder {
+
+    /**
+     * log4j logger
+     */
+    private static Logger log = Logger.getLogger(AuthorityValueFinder.class);
+
+    /**
+     * Item.ANY does not work here.
+     */
+    public AuthorityValue findByUID(Context context, String authorityID) {
+        //Ensure that if we use the full identifier to match on
+        String queryString = "id:\"" + authorityID + "\"";
+        List<AuthorityValue> findings = find(context, queryString);
+        return findings.size() > 0 ? findings.get(0) : null;
+    }
+
+    public List<AuthorityValue> findByExactValue(Context context, String field, String value) {
+        String queryString = "value:\"" + value + "\" AND field:" + field;
+        return find(context, queryString);
+    }
+
+    public List<AuthorityValue> findByValue(Context context, String field, String value) {
+        String queryString = "value:" + value + " AND field:" + field;
+        return find(context, queryString);
+    }
+
+    public List<AuthorityValue> findByValue(Context context, String schema, String element, String qualifier, String value) {
+        String field = fieldParameter(schema, element, qualifier);
+        return findByValue(context, field, qualifier);
+    }
+
+    public AuthorityValue findByOrcidID(Context context, String orcid_id) {
+        String queryString = "orcid_id:" + orcid_id;
+        List<AuthorityValue> findings = find(context, queryString);
+        return findings.size() > 0 ? findings.get(0) : null;
+    }
+
+    public List<AuthorityValue> findByName(Context context, String schema, String element, String qualifier, String name) {
+        String field = fieldParameter(schema, element, qualifier);
+        String queryString = "first_name:" + name + " OR last_name:" + name + " OR name_variant:" + name + " AND field:" + field;
+        return find(context, queryString);
+    }
+
+    public List<AuthorityValue> findByAuthorityMetadata(Context context, String schema, String element, String qualifier, String value) {
+        String field = fieldParameter(schema, element, qualifier);
+        String queryString = "all_Labels:" + value + " AND field:" + field;
+        return find(context, queryString);
+    }
+
+    public List<AuthorityValue> findOrcidHolders(Context context) {
+        String queryString = "orcid_id:*";
+        return find(context, queryString);
+    }
+
+    public List<AuthorityValue> findAll(Context context) {
+        String queryString = "*:*";
+        return find(context, queryString);
+    }
+
+    private List<AuthorityValue> find(Context context, String queryString) {
+        List<AuthorityValue> findings = new ArrayList<AuthorityValue>();
+        try {
+            SolrQuery solrQuery = new SolrQuery();
+            solrQuery.setQuery(filtered(queryString));
+            log.debug("AuthorityValueFinder makes the query: " + queryString);
+            QueryResponse queryResponse = SolrAuthority.getSearchService().search(solrQuery);
+            if (queryResponse != null && queryResponse.getResults() != null && 0 < queryResponse.getResults().getNumFound()) {
+                for (SolrDocument document : queryResponse.getResults()) {
+                    AuthorityValue authorityValue;
+                    if ("orcid".equals(document.getFieldValue("authority_type"))) {
+                        authorityValue = new Orcidv2AuthorityValue(document);
+                        ((Orcidv2AuthorityValue) authorityValue).setOrcid_id((String) document.getFieldValue("orcid_id"));
+                    } else if (new AuthorityUtil().isPersonAuthority(document.getFieldValue("field") + "")) {
+                        authorityValue = new PersonAuthorityValue(document);
+                    } else {
+                        authorityValue = new AuthorityValue(document);
+                    }
+                    findings.add(authorityValue);
+                    log.debug("AuthorityValueFinder found: " + authorityValue.getValue());
+                }
+            }
+        } catch (Exception e) {
+            log.error(LogManager.getHeader(context, "Error while retrieving AuthorityValue from solr", "query: " + queryString),e);
+        }
+
+        return findings;
+    }
+
+    private String filtered(String queryString) throws InstantiationException, IllegalAccessException {
+        String instanceFilter = "-deleted:true";
+        if (StringUtils.isNotBlank(instanceFilter)) {
+            queryString += " AND " + instanceFilter;
+        }
+        return queryString;
+    }
+
+    private String fieldParameter(String schema, String element, String qualifier) {
+        return schema + "_" + element + ((qualifier != null) ? "_" + qualifier : "");
+    }
+
+
+}
diff --git a/dspace/modules/additions/src/main/java/org/dspace/authority/PersonAuthorityValue.java b/dspace/modules/additions/src/main/java/org/dspace/authority/PersonAuthorityValue.java
new file mode 100644
index 0000000000000000000000000000000000000000..476b227f216174ea07bcb862e6d3a4ba04905389
--- /dev/null
+++ b/dspace/modules/additions/src/main/java/org/dspace/authority/PersonAuthorityValue.java
@@ -0,0 +1,277 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.authority;
+
+import org.apache.commons.codec.digest.DigestUtils;
+import org.apache.commons.lang.ObjectUtils;
+import org.apache.commons.lang.StringUtils;
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.SolrInputDocument;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+
+/**
+ *
+ * @author Antoine Snyers (antoine at atmire.com)
+ * @author Kevin Van de Velde (kevin at atmire dot com)
+ * @author Ben Bosman (ben at atmire dot com)
+ * @author Mark Diggory (markd at atmire dot com)
+ */
+public class PersonAuthorityValue extends AuthorityValue {
+
+    private String firstName;
+    private String lastName;
+    private List<String> nameVariants = new ArrayList<String>();
+    private String institution;
+    private List<String> emails = new ArrayList<String>();
+
+    public PersonAuthorityValue() {
+    }
+
+    public PersonAuthorityValue(SolrDocument document) {
+        super(document);
+    }
+
+    @Override
+    public String getId() {
+        // A PersonValue is considered unique with the first & last name.
+        String nonDigestedIdentifier;
+        if(StringUtils.isNotBlank(firstName)) {
+            nonDigestedIdentifier = org.dspace.authority.PersonAuthorityValue.class.toString() + "field: Person " + "lastName: " + lastName + ", firstName: " + firstName;
+        }
+        else {
+            nonDigestedIdentifier = org.dspace.authority.PersonAuthorityValue.class.toString() + "field: Person " + "lastName: " + lastName ;
+        }
+        // We return an md5 digest of the toString, this will ensure a unique identifier for the same value each time
+        return DigestUtils.md5Hex(nonDigestedIdentifier);
+    }
+
+    public String getName() {
+        String name = "";
+        if (StringUtils.isNotBlank(lastName)) {
+            name = lastName;
+            if (StringUtils.isNotBlank(firstName)) {
+                name += ", ";
+            }
+        }
+        if (StringUtils.isNotBlank(firstName)) {
+            name += firstName;
+        }
+        return name;
+    }
+
+    public void setName(String name) {
+        if (StringUtils.isNotBlank(name)) {
+            String[] split = name.split(",");
+            if (split.length > 0) {
+                setLastName(split[0].trim());
+                if (split.length > 1) {
+                    setFirstName(split[1].trim());
+                } else {
+                    setFirstName(null);
+                }
+            }
+        }
+        if (!StringUtils.equals(getValue(), name)) {
+            setValue(name);
+        }
+    }
+
+    @Override
+    public void setValue(String value) {
+        super.setValue(value);
+        setName(value);
+    }
+
+    public String getFirstName() {
+        return firstName;
+    }
+
+    public void setFirstName(String firstName) {
+        this.firstName = firstName;
+    }
+
+    public String getLastName() {
+        return lastName;
+    }
+
+    public void setLastName(String lastName) {
+        this.lastName = lastName;
+    }
+
+    public List<String> getNameVariants() {
+        return nameVariants;
+    }
+
+    public void addNameVariant(String name) {
+        if (StringUtils.isNotBlank(name)) {
+            nameVariants.add(name);
+        }
+    }
+
+    public String getInstitution() {
+        return institution;
+    }
+
+    public void setInstitution(String institution) {
+        this.institution = institution;
+    }
+
+    public List<String> getEmails() {
+        return emails;
+    }
+
+    public void addEmail(String email) {
+        if (StringUtils.isNotBlank(email)) {
+            emails.add(email);
+        }
+    }
+
+    @Override
+    public SolrInputDocument getSolrInputDocument() {
+        SolrInputDocument doc = super.getSolrInputDocument();
+        if (StringUtils.isNotBlank(getFirstName())) {
+            doc.addField("first_name", getFirstName());
+        }
+        if (StringUtils.isNotBlank(getLastName())) {
+            doc.addField("last_name", getLastName());
+        }
+        for (String nameVariant : getNameVariants()) {
+            doc.addField("name_variant", nameVariant);
+        }
+
+        for (String email : emails) {
+            doc.addField("email", email);
+        }
+        doc.addField("institution", getInstitution());
+        return doc;
+    }
+
+    @Override
+    public void setValues(SolrDocument document) {
+        super.setValues(document);
+        this.firstName = ObjectUtils.toString(document.getFieldValue("first_name"));
+        this.lastName = ObjectUtils.toString(document.getFieldValue("last_name"));
+        nameVariants = new ArrayList<String>();
+        Collection<Object> document_name_variant = document.getFieldValues("name_variant");
+        if (document_name_variant != null) {
+            for (Object name_variants : document_name_variant) {
+                addNameVariant(String.valueOf(name_variants));
+            }
+        }
+        if (document.getFieldValue("institution") != null) {
+            this.institution = String.valueOf(document.getFieldValue("institution"));
+        }
+
+        Collection<Object> emails = document.getFieldValues("email");
+        if (emails != null) {
+            for (Object email : emails) {
+                addEmail(String.valueOf(email));
+            }
+        }
+    }
+
+
+    @Override
+    public Map<String, String> choiceSelectMap() {
+
+        Map<String, String> map = super.choiceSelectMap();
+
+        if (StringUtils.isNotBlank(getFirstName())) {
+            map.put("first-name", getFirstName());
+        } else {
+            map.put("first-name", "/");
+        }
+
+        if (StringUtils.isNotBlank(getLastName())) {
+            map.put("last-name", getLastName());
+        } else {
+            map.put("last-name", "/");
+        }
+
+        if (!getEmails().isEmpty()) {
+            boolean added = false;
+            for (String email : getEmails()) {
+                if (!added && StringUtils.isNotBlank(email)) {
+                    map.put("email",email);
+                    added = true;
+                }
+            }
+        }
+        if (StringUtils.isNotBlank(getInstitution())) {
+            map.put("institution", getInstitution());
+        }
+
+        return map;
+    }
+
+    @Override
+    public String getAuthorityType() {
+        return "person";
+    }
+
+    @Override
+    public String generateString() {
+        return AuthorityValueServiceImpl.GENERATE + getAuthorityType() + AuthorityValueServiceImpl.SPLIT + getName();
+        // the part after "AuthorityValueGenerator.GENERATE + getAuthorityType() + AuthorityValueGenerator.SPLIT" is the value of the "info" parameter in public AuthorityValue newInstance(String info)
+    }
+
+    @Override
+    public AuthorityValue newInstance(String info) {
+        PersonAuthorityValue authorityValue = new PersonAuthorityValue();
+        authorityValue.setValue(info);
+        return authorityValue;
+    }
+
+    @Override
+    public String toString() {
+        return "PersonAuthorityValue{" +
+                "firstName='" + firstName + '\'' +
+                ", lastName='" + lastName + '\'' +
+                ", nameVariants=" + nameVariants +
+                ", institution='" + institution + '\'' +
+                ", emails=" + emails +
+                "} " + super.toString();
+    }
+
+    @Override
+    public boolean hasTheSameInformationAs(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+        if(!super.hasTheSameInformationAs(o)){
+            return false;
+        }
+
+        PersonAuthorityValue that = (PersonAuthorityValue) o;
+
+        if (emails != null ? !emails.equals(that.emails) : that.emails != null) {
+            return false;
+        }
+        if (firstName != null ? !firstName.equals(that.firstName) : that.firstName != null) {
+            return false;
+        }
+        if (institution != null ? !institution.equals(that.institution) : that.institution != null) {
+            return false;
+        }
+        if (lastName != null ? !lastName.equals(that.lastName) : that.lastName != null) {
+            return false;
+        }
+        if (nameVariants != null ? !nameVariants.equals(that.nameVariants) : that.nameVariants != null) {
+            return false;
+        }
+
+        return true;
+    }
+}
diff --git a/dspace/modules/additions/src/main/java/org/dspace/authority/orcid/Orcidv2AuthorityValue.java b/dspace/modules/additions/src/main/java/org/dspace/authority/orcid/Orcidv2AuthorityValue.java
new file mode 100644
index 0000000000000000000000000000000000000000..55eed1d62a23322ecbf53041e4bf6ddffd95c8f9
--- /dev/null
+++ b/dspace/modules/additions/src/main/java/org/dspace/authority/orcid/Orcidv2AuthorityValue.java
@@ -0,0 +1,355 @@
+/*
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.authority.orcid;
+
+import java.util.*;
+
+import org.apache.commons.codec.digest.DigestUtils;
+import org.apache.commons.lang.ObjectUtils;
+import org.apache.commons.lang.StringUtils;
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.SolrInputDocument;
+import org.dspace.authority.AuthorityValue;
+import org.dspace.authority.AuthorityValueServiceImpl;
+import org.dspace.authority.PersonAuthorityValue;
+import org.dspace.utils.DSpace;
+import org.orcid.jaxb.model.common_v2.ExternalId;
+import org.orcid.jaxb.model.record_v2.ExternalIdentifiers;
+import org.orcid.jaxb.model.record_v2.KeywordType;
+import org.orcid.jaxb.model.record_v2.NameType;
+import org.orcid.jaxb.model.record_v2.Person;
+import org.orcid.jaxb.model.record_v2.ResearcherUrlType;
+
+/**
+ * @author Jonas Van Goolen (jonas at atmire dot com)
+ */
+public class Orcidv2AuthorityValue extends PersonAuthorityValue {
+
+    /*
+     * The ORCID identifier
+     */
+    private String orcid_id;
+
+    /*
+     * Map containing key-value pairs filled in by "setValues(Person person)".
+     * This represents all dynamic information of the object.
+     */
+    private Map<String, List<String>> otherMetadata = new HashMap<String, List<String>>();
+
+    /**
+     * The syntax that the ORCID id needs to conform to
+     */
+    public static final String ORCID_ID_SYNTAX = "\\d{4}-\\d{4}-\\d{4}-(\\d{3}X|\\d{4})";
+
+    @Override
+    public String getId() {
+        // A PersonValue is considered unique with the first & last name.
+        String nonDigestedIdentifier;
+        if(StringUtils.isNotBlank(getFirstName())) {
+            nonDigestedIdentifier = Orcidv2AuthorityValue.class.toString() + "field: Person " + "lastName: " + getLastName() + ", firstName: " + getFirstName()+ ", OrcidIdentifier: " + getOrcid_id();
+        }
+        else {
+            nonDigestedIdentifier = Orcidv2AuthorityValue.class.toString() + "field: Person " + "lastName: " + getLastName()+", OrcidIdentifier: " + getOrcid_id() ;
+        }
+        // We return an md5 digest of the toString, this will ensure a unique identifier for the same value each time
+        return DigestUtils.md5Hex(nonDigestedIdentifier);
+    }
+
+    /**
+     * Creates an instance of Orcidv2AuthorityValue with only uninitialized fields.
+     * This is meant to be filled in with values from an existing record.
+     * To create a brand new Orcidv2AuthorityValue, use create()
+     */
+    public Orcidv2AuthorityValue() {
+    }
+
+    public Orcidv2AuthorityValue(SolrDocument document) {
+        super(document);
+    }
+
+
+    public String getOrcid_id() {
+        return orcid_id;
+    }
+
+    public void setOrcid_id(String orcid_id) {
+        this.orcid_id = orcid_id;
+    }
+
+    /**
+     * Create an empty authority.
+     * @return OrcidAuthorityValue
+     */
+    public static Orcidv2AuthorityValue create() {
+        Orcidv2AuthorityValue orcidAuthorityValue = new Orcidv2AuthorityValue();
+        orcidAuthorityValue.setId(UUID.randomUUID().toString());
+        orcidAuthorityValue.updateLastModifiedDate();
+        orcidAuthorityValue.setCreationDate(new Date());
+        return orcidAuthorityValue;
+    }
+
+    /**
+     * Create an authority based on a given orcid bio
+     * @return OrcidAuthorityValue
+     */
+    public static Orcidv2AuthorityValue create(Person person) {
+        if (person == null) {
+            return null;
+        }
+        Orcidv2AuthorityValue authority = Orcidv2AuthorityValue.create();
+
+        authority.setValues(person);
+
+        return authority;
+    }
+
+    /**
+     * Initialize this instance based on a Person object
+     * @param person Person
+     */
+    protected void setValues(Person person) {
+        NameType name = person.getName();
+
+        if (!StringUtils.equals(name.getPath(), this.getOrcid_id())) {
+            this.setOrcid_id(name.getPath());
+        }
+
+        if (!StringUtils.equals(name.getFamilyName().getValue(), this.getLastName())) {
+            this.setLastName(name.getFamilyName().getValue());
+        }
+
+        if (!StringUtils.equals(name.getGivenNames().getValue(), this.getFirstName())) {
+            this.setFirstName(name.getGivenNames().getValue());
+        }
+
+        if (name.getCreditName() != null && StringUtils.isNotBlank(name.getCreditName().getValue())) {
+            if (!this.getNameVariants().contains(name.getCreditName())) {
+                this.addNameVariant(name.getCreditName().getValue());
+            }
+        }
+
+        if (person.getKeywords() != null) {
+            for (KeywordType keyword : person.getKeywords().getKeyword()) {
+                if (this.isNewMetadata("keyword", keyword.getContent())) {
+                    this.addOtherMetadata("keyword", keyword.getContent());
+                }
+            }
+        }
+
+        ExternalIdentifiers externalIdentifiers = person.getExternalIdentifiers();
+        if (externalIdentifiers != null) {
+            for (ExternalId externalIdentifier : externalIdentifiers.getExternalIdentifier()) {
+                if (this.isNewMetadata("external_identifier", externalIdentifier.getExternalIdValue())) {
+                    this.addOtherMetadata("external_identifier", externalIdentifier.getExternalIdValue());
+
+                }
+            }
+        }
+        if (person.getResearcherUrls() != null) {
+            for (ResearcherUrlType researcherUrl : person.getResearcherUrls().getResearcherUrl()) {
+                if (this.isNewMetadata("researcher_url", researcherUrl.getUrl().getValue())) {
+                    this.addOtherMetadata("researcher_url", researcherUrl.getUrl().getValue());
+                }
+            }
+
+        }
+        if (person.getBiography() != null) {
+            if (this.isNewMetadata("biography", person.getBiography().getContent())) {
+                this.addOtherMetadata("biography", person.getBiography().getContent());
+            }
+        }
+
+        this.setValue(this.getName());
+
+    }
+
+    /**
+     * Makes an instance of the AuthorityValue with the given information.
+     * @param info string info
+     * @return AuthorityValue
+     */
+    @Override
+    public AuthorityValue newInstance(String info) {
+        AuthorityValue authorityValue = null;
+        if (StringUtils.isNotBlank(info)) {
+            Orcidv2 orcid = new DSpace().getServiceManager().getServiceByName("AuthoritySource", Orcidv2.class);
+            authorityValue = orcid.queryAuthorityID(info);
+        } else {
+            authorityValue = this.create();
+        }
+        return authorityValue;
+    }
+
+    @Override
+    public void setValue(String value) {
+        super.setValue(value);
+    }
+
+    /**
+     * Check to see if the provided label / data pair is already present in the "otherMetadata" or not
+     * */
+    public boolean isNewMetadata(String label, String data) {
+        List<String> strings = getOtherMetadata().get(label);
+        boolean update;
+        if (strings == null) {
+            update = StringUtils.isNotBlank(data);
+        } else {
+            update = !strings.contains(data);
+        }
+        return update;
+    }
+
+    /**
+     * Add additional metadata to the otherMetadata map*/
+    public void addOtherMetadata(String label, String data) {
+        List<String> strings = otherMetadata.get(label);
+        if (strings == null) {
+            strings = new ArrayList<>();
+        }
+        strings.add(data);
+        otherMetadata.put(label, strings);
+    }
+
+    public Map<String, List<String>> getOtherMetadata() {
+        return otherMetadata;
+    }
+
+
+    /**
+     * Generate a solr record from this instance
+     * @return SolrInputDocument
+     */
+    @Override
+    public SolrInputDocument getSolrInputDocument() {
+        SolrInputDocument doc = super.getSolrInputDocument();
+        if (StringUtils.isNotBlank(getOrcid_id())) {
+            doc.addField("orcid_id", getOrcid_id());
+        }
+
+        for (String t : otherMetadata.keySet()) {
+            List<String> data = otherMetadata.get(t);
+            for (String data_entry : data) {
+                doc.addField("label_" + t, data_entry);
+            }
+        }
+        return doc;
+    }
+
+    @Override
+    public void setValues(SolrDocument document) {
+        super.setValues(document);
+        this.setOrcid_id(document.getFieldValue("orcid_id").toString());
+    }
+
+    /**
+     * Information that can be used the choice ui
+     * @return map
+     */
+    @Override
+    public Map<String, String> choiceSelectMap() {
+
+        Map<String, String> map = super.choiceSelectMap();
+
+        String orcid_id = getOrcid_id();
+        if (StringUtils.isNotBlank(orcid_id)) {
+            map.put("orcid", orcid_id);
+        }
+
+        return map;
+    }
+
+    @Override
+    public String getAuthorityType() {
+        return "orcid";
+    }
+
+    /**
+     * Provides a string that will allow this AuthorityType to be recognized and provides information to create a new instance to be created using public Orcidv2AuthorityValue newInstance(String info).
+     * @return see {@link org.dspace.authority.service.AuthorityValueService#GENERATE AuthorityValueService.GENERATE}
+     */
+    @Override
+    public String generateString() {
+        String generateString = AuthorityValueServiceImpl.GENERATE + getAuthorityType() + AuthorityValueServiceImpl.SPLIT;
+        if (StringUtils.isNotBlank(getOrcid_id())) {
+            generateString += getOrcid_id();
+        }
+        return generateString;
+    }
+
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+
+        Orcidv2AuthorityValue that = (Orcidv2AuthorityValue) o;
+
+        if (orcid_id != null ? !orcid_id.equals(that.orcid_id) : that.orcid_id != null) {
+            return false;
+        }
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        return orcid_id != null ? orcid_id.hashCode() : 0;
+    }
+
+    /**
+     * The regular equals() only checks if both AuthorityValues describe the same authority.
+     * This method checks if the AuthorityValues have different information
+     * E.g. it is used to decide when lastModified should be updated.
+     * @param o object
+     * @return true or false
+     */
+    @Override
+    public boolean hasTheSameInformationAs(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+        if (!super.hasTheSameInformationAs(o)) {
+            return false;
+        }
+
+        Orcidv2AuthorityValue that = (Orcidv2AuthorityValue) o;
+
+        if (orcid_id != null ? !orcid_id.equals(that.orcid_id) : that.orcid_id != null) {
+            return false;
+        }
+
+        for (String key : otherMetadata.keySet()) {
+            if (otherMetadata.get(key) != null) {
+                List<String> metadata = otherMetadata.get(key);
+                List<String> otherMetadata = that.otherMetadata.get(key);
+                if (otherMetadata == null) {
+                    return false;
+                } else {
+                    HashSet<String> metadataSet = new HashSet<String>(metadata);
+                    HashSet<String> otherMetadataSet = new HashSet<String>(otherMetadata);
+                    if (!metadataSet.equals(otherMetadataSet)) {
+                        return false;
+                    }
+                }
+            } else {
+                if (that.otherMetadata.get(key) != null) {
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+}
diff --git a/dspace/modules/rest/src/main/java/org/dspace/rest/AuthoritiesResource.java b/dspace/modules/rest/src/main/java/org/dspace/rest/AuthoritiesResource.java
new file mode 100644
index 0000000000000000000000000000000000000000..fb330fa4afc84aefc1ee0a354d735779b1dc3946
--- /dev/null
+++ b/dspace/modules/rest/src/main/java/org/dspace/rest/AuthoritiesResource.java
@@ -0,0 +1,143 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ * <p>
+ * http://www.dspace.org/license/
+ */
+package org.dspace.rest;
+
+import static javax.ws.rs.core.MediaType.TEXT_PLAIN;
+import static javax.ws.rs.core.Response.Status.BAD_REQUEST;
+import static javax.ws.rs.core.Response.Status.OK;
+import static javax.ws.rs.core.Response.Status.UNAUTHORIZED;
+import static javax.ws.rs.core.Response.status;
+
+import java.io.IOException;
+import java.sql.SQLException;
+import java.util.Iterator;
+import javax.servlet.http.HttpServletRequest;
+import javax.ws.rs.Consumes;
+import javax.ws.rs.PUT;
+import javax.ws.rs.Path;
+import javax.ws.rs.PathParam;
+import javax.ws.rs.QueryParam;
+import javax.ws.rs.WebApplicationException;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.Response;
+
+import org.apache.log4j.Logger;
+import org.apache.solr.client.solrj.SolrServerException;
+import org.dspace.authority.AuthorityUtil;
+import org.dspace.authority.AuthorityValue;
+import org.dspace.authority.AuthorityValueFinder;
+import org.dspace.authority.PersonAuthorityValue;
+import org.dspace.authority.factory.AuthorityServiceFactory;
+import org.dspace.authority.indexer.AuthorityIndexingService;
+import org.dspace.authority.orcid.Orcidv2AuthorityValue;
+import org.dspace.authority.service.AuthorityValueService;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.authorize.factory.AuthorizeServiceFactory;
+import org.dspace.authorize.service.AuthorizeService;
+import org.dspace.content.Item;
+import org.dspace.content.MetadataValue;
+import org.dspace.content.factory.ContentServiceFactory;
+import org.dspace.content.service.ItemService;
+import org.dspace.discovery.IndexingService;
+import org.dspace.discovery.SearchServiceException;
+import org.dspace.rest.exceptions.ContextException;
+import org.dspace.services.ConfigurationService;
+import org.dspace.services.factory.DSpaceServicesFactory;
+import org.dspace.utils.DSpace;
+
+@SuppressWarnings("deprecation")
+@Path("/authorities")
+public class AuthoritiesResource extends Resource {
+
+    private static final Logger log = Logger.getLogger(AuthoritiesResource.class);
+
+    private static final AuthorityIndexingService authorityIndexingService = new DSpace().getSingletonService(AuthorityIndexingService.class);
+    private static final IndexingService indexingService = new DSpace().getSingletonService(IndexingService.class);
+    private static final AuthorityValueService authorityValueService = AuthorityServiceFactory.getInstance().getAuthorityValueService();
+
+    private static final AuthorizeService authorizeService = AuthorizeServiceFactory.getInstance().getAuthorizeService();
+    private static final ItemService itemService = ContentServiceFactory.getInstance().getItemService();
+    private static final ConfigurationService configurationService = DSpaceServicesFactory.getInstance().getConfigurationService();
+
+    @PUT
+    @Path("/{authority_id}/value")
+    @Consumes(TEXT_PLAIN)
+    public Response updateAuthorityValue(@PathParam("authority_id") String authorityId, String value,
+                                         @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+                                         @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException {
+
+        if (!configurationService.getBooleanProperty("authority.allow-rest-updates.person", true)) {
+            throw new WebApplicationException(BAD_REQUEST);
+        }
+
+        log.info("Updating value of authority (id: " + authorityId + ") to " + value + ".");
+
+        org.dspace.core.Context context = null;
+        try {
+            context = createContext();
+
+            if (!authorizeService.isAdmin(context)) {
+                context.abort();
+                throw new WebApplicationException(UNAUTHORIZED);
+            }
+
+            AuthorityValue authorityValue = new AuthorityValueFinder().findByUID(context, authorityId);
+
+            if (!(authorityValue instanceof PersonAuthorityValue)) {
+                context.abort();
+                throw new IllegalArgumentException("Provided authority is not a person. Only person authorities can be updated.");
+            }
+
+            authorityValue.setValue(value);
+
+            if (!(authorityValue instanceof Orcidv2AuthorityValue)) {
+                authorityValue = authorityValueService.update(authorityValue);
+            } else if (!configurationService.getBooleanProperty("authority.allow-rest-updates.orcid", true)) {
+                throw new WebApplicationException(BAD_REQUEST);
+            }
+
+            authorityIndexingService.indexContent(authorityValue);
+            new AuthorityUtil().deleteAuthorityValueById(authorityId);
+
+            log.info("Deleted authority with id: " + authorityId + " and added authority with id: " + authorityValue.getId());
+
+            authorityIndexingService.commit();
+
+            Iterator<Item> itemIterator = itemService.findByMetadataFieldAuthority(context, authorityValue.getField().replaceAll("_", "."), authorityId);
+            while (itemIterator.hasNext()) {
+                Item item = context.reloadEntity(itemIterator.next());
+
+                for (MetadataValue metadataValue : itemService.getMetadataByMetadataString(item, authorityValue.getField().replaceAll("_", "."))) {
+                    if (authorityId.equals(metadataValue.getAuthority())) {
+                        metadataValue.setAuthority(authorityValue.getId());
+                        metadataValue.setValue(authorityValue.getValue());
+                    }
+                }
+
+                indexingService.indexContent(context, item, true);
+            }
+
+            indexingService.commit();
+            context.complete();
+            log.info("Updated authority metadata values & discovery index.");
+
+        } catch (IllegalArgumentException | SQLException | SearchServiceException | IOException | SolrServerException | ContextException | AuthorizeException e) {
+            processException(
+                    "Could not update value of authority (id: " + authorityId + "). Message: " + e.getMessage(), context
+            );
+        } finally {
+            processFinally(context);
+        }
+
+        log.info("Value of authority (id: " + authorityId + ") was successfully updated.");
+
+        return status(OK).build();
+    }
+}
diff --git a/dspace/modules/rest/src/main/java/org/dspace/rest/CollectionsResource.java b/dspace/modules/rest/src/main/java/org/dspace/rest/CollectionsResource.java
new file mode 100644
index 0000000000000000000000000000000000000000..6e4abf350b01758d1236077d68eee217a281791a
--- /dev/null
+++ b/dspace/modules/rest/src/main/java/org/dspace/rest/CollectionsResource.java
@@ -0,0 +1,770 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.rest;
+
+import org.dspace.authority.AuthorityUtil;
+import org.apache.log4j.Logger;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.authorize.factory.AuthorizeServiceFactory;
+import org.dspace.authorize.service.AuthorizeService;
+import org.dspace.content.factory.ContentServiceFactory;
+import org.dspace.content.service.CollectionService;
+import org.dspace.content.service.ItemService;
+import org.dspace.content.service.WorkspaceItemService;
+import org.dspace.core.Constants;
+import org.dspace.core.LogManager;
+import org.dspace.rest.common.Collection;
+import org.dspace.rest.common.Item;
+import org.dspace.rest.common.MetadataEntry;
+import org.dspace.rest.exceptions.ContextException;
+import org.dspace.usage.UsageEvent;
+import org.dspace.workflow.WorkflowService;
+import org.dspace.workflow.factory.WorkflowServiceFactory;
+
+import javax.servlet.http.HttpServletRequest;
+import javax.ws.rs.*;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import java.io.IOException;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * This class provides all CRUD operation over collections.
+ * 
+ * @author Rostislav Novak (Computing and Information Centre, CTU in Prague)
+ */
+@Path("/collections")
+public class CollectionsResource extends Resource
+{
+    protected CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();
+    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();
+    protected AuthorizeService authorizeService = AuthorizeServiceFactory.getInstance().getAuthorizeService();
+    protected WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance().getWorkspaceItemService();
+    protected WorkflowService workflowService = WorkflowServiceFactory.getInstance().getWorkflowService();
+
+    private static Logger log = Logger.getLogger(CollectionsResource.class);
+
+    /**
+     * Return instance of collection with passed id. You can add more properties
+     * through expand parameter.
+     * 
+     * @param collectionId
+     *            Id of collection in DSpace.
+     * @param expand
+     *            String in which is what you want to add to returned instance
+     *            of collection. Options are: "all", "parentCommunityList",
+     *            "parentCommunity", "items", "license" and "logo". If you want
+     *            to use multiple options, it must be separated by commas.
+     * @param limit
+     *            Limit value for items in list in collection. Default value is
+     *            100.
+     * @param offset
+     *            Offset of start index in list of items of collection. Default
+     *            value is 0.
+     * @param headers
+     *            If you want to access to collection under logged user into
+     *            context. In headers must be set header "rest-dspace-token"
+     *            with passed token from login method.
+     * @return Return instance of collection. It can also return status code
+     *         NOT_FOUND(404) if id of collection is incorrect or status code
+     *         UNATHORIZED(401) if user has no permission to read collection.
+     * @throws WebApplicationException
+     *             It is thrown when was problem with database reading
+     *             (SQLException) or problem with creating
+     *             context(ContextException). It is thrown by NOT_FOUND and
+     *             UNATHORIZED status codes, too.
+     */
+    @GET
+    @Path("/{collection_id}")
+    @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Collection getCollection(@PathParam("collection_id") String collectionId,
+            @QueryParam("expand") String expand, @QueryParam("limit") @DefaultValue("100") Integer limit,
+            @QueryParam("offset") @DefaultValue("0") Integer offset, @QueryParam("userIP") String user_ip,
+            @QueryParam("userAgent") String user_agent, @QueryParam("xforwardedfor") String xforwardedfor,
+            @Context HttpHeaders headers, @Context HttpServletRequest request) throws WebApplicationException
+    {
+
+        log.info("Reading collection(id=" + collectionId + ").");
+        org.dspace.core.Context context = null;
+        Collection collection = null;
+
+        try
+        {
+            context = createContext();
+
+            org.dspace.content.Collection dspaceCollection = findCollection(context, collectionId, Constants.READ);
+            writeStats(dspaceCollection, UsageEvent.Action.VIEW, user_ip, user_agent, xforwardedfor,
+                    headers, request, context);
+
+            collection = new Collection(dspaceCollection, servletContext, expand, context, limit, offset);
+            context.complete();
+
+        }
+        catch (SQLException e)
+        {
+            processException("Could not read collection(id=" + collectionId + "), SQLException. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Could not read collection(id=" + collectionId + "), ContextException. Message: " + e.getMessage(),
+                    context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.trace("Collection(id=" + collectionId + ") has been successfully read.");
+        return collection;
+    }
+
+    /**
+     * Return array of all collections in DSpace. You can add more properties
+     * through expand parameter.
+     *
+     * @param expand
+     *            String in which is what you want to add to returned instance
+     *            of collection. Options are: "all", "parentCommunityList",
+     *            "parentCommunity", "items", "license" and "logo". If you want
+     *            to use multiple options, it must be separated by commas.
+     * @param limit
+     *            Limit value for items in list in collection. Default value is
+     *            100.
+     * @param offset
+     *            Offset of start index in list of items of collection. Default
+     *            value is 0.
+     * @param headers
+     *            If you want to access to collections under logged user into
+     *            context. In headers must be set header "rest-dspace-token"
+     *            with passed token from login method.
+     * @return Return array of collection, on which has logged user permission
+     *         to view.
+     * @throws WebApplicationException
+     *             It is thrown when was problem with database reading
+     *             (SQLException) or problem with creating
+     *             context(ContextException).
+     */
+    @GET
+    @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Collection[] getCollections(@QueryParam("expand") String expand,
+            @QueryParam("limit") @DefaultValue("100") Integer limit, @QueryParam("offset") @DefaultValue("0") Integer offset,
+            @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Reading all collections.(offset=" + offset + ",limit=" + limit + ")");
+        org.dspace.core.Context context = null;
+        List<Collection> collections = new ArrayList<Collection>();
+
+        try
+        {
+            context = createContext();
+
+            if (!((limit != null) && (limit >= 0) && (offset != null) && (offset >= 0)))
+            {
+                log.warn("Paging was badly set.");
+                limit = 100;
+                offset = 0;
+            }
+
+            List<org.dspace.content.Collection> dspaceCollections = collectionService.findAll(context, limit, offset);
+            for(org.dspace.content.Collection dspaceCollection : dspaceCollections)
+            {
+                if (authorizeService.authorizeActionBoolean(context, dspaceCollection, Constants.READ))
+                {
+                    Collection collection = new Collection(dspaceCollection, servletContext, null, context, limit,
+                            offset);
+                    collections.add(collection);
+                    writeStats(dspaceCollection, UsageEvent.Action.VIEW, user_ip, user_agent,
+                            xforwardedfor, headers, request, context);
+                }
+            }
+            context.complete();
+        }
+        catch (SQLException e)
+        {
+            processException("Something went wrong while reading collections from database. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Something went wrong while reading collections, ContextError. Message: " + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.trace("All collections were successfully read.");
+        return collections.toArray(new Collection[0]);
+    }
+
+    /**
+     * Return array of items in collection. You can add more properties to items
+     * with expand parameter.
+     *
+     * @param collectionId
+     *            Id of collection in DSpace.
+     * @param expand
+     *            String which define, what additional properties will be in
+     *            returned item. Options are separeted by commas and are: "all",
+     *            "metadata", "parentCollection", "parentCollectionList",
+     *            "parentCommunityList" and "bitstreams".
+     * @param limit
+     *            Limit value for items in array. Default value is 100.
+     * @param offset
+     *            Offset of start index in array of items of collection. Default
+     *            value is 0.
+     * @param headers
+     *            If you want to access to collection under logged user into
+     *            context. In headers must be set header "rest-dspace-token"
+     *            with passed token from login method.
+     * @return Return array of items, on which has logged user permission to
+     *         read. It can also return status code NOT_FOUND(404) if id of
+     *         collection is incorrect or status code UNATHORIZED(401) if user
+     *         has no permission to read collection.
+     * @throws WebApplicationException
+     *             It is thrown when was problem with database reading
+     *             (SQLException) or problem with creating
+     *             context(ContextException). It is thrown by NOT_FOUND and
+     *             UNATHORIZED status codes, too.
+     */
+    @GET
+    @Path("/{collection_id}/items")
+    @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Item[] getCollectionItems(@PathParam("collection_id") String collectionId,
+            @QueryParam("expand") String expand, @QueryParam("limit") @DefaultValue("100") Integer limit,
+            @QueryParam("offset") @DefaultValue("0") Integer offset, @QueryParam("userIP") String user_ip,
+            @QueryParam("userAgent") String user_agent, @QueryParam("xforwardedfor") String xforwardedfor,
+            @Context HttpHeaders headers, @Context HttpServletRequest request) throws WebApplicationException
+    {
+
+        log.info("Reading collection(id=" + collectionId + ") items.");
+        org.dspace.core.Context context = null;
+        List<Item> items = null;
+
+        try
+        {
+            context = createContext();
+
+            org.dspace.content.Collection dspaceCollection = findCollection(context, collectionId, Constants.READ);
+            writeStats(dspaceCollection, UsageEvent.Action.VIEW, user_ip, user_agent, xforwardedfor,
+                    headers, request, context);
+
+            items = new ArrayList<Item>();
+            Iterator<org.dspace.content.Item> dspaceItems = itemService.findByCollection(context, dspaceCollection);
+            for (int i = 0; (dspaceItems.hasNext()) && (i < (limit + offset)); i++)
+            {
+                org.dspace.content.Item dspaceItem = dspaceItems.next();
+
+                if (i >= offset)
+                {
+                    if (itemService.isItemListedForUser(context, dspaceItem))
+                    {
+                        items.add(new Item(dspaceItem, servletContext, expand, context));
+                        writeStats(dspaceItem, UsageEvent.Action.VIEW, user_ip, user_agent, xforwardedfor,
+                                headers, request, context);
+                    }
+                }
+            }
+
+            context.complete();
+        }
+        catch (SQLException e)
+        {
+            processException("Could not read collection items, SQLException. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Could not read collection items, ContextException. Message: " + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.trace("All items in collection(id=" + collectionId + ") were successfully read.");
+        return items.toArray(new Item[0]);
+    }
+
+    /**
+     * Create item in collection. Item can be without filled metadata.
+     *
+     * @param collectionId
+     *            Id of collection in which will be item created.
+     * @param item
+     *            Item filled only with metadata, other variables are ignored.
+     * @param headers
+     *            If you want to access to collection under logged user into
+     *            context. In headers must be set header "rest-dspace-token"
+     *            with passed token from login method.
+     * @return Return status code with item. Return status (OK)200 if item was
+     *         created. NOT_FOUND(404) if id of collection does not exists.
+     *         UNAUTHORIZED(401) if user have not permission to write items in
+     *         collection.
+     * @throws WebApplicationException
+     *             It is thrown when was problem with database reading or
+     *             writing (SQLException) or problem with creating
+     *             context(ContextException) or problem with authorization to
+     *             collection or IOException or problem with index item into
+     *             browse index. It is thrown by NOT_FOUND and UNATHORIZED
+     *             status codes, too.
+     *
+     */
+    @POST
+    @Path("/{collection_id}/items")
+    @Consumes({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Item addCollectionItem(@PathParam("collection_id") String collectionId, Item item,
+            @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Create item in collection(id=" + collectionId + ").");
+        org.dspace.core.Context context = null;
+        Item returnItem = null;
+
+        try
+        {
+            context = createContext();
+            org.dspace.content.Collection dspaceCollection = findCollection(context, collectionId,
+                    Constants.WRITE);
+
+            writeStats(dspaceCollection, UsageEvent.Action.UPDATE, user_ip, user_agent, xforwardedfor,
+                    headers, request, context);
+
+            log.trace("Creating item in collection(id=" + collectionId + ").");
+            org.dspace.content.WorkspaceItem workspaceItem = workspaceItemService.create(context, dspaceCollection, false);
+            org.dspace.content.Item dspaceItem = workspaceItem.getItem();
+
+            log.trace("Adding metadata to item(id=" + dspaceItem.getID() + ").");
+            if (item.getMetadata() != null)
+            {
+                for (MetadataEntry entry : item.getMetadata())
+                {
+                    String data[] = mySplit(entry.getKey());
+                    new AuthorityUtil().addMetadata(context, dspaceItem, data, entry.getValue(), entry.getLanguage());
+                }
+            }
+
+            workspaceItemService.update(context, workspaceItem);
+
+            try
+            {
+                // Must insert the item into workflow
+                log.trace("Starting workflow for item(id=" + dspaceItem.getID() + ").");
+                workflowService.start(context, workspaceItem);
+            }
+            catch (Exception e)
+            {
+                log.error(LogManager.getHeader(context, "Error while starting workflow", "Item id: " + dspaceItem.getID()), e);
+                throw new ContextException("Error while starting workflow for item(id=" + dspaceItem.getID() + ")", e);
+            }
+
+            returnItem = new Item(workspaceItem.getItem(), servletContext, "",context);
+
+            context.complete();
+
+        }
+        catch (SQLException e)
+        {
+            processException("Could not add item into collection(id=" + collectionId + "), SQLException. Message: " + e, context);
+        }
+        catch (AuthorizeException e)
+        {
+            processException("Could not add item into collection(id=" + collectionId + "), AuthorizeException. Message: " + e,
+                    context);
+        }
+        catch (ContextException e)
+        {
+            processException(
+                    "Could not add item into collection(id=" + collectionId + "), ContextException. Message: " + e.getMessage(),
+                    context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.info("Item successfully created in collection(id=" + collectionId + "). Item handle=" + returnItem.getHandle());
+        return returnItem;
+    }
+
+    /**
+     * Update collection. It replace all properties.
+     *
+     * @param collectionId
+     *            Id of collection in DSpace.
+     * @param collection
+     *            Collection which will replace properties of actual collection.
+     * @param headers
+     *            If you want to access to collection under logged user into
+     *            context. In headers must be set header "rest-dspace-token"
+     *            with passed token from login method.
+     * @return Return response 200 if was everything all right. Otherwise 400
+     *         when id of community was incorrect or 401 if was problem with
+     *         permission to write into collection.
+     * @throws WebApplicationException
+     *             It is thrown when was problem with database reading or
+     *             writing. Or problem with authorization to collection. Or
+     *             problem with creating context.
+     */
+    @PUT
+    @Path("/{collection_id}")
+    @Consumes({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Response updateCollection(@PathParam("collection_id") String collectionId,
+            Collection collection, @QueryParam("userIP") String user_ip,
+            @QueryParam("userAgent") String user_agent, @QueryParam("xforwardedfor") String xforwardedfor,
+            @Context HttpHeaders headers, @Context HttpServletRequest request) throws WebApplicationException
+    {
+
+        log.info("Updating collection(id=" + collectionId + ").");
+        org.dspace.core.Context context = null;
+
+        try
+        {
+            context = createContext();
+            org.dspace.content.Collection dspaceCollection = findCollection(context, collectionId,
+                    Constants.WRITE);
+
+            writeStats(dspaceCollection, UsageEvent.Action.UPDATE, user_ip, user_agent, xforwardedfor,
+                    headers, request, context);
+
+            collectionService.setMetadata(context, dspaceCollection, "name", collection.getName());
+            collectionService.setMetadata(context, dspaceCollection, "license", collection.getLicense());
+
+            // dspaceCollection.setLogo(collection.getLogo()); // TODO Add this option.
+            collectionService.setMetadata(context, dspaceCollection, org.dspace.content.Collection.COPYRIGHT_TEXT, collection.getCopyrightText());
+            collectionService.setMetadata(context, dspaceCollection, org.dspace.content.Collection.INTRODUCTORY_TEXT, collection.getIntroductoryText());
+            collectionService.setMetadata(context, dspaceCollection, org.dspace.content.Collection.SHORT_DESCRIPTION, collection.getShortDescription());
+            collectionService.setMetadata(context, dspaceCollection, org.dspace.content.Collection.SIDEBAR_TEXT, collection.getSidebarText());
+            collectionService.update(context, dspaceCollection);
+
+            context.complete();
+
+        }
+        catch (ContextException e)
+        {
+            processException("Could not update collection(id=" + collectionId + "), ContextException. Message: " + e.getMessage(),
+                    context);
+        }
+        catch (SQLException e)
+        {
+            processException("Could not update collection(id=" + collectionId + "), SQLException. Message: " + e, context);
+        } catch (AuthorizeException e) {
+            processException("Could not update collection(id=" + collectionId + "), AuthorizeException. Message: " + e, context);
+        } finally
+        {
+            processFinally(context);
+        }
+
+        log.info("Collection(id=" + collectionId + ") successfully updated.");
+        return Response.ok().build();
+    }
+
+    /**
+     * Delete collection.
+     *
+     * @param collectionId
+     *            Id of collection which will be deleted.
+     * @param headers
+     *            If you want to access to collection under logged user into
+     *            context. In headers must be set header "rest-dspace-token"
+     *            with passed token from login method.
+     * @return Return response code OK(200) if was everything all right.
+     *         Otherwise return NOT_FOUND(404) if was id of community or
+     *         collection incorrect. Or (UNAUTHORIZED)401 if was problem with
+     *         permission to community or collection.
+     * @throws WebApplicationException
+     *             It is throw when was problem with creating context or problem
+     *             with database reading or writing. Or problem with deleting
+     *             collection caused by IOException or authorization.
+     */
+    @DELETE
+    @Path("/{collection_id}")
+    @Consumes({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Response deleteCollection(@PathParam("collection_id") String collectionId, @QueryParam("userIP") String user_ip,
+            @QueryParam("userAgent") String user_agent, @QueryParam("xforwardedfor") String xforwardedfor,
+            @Context HttpHeaders headers, @Context HttpServletRequest request) throws WebApplicationException
+    {
+
+        log.info("Delete collection(id=" + collectionId + ").");
+        org.dspace.core.Context context = null;
+
+        try
+        {
+            context = createContext();
+            org.dspace.content.Collection dspaceCollection = findCollection(context, collectionId,
+                    Constants.DELETE);
+
+            writeStats(dspaceCollection, UsageEvent.Action.REMOVE, user_ip, user_agent, xforwardedfor,
+                    headers, request, context);
+
+            collectionService.delete(context, dspaceCollection);
+            collectionService.update(context, dspaceCollection);
+
+            context.complete();
+        }
+        catch (ContextException e)
+        {
+            processException(
+                    "Could not delete collection(id=" + collectionId + "), ContextException. Message: " + e.getMessage(), context);
+        }
+        catch (SQLException e)
+        {
+            processException("Could not delete collection(id=" + collectionId + "), SQLException. Message: " + e, context);
+        }
+        catch (AuthorizeException e)
+        {
+            processException("Could not delete collection(id=" + collectionId + "), AuthorizeException. Message: " + e, context);
+        }
+        catch (IOException e)
+        {
+            processException("Could not delete collection(id=" + collectionId + "), IOException. Message: " + e, context);
+        }
+        finally {
+            processFinally(context);
+        }
+
+        log.info("Collection(id=" + collectionId + ") was successfully deleted.");
+        return Response.ok().build();
+    }
+
+    /**
+     * Delete item in collection.
+     *
+     * @param collectionId
+     *            Id of collection which will be deleted.
+     *
+     * @param itemId
+     *            Id of item in colletion.
+     * @return It returns status code: OK(200). NOT_FOUND(404) if item or
+     *         collection was not found, UNAUTHORIZED(401) if user is not
+     *         allowed to delete item or permission to write into collection.
+     * @throws WebApplicationException
+     *             It can be thrown by: SQLException, when was problem with
+     *             database reading or writting. AuthorizeException, when was
+     *             problem with authorization to item or collection.
+     *             IOException, when was problem with removing item.
+     *             ContextException, when was problem with creating context of
+     *             DSpace.
+     */
+    @DELETE
+    @Path("/{collection_id}/items/{item_id}")
+    @Consumes({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Response deleteCollectionItem(@PathParam("collection_id") String collectionId, @PathParam("item_id") String itemId,
+            @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Delete item(id=" + itemId + ") in collection(id=" + collectionId + ").");
+        org.dspace.core.Context context = null;
+
+        try
+        {
+            context = createContext();
+
+            org.dspace.content.Collection dspaceCollection = collectionService.findByIdOrLegacyId(context, collectionId);
+            org.dspace.content.Item item = itemService.findByIdOrLegacyId(context, itemId);
+
+
+            if(dspaceCollection == null) {
+                //throw collection not exist
+                log.warn("Collection(id=" + itemId + ") was not found!");
+                throw new WebApplicationException(Response.Status.NOT_FOUND);
+            }
+
+            if(item == null) {
+                //throw item not exist
+                log.warn("Item(id=" + itemId + ") was not found!");
+                throw new WebApplicationException(Response.Status.NOT_FOUND);
+            }
+
+            if(!authorizeService.authorizeActionBoolean(context, item, Constants.REMOVE)
+                    || !authorizeService.authorizeActionBoolean(context, dspaceCollection, Constants.REMOVE)) {
+                //throw auth
+                if (context.getCurrentUser() != null)
+                {
+                    log.error("User(" + context.getCurrentUser().getEmail() + ") does not have permission to delete item!");
+                }
+                else
+                {
+                    log.error("User(anonymous) has not permission to delete item!");
+                }
+                throw new WebApplicationException(Response.Status.UNAUTHORIZED);
+            }
+
+            collectionService.removeItem(context, dspaceCollection, item);
+            collectionService.update(context, dspaceCollection);
+            itemService.update(context, item);
+
+            writeStats(dspaceCollection, UsageEvent.Action.UPDATE, user_ip, user_agent, xforwardedfor,
+                    headers, request, context);
+            writeStats(item, UsageEvent.Action.REMOVE, user_ip, user_agent, xforwardedfor, headers, request, context);
+
+            context.complete();
+
+        }
+        catch (ContextException e)
+        {
+            processException("Could not delete item(id=" + itemId + ") in collection(id=" + collectionId
+                    + "), ContextException. Message: " + e.getMessage(), context);
+        }
+        catch (SQLException e)
+        {
+            processException("Could not delete item(id=" + itemId + ") in collection(id=" + collectionId
+                    + "), SQLException. Message: " + e, context);
+        }
+        catch (AuthorizeException e)
+        {
+            processException("Could not delete item(id=" + itemId + ") in collection(id=" + collectionId
+                    + "), AuthorizeException. Message: " + e, context);
+        }
+        catch (IOException e)
+        {
+            processException("Could not delete item(id=" + itemId + ") in collection(id=" + collectionId
+                    + "), IOException. Message: " + e, context);
+        }
+        finally {
+            processFinally(context);
+        }
+
+        log.info("Item(id=" + itemId + ") in collection(id=" + collectionId + ") was successfully deleted.");
+        return Response.ok().build();
+    }
+
+    /**
+     * Search for first collection with passed name.
+     *
+     * @param name
+     *            Name of collection.
+     * @param headers
+     *            If you want to access to collection under logged user into
+     *            context. In headers must be set header "rest-dspace-token"
+     *            with passed token from login method.
+     * @return It returns null if collection was not found. Otherwise returns
+     *         first founded collection.
+     * @throws WebApplicationException
+     */
+    @POST
+    @Path("/find-collection")
+    @Consumes({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Collection findCollectionByName(String name, @Context HttpHeaders headers) throws WebApplicationException
+    {
+        log.info("Searching for first collection with name=" + name + ".");
+        org.dspace.core.Context context = null;
+        Collection collection = null;
+
+        try
+        {
+            context = createContext();
+
+            List<org.dspace.content.Collection> dspaceCollections = collectionService.findAll(context);
+            //TODO, this would be more efficient with a findByName query
+
+            for (org.dspace.content.Collection dspaceCollection : dspaceCollections)
+            {
+                if (authorizeService.authorizeActionBoolean(context, dspaceCollection, Constants.READ))
+                {
+                    if (dspaceCollection.getName().equals(name))
+                    {
+                        collection = new Collection(dspaceCollection, servletContext, "", context, 100, 0);
+                        break;
+                    }
+                }
+            }
+
+            context.complete();
+
+        }
+        catch (SQLException e)
+        {
+            processException("Something went wrong while searching for collection(name=" + name + ") from database. Message: "
+                    + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Something went wrong while searching for collection(name=" + name + "), ContextError. Message: "
+                    + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        if (collection == null)
+        {
+            log.info("Collection was not found.");
+        }
+        else
+        {
+            log.info("Collection was found with id(" + collection.getUUID() + ").");
+        }
+        return collection;
+    }
+
+    /**
+     * Find collection from DSpace database. It is encapsulation of method
+     * org.dspace.content.Collection.find with checking if item exist and if
+     * user logged into context has permission to do passed action.
+     * 
+     * @param context
+     *            Context of actual logged user.
+     * @param id
+     *            Id of collection in DSpace.
+     * @param action
+     *            Constant from org.dspace.core.Constants.
+     * @return It returns DSpace collection.
+     * @throws WebApplicationException
+     *             Is thrown when item with passed id is not exists and if user
+     *             has no permission to do passed action.
+     */
+    private org.dspace.content.Collection findCollection(org.dspace.core.Context context, String id, int action)
+            throws WebApplicationException
+    {
+        org.dspace.content.Collection collection = null;
+        try
+        {
+            collection = collectionService.findByIdOrLegacyId(context, id);
+
+            if (collection == null)
+            {
+                context.abort();
+                log.warn("Collection(id=" + id + ") was not found!");
+                throw new WebApplicationException(Response.Status.NOT_FOUND);
+            }
+            else if (!authorizeService.authorizeActionBoolean(context, collection, action))
+            {
+                context.abort();
+                if (context.getCurrentUser() != null)
+                {
+                    log.error("User(" + context.getCurrentUser().getEmail() + ") has not permission to "
+                            + getActionString(action) + " collection!");
+                }
+                else
+                {
+                    log.error("User(anonymous) has not permission to " + getActionString(action) + " collection!");
+                }
+                throw new WebApplicationException(Response.Status.UNAUTHORIZED);
+            }
+
+        }
+        catch (SQLException e)
+        {
+            processException("Something get wrong while finding collection(id=" + id + "). SQLException, Message: " + e, context);
+        }
+        return collection;
+    }
+}
diff --git a/dspace/modules/rest/src/main/java/org/dspace/rest/ItemsResource.java b/dspace/modules/rest/src/main/java/org/dspace/rest/ItemsResource.java
new file mode 100644
index 0000000000000000000000000000000000000000..8a2d753ee3145269f26350035a534ba5aa66f013
--- /dev/null
+++ b/dspace/modules/rest/src/main/java/org/dspace/rest/ItemsResource.java
@@ -0,0 +1,1025 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.rest;
+
+import org.dspace.authority.AuthorityUtil;
+import org.apache.log4j.Logger;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.authorize.factory.AuthorizeServiceFactory;
+import org.dspace.authorize.service.AuthorizeService;
+import org.dspace.authorize.service.ResourcePolicyService;
+import org.dspace.content.Bundle;
+import org.dspace.content.factory.ContentServiceFactory;
+import org.dspace.content.service.*;
+import org.dspace.eperson.factory.EPersonServiceFactory;
+import org.dspace.eperson.service.GroupService;
+import org.dspace.rest.common.Bitstream;
+import org.dspace.rest.common.Item;
+import org.dspace.rest.common.MetadataEntry;
+import org.dspace.rest.exceptions.ContextException;
+import org.dspace.usage.UsageEvent;
+
+import javax.servlet.http.HttpServletRequest;
+import javax.ws.rs.*;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.core.Response.Status;
+import java.io.IOException;
+import java.io.InputStream;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * Class which provide all CRUD methods over items.
+ * 
+ * @author Rostislav Novak (Computing and Information Centre, CTU in Prague)
+ * 
+ */
+// Every DSpace class used without namespace is from package org.dspace.rest.common.*. Otherwise namespace is defined.
+@SuppressWarnings("deprecation")
+@Path("/items")
+public class ItemsResource extends Resource
+{
+    protected CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();
+    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();
+    protected AuthorizeService authorizeService = AuthorizeServiceFactory.getInstance().getAuthorizeService();
+    protected BitstreamService bitstreamService = ContentServiceFactory.getInstance().getBitstreamService();
+    protected BitstreamFormatService bitstreamFormatService = ContentServiceFactory.getInstance().getBitstreamFormatService();
+    protected BundleService bundleService = ContentServiceFactory.getInstance().getBundleService();
+    protected ResourcePolicyService resourcePolicyService = AuthorizeServiceFactory.getInstance().getResourcePolicyService();
+    protected GroupService groupService = EPersonServiceFactory.getInstance().getGroupService();
+
+    private static final Logger log = Logger.getLogger(ItemsResource.class);
+
+    /**
+     * Return item properties without metadata and bitstreams. You can add
+     * additional properties by parameter expand.
+     * 
+     * @param itemId
+     *            Id of item in DSpace.
+     * @param expand
+     *            String which define, what additional properties will be in
+     *            returned item. Options are separeted by commas and are: "all",
+     *            "metadata", "parentCollection", "parentCollectionList",
+     *            "parentCommunityList" and "bitstreams".
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @return If user is allowed to read item, it returns item. Otherwise is
+     *         thrown WebApplicationException with response status
+     *         UNAUTHORIZED(401) or NOT_FOUND(404) if was id incorrect.
+     * @throws WebApplicationException
+     *             This exception can be throw by NOT_FOUND(bad id of item),
+     *             UNAUTHORIZED, SQLException if wasproblem with reading from
+     *             database and ContextException, if there was problem with
+     *             creating context of DSpace.
+     */
+    @GET
+    @Path("/{item_id}")
+    @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Item getItem(@PathParam("item_id") String itemId, @QueryParam("expand") String expand,
+            @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Reading item(id=" + itemId + ").");
+        org.dspace.core.Context context = null;
+        Item item = null;
+
+        try
+        {
+            context = createContext();
+            org.dspace.content.Item dspaceItem = findItem(context, itemId, org.dspace.core.Constants.READ);
+
+            writeStats(dspaceItem, UsageEvent.Action.VIEW, user_ip, user_agent, xforwardedfor, headers, request, context);
+
+            item = new Item(dspaceItem, servletContext, expand, context);
+            context.complete();
+            log.trace("Item(id=" + itemId + ") was successfully read.");
+
+        }
+        catch (SQLException e)
+        {
+            processException("Could not read item(id=" + itemId + "), SQLException. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Could not read item(id=" + itemId + "), ContextException. Message: " + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        return item;
+    }
+
+    /**
+     * It returns an array of items in DSpace. You can define how many items in
+     * list will be and from which index will start. Items in list are sorted by
+     * handle, not by id.
+     * 
+     * @param limit
+     *            How many items in array will be. Default value is 100.
+     * @param offset
+     *            On which index will array start. Default value is 0.
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @return Return array of items, on which has logged user into context
+     *         permission.
+     * @throws WebApplicationException
+     *             It can be thrown by SQLException, when was problem with
+     *             reading items from database or ContextException, when was
+     *             problem with creating context of DSpace.
+     */
+    @GET
+    @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Item[] getItems(@QueryParam("expand") String expand, @QueryParam("limit") @DefaultValue("100") Integer limit,
+            @QueryParam("offset") @DefaultValue("0") Integer offset, @QueryParam("userIP") String user_ip,
+            @QueryParam("userAgent") String user_agent, @QueryParam("xforwardedfor") String xforwardedfor,
+            @Context HttpHeaders headers, @Context HttpServletRequest request) throws WebApplicationException
+    {
+
+        log.info("Reading items.(offset=" + offset + ",limit=" + limit + ").");
+        org.dspace.core.Context context = null;
+        List<Item> items = null;
+
+        try
+        {
+            context = createContext();
+
+            Iterator<org.dspace.content.Item> dspaceItems = itemService.findAllUnfiltered(context);
+            items = new ArrayList<Item>();
+
+            if (!((limit != null) && (limit >= 0) && (offset != null) && (offset >= 0)))
+            {
+                log.warn("Paging was badly set, using default values.");
+                limit = 100;
+                offset = 0;
+            }
+
+            for (int i = 0; (dspaceItems.hasNext()) && (i < (limit + offset)); i++)
+            {
+                org.dspace.content.Item dspaceItem = dspaceItems.next();
+                if (i >= offset)
+                {
+                    if (itemService.isItemListedForUser(context, dspaceItem))
+                    {
+                        items.add(new Item(dspaceItem, servletContext, expand, context));
+                        writeStats(dspaceItem, UsageEvent.Action.VIEW, user_ip, user_agent, xforwardedfor,
+                                headers, request, context);
+                    }
+                }
+            }
+            context.complete();
+        }
+        catch (SQLException e)
+        {
+            processException("Something went wrong while reading items from database. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Something went wrong while reading items, ContextException. Message: " + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.trace("Items were successfully read.");
+        return items.toArray(new Item[0]);
+    }
+
+    /**
+     * Returns item metadata in list.
+     * 
+     * @param itemId
+     *            Id of item in DSpace.
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @return Return list of metadata fields if was everything ok. Otherwise it
+     *         throw WebApplication exception with response code NOT_FOUND(404)
+     *         or UNAUTHORIZED(401).
+     * @throws WebApplicationException
+     *             It can be thrown by two exceptions: SQLException if was
+     *             problem wtih reading item from database and ContextException,
+     *             if was problem with creating context of DSpace. And can be
+     *             thrown by NOT_FOUND and UNAUTHORIZED too.
+     */
+    @GET
+    @Path("/{item_id}/metadata")
+    @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public MetadataEntry[] getItemMetadata(@PathParam("item_id") String itemId, @QueryParam("userIP") String user_ip,
+            @QueryParam("userAgent") String user_agent, @QueryParam("xforwardedfor") String xforwardedfor,
+            @Context HttpHeaders headers, @Context HttpServletRequest request) throws WebApplicationException
+    {
+
+        log.info("Reading item(id=" + itemId + ") metadata.");
+        org.dspace.core.Context context = null;
+        List<MetadataEntry> metadata = null;
+
+        try
+        {
+            context = createContext();
+            org.dspace.content.Item dspaceItem = findItem(context, itemId, org.dspace.core.Constants.READ);
+
+            writeStats(dspaceItem, UsageEvent.Action.VIEW, user_ip, user_agent, xforwardedfor, headers, request, context);
+
+            metadata = new Item(dspaceItem, servletContext, "metadata", context).getMetadata();
+            context.complete();
+        }
+        catch (SQLException e)
+        {
+            processException("Could not read item(id=" + itemId + "), SQLException. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Could not read item(id=" + itemId + "), ContextException. Message: " + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.trace("Item(id=" + itemId + ") metadata were successfully read.");
+        return metadata.toArray(new MetadataEntry[0]);
+    }
+
+    /**
+     * Return array of bitstreams in item. It can be paged.
+     *
+     * @param itemId
+     *            Id of item in DSpace.
+     * @param limit
+     *            How many items will be in array.
+     * @param offset
+     *            On which index will start array.
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @return Return paged array of bitstreams in item.
+     * @throws WebApplicationException
+     *             It can be throw by NOT_FOUND, UNAUTHORIZED, SQLException if
+     *             was problem with reading from database and ContextException
+     *             if was problem with creating context of DSpace.
+     */
+    @GET
+    @Path("/{item_id}/bitstreams")
+    @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Bitstream[] getItemBitstreams(@PathParam("item_id") String itemId,
+            @QueryParam("limit") @DefaultValue("20") Integer limit, @QueryParam("offset") @DefaultValue("0") Integer offset,
+            @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Reading item(id=" + itemId + ") bitstreams.(offset=" + offset + ",limit=" + limit + ")");
+        org.dspace.core.Context context = null;
+        List<Bitstream> bitstreams = null;
+        try
+        {
+            context = createContext();
+            org.dspace.content.Item dspaceItem = findItem(context, itemId, org.dspace.core.Constants.READ);
+
+            writeStats(dspaceItem, UsageEvent.Action.VIEW, user_ip, user_agent, xforwardedfor, headers, request, context);
+
+            List<Bitstream> itemBitstreams = new Item(dspaceItem, servletContext, "bitstreams", context).getBitstreams();
+
+            if ((offset + limit) > (itemBitstreams.size() - offset))
+            {
+                bitstreams = itemBitstreams.subList(offset, itemBitstreams.size());
+            }
+            else
+            {
+                bitstreams = itemBitstreams.subList(offset, offset + limit);
+            }
+            context.complete();
+        }
+        catch (SQLException e)
+        {
+            processException("Could not read item(id=" + itemId + ") bitstreams, SQLExcpetion. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Could not read item(id=" + itemId + ") bitstreams, ContextException. Message: " + e.getMessage(),
+                    context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.trace("Item(id=" + itemId + ") bitstreams were successfully read.");
+        return bitstreams.toArray(new Bitstream[0]);
+    }
+
+    /**
+     * Adding metadata fields to item. If metadata key is in item, it will be
+     * added, NOT REPLACED!
+     *
+     * @param itemId
+     *            Id of item in DSpace.
+     * @param metadata
+     *            List of metadata fields, which will be added into item.
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @return It returns status code OK(200) if all was ok. UNAUTHORIZED(401)
+     *         if user is not allowed to write to item. NOT_FOUND(404) if id of
+     *         item is incorrect.
+     * @throws WebApplicationException
+     *             It is throw by these exceptions: SQLException, if was problem
+     *             with reading from database or writing to database.
+     *             AuthorizeException, if was problem with authorization to item
+     *             fields. ContextException, if was problem with creating
+     *             context of DSpace.
+     */
+    @POST
+    @Path("/{item_id}/metadata")
+    @Consumes({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Response addItemMetadata(@PathParam("item_id") String itemId, List<MetadataEntry> metadata,
+            @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Adding metadata to item(id=" + itemId + ").");
+        org.dspace.core.Context context = null;
+
+        try
+        {
+            context = createContext();
+            org.dspace.content.Item dspaceItem = findItem(context, itemId, org.dspace.core.Constants.WRITE);
+
+            writeStats(dspaceItem, UsageEvent.Action.UPDATE, user_ip, user_agent, xforwardedfor, headers, request, context);
+
+            for (MetadataEntry entry : metadata) {
+                addMetadataEntry(context, dspaceItem, entry);
+            }
+            context.complete();
+
+        }
+        catch (SQLException e)
+        {
+            processException("Could not write metadata to item(id=" + itemId + "), SQLException. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Could not write metadata to item(id=" + itemId + "), ContextException. Message: " + e.getMessage(),
+                    context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.info("Metadata to item(id=" + itemId + ") were successfully added.");
+        return Response.status(Status.OK).build();
+    }
+
+    private void addMetadataEntry(final org.dspace.core.Context context, final org.dspace.content.Item dspaceItem,
+                                  final MetadataEntry entry) throws SQLException {
+
+        String data[] = mySplit(entry.getKey());
+        if ((data.length >= 2) && (data.length <= 3)) {
+
+            new AuthorityUtil().addMetadata(context, dspaceItem, data, entry.getValue(), entry.getLanguage());
+        }
+    }
+
+    /**
+     * Create bitstream in item.
+     *
+     * @param itemId
+     *            Id of item in DSpace.
+     * @param inputStream
+     *            Data of bitstream in inputStream.
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @return Returns bitstream with status code OK(200). If id of item is
+     *         invalid , it returns status code NOT_FOUND(404). If user is not
+     *         allowed to write to item, UNAUTHORIZED(401).
+     * @throws WebApplicationException
+     *             It is thrown by these exceptions: SQLException, when was
+     *             problem with reading/writing from/to database.
+     *             AuthorizeException, when was problem with authorization to
+     *             item and add bitstream to item. IOException, when was problem
+     *             with creating file or reading from inpustream.
+     *             ContextException. When was problem with creating context of
+     *             DSpace.
+     */
+    // TODO Add option to add bitstream by URI.(for very big files)
+    @POST
+    @Path("/{item_id}/bitstreams")
+    public Bitstream addItemBitstream(@PathParam("item_id") String itemId, InputStream inputStream,
+            @QueryParam("name") String name, @QueryParam("description") String description,
+            @QueryParam("groupId") String groupId, @QueryParam("year") Integer year, @QueryParam("month") Integer month,
+            @QueryParam("day") Integer day, @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Adding bitstream to item(id=" + itemId + ").");
+        org.dspace.core.Context context = null;
+        Bitstream bitstream = null;
+
+        try
+        {
+            context = createContext();
+            org.dspace.content.Item dspaceItem = findItem(context, itemId, org.dspace.core.Constants.WRITE);
+
+            writeStats(dspaceItem, UsageEvent.Action.UPDATE, user_ip, user_agent, xforwardedfor, headers, request, context);
+
+            // Is better to add bitstream to ORIGINAL bundle or to item own?
+            log.trace("Creating bitstream in item.");
+            Bundle bundle = null;
+            org.dspace.content.Bitstream dspaceBitstream = null;
+            List<Bundle> bundles = itemService.getBundles(dspaceItem, org.dspace.core.Constants.CONTENT_BUNDLE_NAME);
+
+			if(bundles != null && bundles.size() != 0)
+			{
+				bundle = bundles.get(0); // There should be only one bundle ORIGINAL.
+			}
+            if (bundle == null)
+            {
+                log.trace("Creating bundle in item.");
+                dspaceBitstream = itemService.createSingleBitstream(context, inputStream, dspaceItem);
+            }
+            else
+            {
+                log.trace("Getting bundle from item.");
+                dspaceBitstream = bitstreamService.create(context, bundle, inputStream);
+            }
+
+            dspaceBitstream.setSource(context, "DSpace REST API");
+
+            // Set bitstream name and description
+            if (name != null)
+            {
+                if (BitstreamResource.getMimeType(name) == null)
+                {
+                    dspaceBitstream.setFormat(context, bitstreamFormatService.findUnknown(context));
+                }
+                else
+                {
+                    bitstreamService.setFormat(context, dspaceBitstream, bitstreamFormatService.findByMIMEType(context, BitstreamResource.getMimeType(name)));
+                }
+
+                dspaceBitstream.setName(context, name);
+            }
+            if (description != null)
+            {
+                dspaceBitstream.setDescription(context, description);
+            }
+
+            // Create policy for bitstream
+            if (groupId != null)
+            {
+                bundles = dspaceBitstream.getBundles();
+                for (Bundle dspaceBundle : bundles)
+                {
+                    List<org.dspace.authorize.ResourcePolicy> bitstreamsPolicies = bundleService.getBitstreamPolicies(context, dspaceBundle);
+
+                    // Remove default bitstream policies
+                    List<org.dspace.authorize.ResourcePolicy> policiesToRemove = new ArrayList<org.dspace.authorize.ResourcePolicy>();
+                    for (org.dspace.authorize.ResourcePolicy policy : bitstreamsPolicies) {
+                        if (policy.getdSpaceObject().getID().equals(dspaceBitstream.getID()))
+                        {
+                            policiesToRemove.add(policy);
+                        }
+                    }
+                    for (org.dspace.authorize.ResourcePolicy policy : policiesToRemove)
+                    {
+                        bitstreamsPolicies.remove(policy);
+                    }
+
+                    org.dspace.authorize.ResourcePolicy dspacePolicy = resourcePolicyService.create(context);
+                    dspacePolicy.setAction(org.dspace.core.Constants.READ);
+                    dspacePolicy.setGroup(groupService.findByIdOrLegacyId(context, groupId));
+                    dspacePolicy.setdSpaceObject(dspaceBitstream);
+                    if ((year != null) || (month != null) || (day != null))
+                    {
+                        Date date = new Date();
+                        if (year != null)
+                        {
+                            date.setYear(year - 1900);
+                        }
+                        if (month != null)
+                        {
+                            date.setMonth(month - 1);
+                        }
+                        if (day != null)
+                        {
+                            date.setDate(day);
+                        }
+                        date.setHours(0);
+                        date.setMinutes(0);
+                        date.setSeconds(0);
+                        dspacePolicy.setStartDate(date);
+                    }
+
+                    resourcePolicyService.update(context, dspacePolicy);
+
+                    bitstreamService.updateLastModified(context, dspaceBitstream);
+                }
+            }
+
+            dspaceBitstream = bitstreamService.find(context, dspaceBitstream.getID());
+            bitstream = new Bitstream(dspaceBitstream, servletContext, "", context);
+
+            context.complete();
+
+        }
+        catch (SQLException e)
+        {
+            processException("Could not create bitstream in item(id=" + itemId + "), SQLException. Message: " + e, context);
+        }
+        catch (AuthorizeException e)
+        {
+            processException("Could not create bitstream in item(id=" + itemId + "), AuthorizeException. Message: " + e, context);
+        }
+        catch (IOException e)
+        {
+            processException("Could not create bitstream in item(id=" + itemId + "), IOException Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException(
+                    "Could not create bitstream in item(id=" + itemId + "), ContextException Message: " + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.info("Bitstream(id=" + bitstream.getUUID() + ") was successfully added into item(id=" + itemId + ").");
+        return bitstream;
+    }
+
+    /**
+     * Replace all metadata in item with new passed metadata.
+     *
+     * @param itemId
+     *            Id of item in DSpace.
+     * @param metadata
+     *            List of metadata fields, which will replace old metadata in
+     *            item.
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @return It returns status code: OK(200). NOT_FOUND(404) if item was not
+     *         found, UNAUTHORIZED(401) if user is not allowed to write to item.
+     * @throws WebApplicationException
+     *             It is thrown by: SQLException, when was problem with database
+     *             reading or writting, AuthorizeException when was problem with
+     *             authorization to item and metadata fields. And
+     *             ContextException, when was problem with creating context of
+     *             DSpace.
+     */
+    @PUT
+    @Path("/{item_id}/metadata")
+    @Consumes({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Response updateItemMetadata(@PathParam("item_id") String itemId, MetadataEntry[] metadata,
+            @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Updating metadata in item(id=" + itemId + ").");
+        org.dspace.core.Context context = null;
+
+        try
+        {
+            context = createContext();
+            org.dspace.content.Item dspaceItem = findItem(context, itemId, org.dspace.core.Constants.WRITE);
+
+            writeStats(dspaceItem, UsageEvent.Action.UPDATE, user_ip, user_agent, xforwardedfor, headers, request, context);
+
+            log.trace("Deleting original metadata from item.");
+            for (MetadataEntry entry : metadata)
+            {
+                String data[] = mySplit(entry.getKey());
+                if ((data.length >= 2) && (data.length <= 3))
+                {
+                    itemService.clearMetadata(context, dspaceItem, data[0], data[1], data[2], org.dspace.content.Item.ANY);
+                }
+            }
+
+            log.trace("Adding new metadata to item.");
+            for (MetadataEntry entry : metadata) {
+                addMetadataEntry(context, dspaceItem, entry);
+            }
+            //Update the item to ensure that all the events get fired.
+            itemService.update(context, dspaceItem);
+
+            context.complete();
+
+        }
+        catch (SQLException e)
+        {
+            processException("Could not update metadata in item(id=" + itemId + "), SQLException. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException(
+                    "Could not update metadata in item(id=" + itemId + "), ContextException. Message: " + e.getMessage(), context);
+        } catch (AuthorizeException e) {
+            processException(
+                    "Could not update metadata in item(id=" + itemId + "), AuthorizeException. Message: " + e.getMessage(), context);
+        } finally
+        {
+            processFinally(context);
+        }
+
+        log.info("Metadata of item(id=" + itemId + ") were successfully updated.");
+        return Response.status(Status.OK).build();
+    }
+
+    /**
+     * Delete item from DSpace. It delete bitstreams only from item bundle.
+     *
+     * @param itemId
+     *            Id of item which will be deleted.
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @return It returns status code: OK(200). NOT_FOUND(404) if item was not
+     *         found, UNAUTHORIZED(401) if user is not allowed to delete item
+     *         metadata.
+     * @throws WebApplicationException
+     *             It can be thrown by: SQLException, when was problem with
+     *             database reading. AuthorizeException, when was problem with
+     *             authorization to item.(read and delete) IOException, when was
+     *             problem with deleting bitstream file. ContextException, when
+     *             was problem with creating context of DSpace.
+     */
+    @DELETE
+    @Path("/{item_id}")
+    public Response deleteItem(@PathParam("item_id") String itemId, @QueryParam("userIP") String user_ip,
+            @QueryParam("userAgent") String user_agent, @QueryParam("xforwardedfor") String xforwardedfor,
+            @Context HttpHeaders headers, @Context HttpServletRequest request) throws WebApplicationException
+    {
+
+        log.info("Deleting item(id=" + itemId + ").");
+        org.dspace.core.Context context = null;
+
+        try
+        {
+            context = createContext();
+            org.dspace.content.Item dspaceItem = findItem(context, itemId, org.dspace.core.Constants.DELETE);
+
+            writeStats(dspaceItem, UsageEvent.Action.REMOVE, user_ip, user_agent, xforwardedfor, headers, request, context);
+
+            log.trace("Deleting item.");
+            itemService.delete(context, dspaceItem);
+            context.complete();
+
+        }
+        catch (SQLException e)
+        {
+            processException("Could not delete item(id=" + itemId + "), SQLException. Message: " + e, context);
+        }
+        catch (AuthorizeException e)
+        {
+            processException("Could not delete item(id=" + itemId + "), AuthorizeException. Message: " + e, context);
+            throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);
+        }
+        catch (IOException e)
+        {
+            processException("Could not delete item(id=" + itemId + "), IOException. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Could not delete item(id=" + itemId + "), ContextException. Message: " + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.info("Item(id=" + itemId + ") was successfully deleted.");
+        return Response.status(Status.OK).build();
+    }
+
+    /**
+     * Delete all item metadata.
+     *
+     * @param itemId
+     *            Id of item in DSpace.
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @return It returns status code: OK(200). NOT_FOUND(404) if item was not
+     *         found, UNAUTHORIZED(401) if user is not allowed to delete item
+     *         metadata.
+     * @throws WebApplicationException
+     *             Thrown by three exceptions. SQLException, when there was
+     *             a problem reading item from database or editing metadata
+     *             fields. AuthorizeException, when there was a problem with
+     *             authorization to item. And ContextException, when there was a problem
+     *             with creating a DSpace context.
+     */
+    @DELETE
+    @Path("/{item_id}/metadata")
+    public Response deleteItemMetadata(@PathParam("item_id") String itemId, @QueryParam("userIP") String user_ip,
+            @QueryParam("userAgent") String user_agent, @QueryParam("xforwardedfor") String xforwardedfor,
+            @Context HttpHeaders headers, @Context HttpServletRequest request) throws WebApplicationException
+    {
+
+        log.info("Deleting metadata in item(id=" + itemId + ").");
+        org.dspace.core.Context context = null;
+
+        try
+        {
+            context = createContext();
+            org.dspace.content.Item dspaceItem = findItem(context, itemId, org.dspace.core.Constants.WRITE);
+
+            writeStats(dspaceItem, UsageEvent.Action.UPDATE, user_ip, user_agent, xforwardedfor, headers, request, context);
+
+            log.trace("Deleting metadata.");
+            // TODO Rewrite without deprecated object. Leave there only generated metadata.
+
+            String valueAccessioned = itemService.getMetadataFirstValue(dspaceItem, "dc", "date", "accessioned", org.dspace.content.Item.ANY);
+            String valueAvailable = itemService.getMetadataFirstValue(dspaceItem, "dc", "date", "available", org.dspace.content.Item.ANY);
+            String valueURI = itemService.getMetadataFirstValue(dspaceItem, "dc", "identifier", "uri", org.dspace.content.Item.ANY);
+            String valueProvenance = itemService.getMetadataFirstValue(dspaceItem, "dc", "description", "provenance", org.dspace.content.Item.ANY);
+
+            itemService.clearMetadata(context, dspaceItem, org.dspace.content.Item.ANY, org.dspace.content.Item.ANY, org.dspace.content.Item.ANY,
+                    org.dspace.content.Item.ANY);
+
+            // Add their generated metadata
+            itemService.addMetadata(context, dspaceItem, "dc", "date", "accessioned", null, valueAccessioned);
+            itemService.addMetadata(context, dspaceItem, "dc", "date", "available", null, valueAvailable);
+            itemService.addMetadata(context, dspaceItem, "dc", "identifier", "uri", null, valueURI);
+            itemService.addMetadata(context, dspaceItem, "dc", "description", "provenance", null, valueProvenance);
+
+            context.complete();
+        }
+        catch (SQLException e)
+        {
+            processException("Could not delete item(id=" + itemId + "), SQLException. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Could not delete item(id=" + itemId + "), ContextException. Message:" + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.info("Item(id=" + itemId + ") metadata were successfully deleted.");
+        return Response.status(Status.OK).build();
+    }
+
+    /**
+     * Delete bitstream from item bundle.
+     *
+     * @param itemId
+     *            Id of item in DSpace.
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @param bitstreamId
+     *            Id of bitstream, which will be deleted from bundle.
+     * @return Return status code OK(200) if is all ok. NOT_FOUND(404) if item
+     *         or bitstream was not found. UNAUTHORIZED(401) if user is not
+     *         allowed to delete bitstream.
+     * @throws WebApplicationException
+     *             It is thrown, when: Was problem with edditting database,
+     *             SQLException. Or problem with authorization to item, bundle
+     *             or bitstream, AuthorizeException. When was problem with
+     *             deleting file IOException. Or problem with creating context
+     *             of DSpace, ContextException.
+     */
+    @DELETE
+    @Path("/{item_id}/bitstreams/{bitstream_id}")
+    public Response deleteItemBitstream(@PathParam("item_id") String itemId, @PathParam("bitstream_id") String bitstreamId,
+            @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Deleting bitstream in item(id=" + itemId + ").");
+        org.dspace.core.Context context = null;
+
+        try
+        {
+            context = createContext();
+            org.dspace.content.Item item = findItem(context, itemId, org.dspace.core.Constants.WRITE);
+
+            org.dspace.content.Bitstream bitstream = bitstreamService.findByIdOrLegacyId(context, bitstreamId);
+            if (bitstream == null)
+            {
+                context.abort();
+                log.warn("Bitstream(id=" + bitstreamId + ") was not found.");
+                return Response.status(Status.NOT_FOUND).build();
+            }
+            else if (!authorizeService.authorizeActionBoolean(context, bitstream, org.dspace.core.Constants.DELETE))
+            {
+                context.abort();
+                log.error("User(" + context.getCurrentUser().getEmail() + ") is not allowed to delete bitstream(id=" + bitstreamId + ").");
+                return Response.status(Status.UNAUTHORIZED).build();
+            }
+
+            writeStats(item, UsageEvent.Action.UPDATE, user_ip, user_agent, xforwardedfor, headers, request, context);
+            writeStats(bitstream, UsageEvent.Action.REMOVE, user_ip, user_agent, xforwardedfor, headers,
+                    request, context);
+
+            log.trace("Deleting bitstream...");
+            bitstreamService.delete(context, bitstream);
+
+            context.complete();
+
+        }
+        catch (SQLException e)
+        {
+            processException("Could not delete bitstream(id=" + bitstreamId + "), SQLException. Message: " + e, context);
+        }
+        catch (AuthorizeException e)
+        {
+            processException("Could not delete bitstream(id=" + bitstreamId + "), AuthorizeException. Message: " + e, context);
+        }
+        catch (IOException e)
+        {
+            processException("Could not delete bitstream(id=" + bitstreamId + "), IOException. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Could not delete bitstream(id=" + bitstreamId + "), ContextException. Message:" + e.getMessage(),
+                    context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.info("Bitstream(id=" + bitstreamId + ") from item(id=" + itemId + ") was successfuly deleted .");
+        return Response.status(Status.OK).build();
+    }
+
+    /**
+     * Find items by one metadata field.
+     *
+     * @param metadataEntry
+     *            Metadata field to search by.
+     * @param headers
+     *            If you want to access the item as the user logged into context,
+     *            header "rest-dspace-token" must be set to token value retrieved
+     *            from the login method.
+     * @return Return array of found items.
+     * @throws WebApplicationException
+     *             Can be thrown: SQLException - problem with
+     *             database reading. AuthorizeException - problem with
+     *             authorization to item. IOException - problem with
+     *             reading from metadata field. ContextException -
+     *             problem with creating DSpace context.
+     */
+    @POST
+    @Path("/find-by-metadata-field")
+    @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Item[] findItemsByMetadataField(MetadataEntry metadataEntry, @QueryParam("expand") String expand,
+            @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Looking for item with metadata(key=" + metadataEntry.getKey() + ",value=" + metadataEntry.getValue()
+                + ", language=" + metadataEntry.getLanguage() + ").");
+        org.dspace.core.Context context = null;
+
+        List<Item> items = new ArrayList<Item>();
+        String[] metadata = mySplit(metadataEntry.getKey());
+
+        // Must used own style.
+        if ((metadata.length < 2) || (metadata.length > 3))
+        {
+            log.error("Finding failed, bad metadata key.");
+            throw new WebApplicationException(Status.NOT_FOUND);
+        }
+
+        try
+        {
+            context = createContext();
+
+            Iterator<org.dspace.content.Item> itemIterator = itemService.findByMetadataField(context, metadataEntry.getSchema(),
+                    metadataEntry.getElement(), metadataEntry.getQualifier(), metadataEntry.getValue());
+
+            while (itemIterator.hasNext())
+            {
+                org.dspace.content.Item dspaceItem = itemIterator.next();
+                //Only return items that are available for the current user
+                if (itemService.isItemListedForUser(context, dspaceItem)) {
+                    Item item = new Item(dspaceItem, servletContext, expand, context);
+                    writeStats(dspaceItem, UsageEvent.Action.VIEW, user_ip, user_agent, xforwardedfor, headers,
+                            request, context);
+                    items.add(item);
+                }
+            }
+
+            context.complete();
+        }
+        catch (SQLException e)
+        {
+            processException("Something went wrong while finding item. SQLException, Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Context error:" + e.getMessage(), context);
+        } catch (AuthorizeException e) {
+            processException("Authorize error:" + e.getMessage(), context);
+        } catch (IOException e) {
+            processException("IO error:" + e.getMessage(), context);
+        } finally
+        {
+            processFinally(context);
+        }
+
+        if (items.size() == 0)
+        {
+            log.info("Items not found.");
+        }
+        else
+        {
+            log.info("Items were found.");
+        }
+
+        return items.toArray(new Item[0]);
+    }
+
+    /**
+     * Find item from DSpace database. It is encapsulation of method
+     * org.dspace.content.Item.find with checking if item exist and if user
+     * logged into context has permission to do passed action.
+     *
+     * @param context
+     *            Context of actual logged user.
+     * @param id
+     *            Id of item in DSpace.
+     * @param action
+     *            Constant from org.dspace.core.Constants.
+     * @return It returns DSpace item.
+     * @throws WebApplicationException
+     *             Is thrown when item with passed id is not exists and if user
+     *             has no permission to do passed action.
+     */
+    private org.dspace.content.Item findItem(org.dspace.core.Context context, String id, int action) throws WebApplicationException
+    {
+        org.dspace.content.Item item = null;
+        try
+        {
+            item = itemService.findByIdOrLegacyId(context, id);
+
+            if (item == null)
+            {
+                context.abort();
+                log.warn("Item(id=" + id + ") was not found!");
+                throw new WebApplicationException(Status.NOT_FOUND);
+            }
+            else if (!authorizeService.authorizeActionBoolean(context, item, action))
+            {
+                context.abort();
+                if (context.getCurrentUser() != null)
+                {
+                    log.error("User(" + context.getCurrentUser().getEmail() + ") has not permission to "
+                            + getActionString(action) + " item!");
+                }
+                else
+                {
+                    log.error("User(anonymous) has not permission to " + getActionString(action) + " item!");
+                }
+                throw new WebApplicationException(Status.UNAUTHORIZED);
+            }
+
+        }
+        catch (SQLException e)
+        {
+            processException("Something get wrong while finding item(id=" + id + "). SQLException, Message: " + e, context);
+        }
+        return item;
+    }
+}
diff --git a/dspace/modules/rest/src/main/java/org/dspace/rest/RestIndex.java b/dspace/modules/rest/src/main/java/org/dspace/rest/RestIndex.java
new file mode 100644
index 0000000000000000000000000000000000000000..9b8e06d13958d1720ec5448853ecbe1e6bf5271a
--- /dev/null
+++ b/dspace/modules/rest/src/main/java/org/dspace/rest/RestIndex.java
@@ -0,0 +1,292 @@
+/*
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.rest;
+
+import java.io.UnsupportedEncodingException;
+import java.sql.SQLException;
+import javax.servlet.ServletContext;
+import javax.ws.rs.Consumes;
+import javax.ws.rs.GET;
+import javax.ws.rs.POST;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+import javax.ws.rs.QueryParam;
+import javax.ws.rs.WebApplicationException;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+
+import org.apache.log4j.Logger;
+import org.dspace.eperson.EPerson;
+import org.dspace.eperson.factory.EPersonServiceFactory;
+import org.dspace.eperson.service.EPersonService;
+import org.dspace.rest.common.Status;
+import org.dspace.rest.exceptions.ContextException;
+
+/**
+ * Root of RESTful api. It provides login and logout. Also have method for
+ * printing every method which is provides by RESTful api.
+ *
+ * @author Rostislav Novak (Computing and Information Centre, CTU in Prague)
+ *
+ */
+@Path("/")
+public class RestIndex {
+    protected EPersonService epersonService = EPersonServiceFactory.getInstance().getEPersonService();
+    private static Logger log = Logger.getLogger(RestIndex.class);
+
+    /**
+     * Return html page with information about REST api. It contains methods all
+     * methods provide by REST api.
+     *
+     * @return HTML page which has information about all methods of REST api.
+     */
+    @GET
+    @Produces(MediaType.TEXT_HTML)
+    public String sayHtmlHello(@Context ServletContext servletContext) {
+    	// TODO Better graphics, add arguments to all methods. (limit, offset, item and so on)
+        return "<html><title>DSpace REST - index</title>" +
+                "<body>"
+                    + "<h1>DSpace REST API</h1>" +
+                    "Server path: " + servletContext.getContextPath() +
+                    "<h2>Index</h2>" +
+                        "<ul>" +
+                            "<li>GET / - Return this page.</li>" +
+                            "<li>GET /test - Return the string \"REST api is running\" for testing purposes.</li>" +
+                            "<li>POST /login - Method for logging into the DSpace RESTful API. You must post the parameters \"email\" and \"password\". Example: \"email=test@dspace&password=pass\". Returns a JSESSIONID cookie which can be used for future authenticated requests.</li>" +
+                            "<li>GET /shibboleth-login - Method for logging into the DSpace RESTful API with Shibboleth. You must configure Shibboleth to pass the Shibboleth session to this endpoint. This will return you a JSESSIONID cookie which must be included in future requests.</li>" +
+                            "<li>GET /status - Method for retrieving information on the current authenticated user. The request must include the JSESSIONID cookie.</li>" +
+                            "<li>GET /logout - Method for logging out of the DSpace RESTful API. The request must include the JSESSIONID cookie.</li>" +
+                        "</ul>" +
+                    "<h2>Communities</h2>" +
+                        "<ul>" +
+                            "<li>GET /communities - Return an array of all communities in DSpace.</li>" +
+                            "<li>GET /communities/top-communities - Returns an array of all top-leve communities in DSpace.</li>" +
+                            "<li>GET /communities/{communityId} - Returns a community with the specified ID.</li>" +
+                            "<li>GET /communities/{communityId}/collections - Returns an array of collections of the specified community.</li>" +
+                            "<li>GET /communities/{communityId}/communities - Returns an array of subcommunities of the specified community.</li>" +
+                            "<li>POST /communities - Create a new top-level community. You must post a community.</li>" +
+                            "<li>POST /communities/{communityId}/collections - Create a new collection in the specified community. You must post a collection.</li>" +
+                            "<li>POST /communities/{communityId}/communities - Create a new subcommunity in the specified community. You must post a community.</li>" +
+                            "<li>PUT /communities/{communityId} - Update the specified community.</li>" +
+                            "<li>DELETE /communities/{communityId} - Delete the specified community.</li>" +
+                            "<li>DELETE /communities/{communityId}/collections/{collectionId} - Delete the specified collection in the specified community.</li>" +
+                            "<li>DELETE /communities/{communityId}/communities/{communityId2} - Delete the specified subcommunity (communityId2) in the specified community (communityId).</li>" +
+                        "</ul>" +
+                    "<h2>Collections</h2>" +
+                    "<ul>" +
+                          "<li>GET /collections - Return all DSpace collections in array.</li>" +
+                          "<li>GET /collections/{collectionId} - Return a collection with the specified ID.</li>" +
+                          "<li>GET /collections/{collectionId}/items - Return all items of the specified collection.</li>" +
+                          "<li>POST /collections/{collectionId}/items - Create an item in the specified collection. You must post an item.</li>" +
+                          "<li>POST /collections/find-collection - Find a collection by name.</li>" +
+                          "<li>PUT /collections/{collectionId} </li> - Update the specified collection. You must post a collection." +
+                          "<li>DELETE /collections/{collectionId} - Delete the specified collection from DSpace.</li>" +
+                          "<li>DELETE /collections/{collectionId}/items/{itemId} - Delete the specified item (itemId) in the specified collection (collectionId). </li>" +
+                      "</ul>" +
+                      "<h2>Items</h2>" +
+                      "<ul>" +
+                          "<li>GET /items - Return a list of items.</li>" +
+                          "<li>GET /items/{item id} - Return the specified item.</li>" +
+                          "<li>GET /items/{item id}/metadata - Return metadata of the specified item.</li>" +
+                          "<li>GET /items/{item id}/bitstreams - Return bitstreams of the specified item.</li>" +
+                          "<li>POST /items/find-by-metadata-field - Find items by the specified metadata value.</li>" +
+                          "<li>POST /items/{item id}/metadata - Add metadata to the specified item.</li>" +
+                          "<li>POST /items/{item id}/bitstreams - Add a bitstream to the specified item.</li>" +
+                          "<li>PUT /items/{item id}/metadata - Update metadata in the specified item.</li>" +
+                          "<li>DELETE /items/{item id} - Delete the specified item.</li>" +
+                          "<li>DELETE /items/{item id}/metadata - Clear metadata of the specified item.</li>" +
+                          "<li>DELETE /items/{item id}/bitstreams/{bitstream id} - Delete the specified bitstream of the specified item.</li>" +
+                      "</ul>" +
+                      "<h2>Bitstreams</h2>" +
+                      "<ul>" +
+                          "<li>GET /bitstreams - Return all bitstreams in DSpace.</li>" +
+                          "<li>GET /bitstreams/{bitstream id} - Return the specified bitstream.</li>" +
+                          "<li>GET /bitstreams/{bitstream id}/policy - Return policies of the specified bitstream.</li>" +
+                          "<li>GET /bitstreams/{bitstream id}/retrieve - Return the contents of the specified bitstream.</li>" +
+                          "<li>POST /bitstreams/{bitstream id}/policy - Add a policy to the specified bitstream.</li>" +
+                          "<li>PUT /bitstreams/{bitstream id}/data - Update the contents of the specified bitstream.</li>" +
+                          "<li>PUT /bitstreams/{bitstream id} - Update metadata of the specified bitstream.</li>" +
+                          "<li>DELETE /bitstreams/{bitstream id} - Delete the specified bitstream from DSpace.</li>" +
+                          "<li>DELETE /bitstreams/{bitstream id}/policy/{policy_id} - Delete the specified bitstream policy.</li>" +
+                      "</ul>" +
+                      "<h2>Hierarchy</h2>" +
+                      "<ul>" +
+                          "<li>GET /hierarchy - Return hierarchy of communities and collections in tree form. Each object is minimally populated (name, handle, id) for efficient retrieval.</li>" +
+                      "</ul>" +
+                    "<h2>Metadata and Schema Registry</h2>" +
+                    "<ul>" +
+                        "<li>GET /registries/schema - Return the list of metadata schemas in the registry</li>" +
+                        "<li>GET /registries/schema/{schema_prefix} - Returns the specified metadata schema</li>" +
+                        "<li>GET /registries/schema/{schema_prefix}/metadata-fields/{element} - Returns the metadata field within a schema with an unqualified element name</li>" +
+                        "<li>GET /registries/schema/{schema_prefix}/metadata-fields/{element}/{qualifier} - Returns the metadata field within a schema with a qualified element name</li>" +
+                        "<li>POST /registries/schema/ - Add a schema to the schema registry</li>" +
+                        "<li>POST /registries/schema/{schema_prefix}/metadata-fields - Add a metadata field to the specified schema</li>" +
+                        "<li>GET /registries/metadata-fields/{field_id} - Return the specified metadata field</li>" +
+                        "<li>PUT /registries/metadata-fields/{field_id} - Update the specified metadata field</li>" +
+                        "<li>DELETE /registries/metadata-fields/{field_id} - Delete the specified metadata field from the metadata field registry</li>" +
+                        "<li>DELETE /registries/schema/{schema_id} - Delete the specified schema from the schema registry</li>" +
+                    "</ul>" +
+                    "<h2>Query/Reporting Tools</h2>" +
+                    "<ul>" +
+                        "<li>GET /reports - Return a list of report tools built on the rest api</li>" +
+                        "<li>GET /reports/{nickname} - Return a redirect to a specific report</li>" +
+                        "<li>GET /filters - Return a list of use case filters available for quality control reporting</li>" +
+                        "<li>GET /filtered-collections - Return collections and item counts based on pre-defined filters</li>" +
+                        "<li>GET /filtered-collections/{collection_id} - Return items and item counts for a collection based on pre-defined filters</li>" +
+                        "<li>GET /filtered-items - Retrieve a set of items based on a metadata query and a set of filters</li>" +
+                    "</ul>" +
+                    "<h2>Authorities</h2>" +
+                    "<ul>" +
+                        "<li>PUT /authorities/{authority key}/value - Update the name on an authority. </li>" +
+                    "</ul>" +
+
+                "</body></html> ";
+    }
+
+    /**
+     * Method only for testing whether the REST API is running.
+     *
+     * @return String "REST api is running."
+     */
+    @GET
+    @Path("/test")
+    public String test()
+    {
+        return "REST api is running.";
+    }
+
+    /**
+     * Method to login a user into REST API.
+     *
+     * @return Returns response code OK and a token. Otherwise returns response
+     *         code FORBIDDEN(403).
+     */
+    @POST
+    @Path("/login")
+    @Consumes({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Response login(@QueryParam("email") String user, @QueryParam("password") String password)
+    {
+        //If you can get here, you should be authenticated, the actual login is handled by spring security.
+        //If not, the provided credentials are invalid.
+
+        return getLoginResponse("Authentication failed for user " + user + ": The credentials you provided are not valid.");
+    }
+
+    @GET
+    @Path("/shibboleth-login")
+    @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
+    public Response shibbolethLogin()
+    {
+        //If you can get here, you should be authenticated, the actual login is handled by spring security.
+        //If not, no valid Shibboleth session is present or Shibboleth config is missing.
+
+        /* Make sure to apply
+           - AuthType shibboleth
+           - ShibRequireSession On
+           - ShibUseHeaders On
+           - require valid-user
+           to this endpoint. The Shibboleth daemon will then take care of redirecting you to the login page if
+           necessary.
+         */
+
+        return getLoginResponse("Shibboleth authentication failed: No valid Shibboleth session could be found.");
+    }
+
+    protected Response getLoginResponse(String failedMessage) {
+        //Get the context and check if we have an authenticated eperson
+
+        org.dspace.core.Context context = null;
+        try {
+            context = Resource.createContext();
+        } catch (ContextException e) {
+            log.error("Unable to create context: " + e.getMessage(), e);
+            return Response.serverError().entity(e.getMessage()).build();
+        } catch (SQLException e) {
+            log.error("Unable to load user information from the database: " + e.getMessage(), e);
+            return Response.serverError().entity(e.getMessage()).build();
+        } catch (WebApplicationException e) {
+            log.warn("REST API authentication failed.");
+            context = null;
+        }
+
+        if(context == null || context.getCurrentUser() == null) {
+            return Response.status(Response.Status.FORBIDDEN)
+                    .entity(failedMessage)
+                    .build();
+        } else {
+            //We have a user, so the login was successful.
+            return Response.ok().build();
+        }
+    }
+
+    /**
+     * Method to logout a user from DSpace REST API. Removes the token and user from
+     * TokenHolder.
+     *
+     * @param headers
+     *            Request header which contains the header named
+     *            "rest-dspace-token" containing the token as value.
+     * @return Return response OK, otherwise BAD_REQUEST, if there was a problem with
+     *         logout or the token is incorrect.
+     */
+    @POST
+    @Path("/logout")
+    @Consumes({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Response logout(@Context HttpHeaders headers)
+    {
+        //If you can get here, you are logged out, this actual logout is handled by spring security
+        return Response.ok().build();
+    }
+
+    /**
+     * Method to check current status of the service and logged in user.
+     *
+     * okay: true | false
+     * authenticated: true | false
+     * epersonEMAIL: user@example.com
+     * epersonNAME: John Doe
+     * @param headers
+     *            Request header which contains the header named
+     *            "rest-dspace-token" containing the token as value.
+     * @return status
+     */
+    @GET
+    @Path("/status")
+    @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
+    public Status status(@Context HttpHeaders headers) throws UnsupportedEncodingException {
+        org.dspace.core.Context context = null;
+
+        try {
+            context = Resource.createContext();
+            EPerson ePerson = context.getCurrentUser();
+
+            if(ePerson != null) {
+                //DB EPerson needed since token won't have full info, need context
+                EPerson dbEPerson = epersonService.findByEmail(context, ePerson.getEmail());
+
+                Status status = new Status(dbEPerson.getEmail(), dbEPerson.getFullName());
+                return status;
+            }
+
+        } catch (ContextException e)
+        {
+            Resource.processException("Status context error: " + e.getMessage(), context);
+        } catch (SQLException e) {
+            Resource.processException("Status eperson db lookup error: " + e.getMessage(), context);
+        } finally {
+            context.abort();
+        }
+
+        //fallback status, unauth
+        return new Status();
+    }
+
+
+}
diff --git a/dspace/modules/rest/src/main/java/org/dspace/rest/common/Item.java b/dspace/modules/rest/src/main/java/org/dspace/rest/common/Item.java
new file mode 100644
index 0000000000000000000000000000000000000000..054f983ca624921bd49d6ceeeeb008c698895db1
--- /dev/null
+++ b/dspace/modules/rest/src/main/java/org/dspace/rest/common/Item.java
@@ -0,0 +1,231 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ * <p>
+ * http://www.dspace.org/license/
+ */
+package org.dspace.rest.common;
+
+import org.apache.commons.lang3.StringUtils;
+import org.apache.log4j.Logger;
+import org.dspace.app.util.factory.UtilServiceFactory;
+import org.dspace.app.util.service.MetadataExposureService;
+import org.dspace.authority.AuthorityValue;
+import org.dspace.authority.factory.AuthorityServiceFactory;
+import org.dspace.authority.orcid.Orcidv2AuthorityValue;
+import org.dspace.authorize.factory.AuthorizeServiceFactory;
+import org.dspace.authorize.service.AuthorizeService;
+import org.dspace.content.Bundle;
+import org.dspace.content.MetadataField;
+import org.dspace.content.MetadataValue;
+import org.dspace.content.factory.ContentServiceFactory;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+
+import javax.servlet.ServletContext;
+import javax.ws.rs.WebApplicationException;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlRootElement;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: peterdietz
+ * Date: 9/19/13
+ * Time: 4:50 PM
+ * To change this template use File | Settings | File Templates.
+ */
+@SuppressWarnings("deprecation")
+@XmlRootElement(name = "item")
+public class Item extends DSpaceObject {
+    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();
+    protected MetadataExposureService metadataExposureService = UtilServiceFactory.getInstance().getMetadataExposureService();
+    protected AuthorizeService authorizeService = AuthorizeServiceFactory.getInstance().getAuthorizeService();
+
+    Logger log = Logger.getLogger(Item.class);
+
+    String isArchived;
+    String isWithdrawn;
+    String lastModified;
+
+    Collection parentCollection;
+    List<Collection> parentCollectionList;
+    List<Community> parentCommunityList;
+    List<MetadataEntry> metadata;
+    List<Bitstream> bitstreams;
+
+    public Item() {
+    }
+
+    public Item(org.dspace.content.Item item, ServletContext servletContext, String expand, Context context) throws SQLException, WebApplicationException {
+        super(item, servletContext);
+        setup(item, servletContext, expand, context);
+    }
+
+    private void setup(org.dspace.content.Item item, ServletContext servletContext, String expand, Context context) throws SQLException {
+        List<String> expandFields = new ArrayList<String>();
+        if (expand != null) {
+            expandFields = Arrays.asList(expand.split(","));
+        }
+
+        if (expandFields.contains("metadata") || expandFields.contains("all")) {
+            metadata = new ArrayList<MetadataEntry>();
+            List<MetadataValue> metadataValues = itemService.getMetadata(item, org.dspace.content.Item.ANY, org.dspace.content.Item.ANY, org.dspace.content.Item.ANY, org.dspace.content.Item.ANY);
+
+            for (MetadataValue metadataValue : metadataValues) {
+                MetadataField metadataField = metadataValue.getMetadataField();
+                if (!metadataExposureService.isHidden(context, metadataField.getMetadataSchema().getName(), metadataField.getElement(), metadataField.getQualifier())) {
+                    metadata.add(new MetadataEntry(metadataField.toString('.'), assembleValue(context, metadataValue), metadataValue.getLanguage()));
+                }
+            }
+        } else {
+            this.addExpand("metadata");
+        }
+
+        this.setArchived(Boolean.toString(item.isArchived()));
+        this.setWithdrawn(Boolean.toString(item.isWithdrawn()));
+        this.setLastModified(item.getLastModified().toString());
+
+        if (expandFields.contains("parentCollection") || expandFields.contains("all")) {
+            if (item.getOwningCollection() != null) {
+                this.parentCollection = new Collection(item.getOwningCollection(), servletContext, null, context, null, null);
+            } else {
+                this.addExpand("parentCollection");
+            }
+        } else {
+            this.addExpand("parentCollection");
+        }
+
+        if (expandFields.contains("parentCollectionList") || expandFields.contains("all")) {
+            this.parentCollectionList = new ArrayList<Collection>();
+            List<org.dspace.content.Collection> collections = item.getCollections();
+            for (org.dspace.content.Collection collection : collections) {
+                this.parentCollectionList.add(new Collection(collection, servletContext, null, context, null, null));
+            }
+        } else {
+            this.addExpand("parentCollectionList");
+        }
+
+        if (expandFields.contains("parentCommunityList") || expandFields.contains("all")) {
+            this.parentCommunityList = new ArrayList<Community>();
+            List<org.dspace.content.Community> communities = itemService.getCommunities(context, item);
+
+            for (org.dspace.content.Community community : communities) {
+                this.parentCommunityList.add(new Community(community, servletContext, null, context));
+            }
+        } else {
+            this.addExpand("parentCommunityList");
+        }
+
+        //TODO: paging - offset, limit
+        if (expandFields.contains("bitstreams") || expandFields.contains("all")) {
+            bitstreams = new ArrayList<Bitstream>();
+
+            List<Bundle> bundles = item.getBundles();
+            for (Bundle bundle : bundles) {
+
+                List<org.dspace.content.Bitstream> itemBitstreams = bundle.getBitstreams();
+                for (org.dspace.content.Bitstream itemBitstream : itemBitstreams) {
+                    if (authorizeService.authorizeActionBoolean(context, itemBitstream, org.dspace.core.Constants.READ)) {
+                        bitstreams.add(new Bitstream(itemBitstream, servletContext, null, context));
+                    }
+                }
+            }
+        } else {
+            this.addExpand("bitstreams");
+        }
+
+        if (!expandFields.contains("all")) {
+            this.addExpand("all");
+        }
+    }
+
+    private String assembleValue(final Context context, final MetadataValue metadataValue) {
+        StringBuilder sb = new StringBuilder(metadataValue.getValue());
+
+        if (StringUtils.isNotBlank(metadataValue.getAuthority())) {
+
+            AuthorityValue authority = AuthorityServiceFactory.getInstance().getAuthorityValueService()
+                    .findByUID(context, metadataValue.getAuthority());
+
+            sb.append("::");
+            sb.append(authority.getId());
+
+            if (authority instanceof Orcidv2AuthorityValue) {
+                sb.append("::");
+                sb.append(((Orcidv2AuthorityValue) authority).getOrcid_id());
+            }
+        }
+
+        return sb.toString();
+    }
+
+    public String getArchived() {
+        return isArchived;
+    }
+
+    public void setArchived(String archived) {
+        isArchived = archived;
+    }
+
+    public String getWithdrawn() {
+        return isWithdrawn;
+    }
+
+    public void setWithdrawn(String withdrawn) {
+        isWithdrawn = withdrawn;
+    }
+
+    public String getLastModified() {
+        return lastModified;
+    }
+
+    public void setLastModified(String lastModified) {
+        this.lastModified = lastModified;
+    }
+
+    public Collection getParentCollection() {
+        return parentCollection;
+    }
+
+    public List<Collection> getParentCollectionList() {
+        return parentCollectionList;
+    }
+
+    public List<MetadataEntry> getMetadata() {
+        return metadata;
+    }
+
+    public List<Bitstream> getBitstreams() {
+        return bitstreams;
+    }
+
+    public List<Community> getParentCommunityList() {
+        return parentCommunityList;
+    }
+
+    public void setParentCollection(Collection parentCollection) {
+        this.parentCollection = parentCollection;
+    }
+
+    public void setParentCollectionList(List<Collection> parentCollectionList) {
+        this.parentCollectionList = parentCollectionList;
+    }
+
+    public void setParentCommunityList(List<Community> parentCommunityList) {
+        this.parentCommunityList = parentCommunityList;
+    }
+
+    @XmlElement(required = true)
+    public void setMetadata(List<MetadataEntry> metadata) {
+        this.metadata = metadata;
+    }
+
+    public void setBitstreams(List<Bitstream> bitstreams) {
+        this.bitstreams = bitstreams;
+    }
+}
diff --git a/dspace/modules/rest/src/main/webapp/WEB-INF/web.xml b/dspace/modules/rest/src/main/webapp/WEB-INF/web.xml
new file mode 100644
index 0000000000000000000000000000000000000000..60f7f69e536ee93dfff9c6b9317ac849605649c4
--- /dev/null
+++ b/dspace/modules/rest/src/main/webapp/WEB-INF/web.xml
@@ -0,0 +1,113 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+
+    The contents of this file are subject to the license and copyright
+    detailed in the LICENSE and NOTICE files at the root of the source
+    tree and available online at
+
+    http://www.dspace.org/license/
+
+-->
+<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://java.sun.com/xml/ns/javaee"
+         xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
+         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
+         id="WebApp_ID" version="2.5">
+
+    <filter>
+        <filter-name>dspace.request</filter-name>
+        <filter-class>org.dspace.utils.servlet.DSpaceWebappServletFilter</filter-class>
+    </filter>
+
+    <filter-mapping>
+        <filter-name>dspace.request</filter-name>
+        <url-pattern>/*</url-pattern>
+    </filter-mapping>
+
+
+    <filter>
+        <filter-name>springSecurityFilterChain</filter-name>
+        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
+    </filter>
+
+    <filter-mapping>
+        <filter-name>springSecurityFilterChain</filter-name>
+        <url-pattern>/*</url-pattern>
+    </filter-mapping>
+
+
+    <servlet>
+        <servlet-name>DSpace REST API</servlet-name>
+        <servlet-class>
+            org.glassfish.jersey.servlet.ServletContainer
+        </servlet-class>
+        <init-param>
+            <param-name>javax.ws.rs.Application</param-name>
+            <param-value>org.dspace.rest.DSpaceRestApplication</param-value>
+        </init-param>
+        <load-on-startup>1</load-on-startup>
+    </servlet>
+
+    <servlet-mapping>
+        <servlet-name>DSpace REST API</servlet-name>
+        <url-pattern>/*</url-pattern>
+    </servlet-mapping>
+
+    <servlet-mapping>
+        <servlet-name>default</servlet-name>
+        <url-pattern>/static/*</url-pattern>
+    </servlet-mapping>
+
+    <!-- Security settings and mapping -->
+    <security-constraint>
+        <web-resource-collection>
+            <web-resource-name>DSpace REST API</web-resource-name>
+            <url-pattern>/*</url-pattern>
+        </web-resource-collection>
+        <user-data-constraint>
+            <transport-guarantee>NONE</transport-guarantee>
+        </user-data-constraint>
+    </security-constraint>
+    
+    <!-- ConfigurationService initialization for dspace.dir -->
+    <context-param>
+        <description>
+            The location of the DSpace home directory
+        </description>
+        <param-name>dspace.dir</param-name>
+        <param-value>${dspace.dir}</param-value>
+    </context-param>
+
+    <context-param>
+        <param-name>contextConfigLocation</param-name>
+        <param-value>
+            /WEB-INF/applicationContext.xml,
+            /WEB-INF/security-applicationContext.xml
+        </param-value>
+    </context-param>
+
+    <listener>
+        <listener-class>org.dspace.app.util.DSpaceContextListener</listener-class>
+    </listener>
+
+    <!-- kernel start listener (from impl)
+        The following listener can be used instead of the filter below, it is simpler, cleaner
+        and eliminates the need for a DSpaceKernelServletFilter filter to be involved with the
+        request cycle.
+    -->
+    <listener>
+        <listener-class>org.dspace.servicemanager.servlet.DSpaceKernelServletContextListener</listener-class>
+    </listener>
+    
+    <listener>
+        <listener-class>
+            org.springframework.web.context.ContextLoaderListener
+        </listener-class>
+    </listener>
+
+    <listener>
+        <listener-class>org.dspace.app.util.DSpaceWebappListener</listener-class>
+    </listener>
+
+
+</web-app>
\ No newline at end of file
diff --git a/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/images/orcid_icon.png b/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/images/orcid_icon.png
new file mode 100644
index 0000000000000000000000000000000000000000..ef109145bc74c3f884d712ae2782ccedd29d096d
GIT binary patch
literal 1261
zcmbVMTWs4@7<LKtvaPIxQ4tX0;39;yB|f&}*f9x9V#hRN>8dnhK|*4#ebRWX?aX!;
zw;<GRg8@QQ1ur0ws02u`ham<+NC;MTsVGBz7#d<oyj7hTNU#<O#%&z8N#UW|1D5P_
z{&W8C`|p0Pzwe>W4R>rH2%<CJD;M$F6};`O_<Q&AH5D&mFIV;k?21=c9Ykbwdk}%V
zsScqcQuVR@b0|p=p^8x|d*#9|QM1jc8t6oQvxd<Gk=)_eRBae}U=R%%R*L-T<C7#X
z^c1;=E5JfcLRF)8+(855eI;#tSWD>Sjt4=~7cqf}JQeunh~<iYid^9p@jf`FNU);f
z4X4Oer^<zXAlVKATogt$7>6KEM`<?3^Za(eKpIkzp=c&T^CHWL5Q4@-Vr!0G5sR|Y
zu!W@*S@pb{NKy5AJz8g@wlhT0i9{mcV3-Kjh`3{xr}`1g?P)T|$kiO9<{7pH0!DSv
z9`#Zr_H;D_vsNgq5nFB}Q8;Ckuhu9!3MtbJ;#$#my(0S8jdiu%(pU{qMdaF}j)v<|
z>1l#-?yherP{iJdyBz};MIDiCZPY}TmzPr{zKQCFE^@piGf;pG$H2Hi<M3lrg5_vd
ziOU&*<C`4oVOds^gsc)%6pp9q94+t}A(s_|xWZ>8877+8yybeTrJ<%>1KVw2+3R9O
z$w8`TJ0;s5X?8$=)%I++YS(}?z=49Q8CD<%<ynnZMvid+>55~UU?snzv5tL3;uV_a
zV~}se%_%vVPta1F&cT>0lMSr?e{x1)XQ-e#{?jbYBiw<(cCGcXur@r%!V}}*(O5oI
z{e&P|?#j!VlK<_Xo(`RxfAl`$9UmM>za$c8Hooz~Q7YZ7%je%F-uycBUQ6hyTFbMc
z$<`FH|K+LJ>utu-SaNoH+bduGy!chyW33b0h0Pa2G_mh}B6KB996K_(<?^MgFs#3t
z`>m^Tf?kGy{{F{J-%ZQi)rrqC$N%D<*+wlgKc2jJj##>x@t3Z2ot`@q`MmWkt9F=M
z;nnHx(@V>bY<j}J1lyfs%<Xeq!NU*0EkAs}=ka;^HUFD0rte>Pnw*!jGn1W}wtK^1
zRy%xQB6Mcohg0uXKDuVzx%2XkXHR9HZ0UIZwuQ3rtA4|YU$RPdXL7fE%WUuYnT3(|
zjfc|U@ASdN&HbsV^x?`Tsj8@eWW%SJTYKKR7zQ)MJumM4)bIFUSMUSM=lbO1*}Vt<
E0ecprk^lez

literal 0
HcmV?d00001

diff --git a/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/styles/_style.scss b/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/styles/_style.scss
index 95b72eee1fa50564c1a98d4a2d5403cbed88d649..3b83125878c5d2e1e540abc1117019c4a86bf3bd 100644
--- a/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/styles/_style.scss
+++ b/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/styles/_style.scss
@@ -58,4 +58,13 @@
   #aspect_submission_StepTransformer_item_publication-title{
     margin-bottom:5px;
   }
+}
+
+.orcid_icon {
+
+    margin-top: -2px;
+
+    &:hover {
+        text-decoration: none;
+    }
 }
\ No newline at end of file
diff --git a/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/xsl/additions.xsl b/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/xsl/additions.xsl
new file mode 100644
index 0000000000000000000000000000000000000000..9edb9eecea718251c2263ce9c566b880db699d44
--- /dev/null
+++ b/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/xsl/additions.xsl
@@ -0,0 +1,76 @@
+<xsl:stylesheet
+        xmlns:i18n="http://apache.org/cocoon/i18n/2.1"
+        xmlns:dri="http://di.tamu.edu/DRI/1.0/"
+        xmlns:mets="http://www.loc.gov/METS/"
+        xmlns:dim="http://www.dspace.org/xmlns/dspace/dim"
+        xmlns:xlink="http://www.w3.org/TR/xlink/"
+        xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"
+        xmlns="http://www.w3.org/1999/xhtml"
+        xmlns:xalan="http://xml.apache.org/xalan"
+        xmlns:encoder="xalan://java.net.URLEncoder"
+        xmlns:confman="org.dspace.core.ConfigurationManager"
+        exclude-result-prefixes="i18n dri mets dim xlink xsl xalan encoder confman">
+
+    <xsl:output indent="yes"/>
+
+    <xsl:template name="itemSummaryView-DIM-authors-entry">
+        <div>
+            <xsl:if test="@authority">
+                <xsl:attribute name="class"><xsl:text>ds-dc_contributor_author-authority</xsl:text></xsl:attribute>
+            </xsl:if>
+            <xsl:choose>
+                <xsl:when test="@orcidID">
+                    <xsl:call-template name="renderDiscovery">
+                        <xsl:with-param name="value" select="node()"/>
+                        <xsl:with-param name="orcidID" select="@orcidID"/>
+                    </xsl:call-template>
+                    <xsl:call-template name="renderORCID"/>
+                </xsl:when>
+                <xsl:otherwise>
+                    <xsl:copy-of select="node()"/>
+                </xsl:otherwise>
+            </xsl:choose>
+        </div>
+    </xsl:template>
+
+    <xsl:template name="renderDiscovery">
+        <xsl:param name="value"/>
+        <xsl:param name="orcidID"/>
+        <a>
+            <xsl:attribute name="href">
+                <xsl:value-of select="$context-path"/>
+                <xsl:text>/discover?filtertype_1=orcidid</xsl:text>
+                <xsl:text>&amp;filter_relational_operator_1=equals&amp;filter_1=</xsl:text>
+                <xsl:value-of select="substring-after($orcidID, confman:getProperty('orcid.connector.url'))"/>
+            </xsl:attribute>
+            <xsl:value-of select="$value"/>
+        </a>
+    </xsl:template>
+
+    <xsl:template name="renderORCID">
+        <a class="orcid_icon" target="_blank" href="{@orcidID}">
+            <xsl:text> </xsl:text>
+            <img src="{$theme-path}images/orcid_icon.png" alt="cc"/>
+        </a>
+    </xsl:template>
+
+    <xsl:template match="dri:referenceSet[@id='aspect.artifactbrowser.ItemViewer.referenceSet.collection-viewer']/dri:reference" mode="summaryView">
+        <!-- simplified check to verify whether access rights are available in METS -->
+        <xsl:variable name='METSRIGHTS-enabled' select="contains(confman:getProperty('plugin.named.org.dspace.content.crosswalk.DisseminationCrosswalk'), 'METSRIGHTS')" />
+        <xsl:variable name="externalMetadataURL">
+            <xsl:text>cocoon:/</xsl:text>
+            <xsl:value-of select="@url"/>
+            <!-- If this is an Item, display the METSRIGHTS section, so we
+                 know which files have access restrictions.
+                 This requires the METSRightsCrosswalk to be enabled! -->
+            <xsl:if test="@type='DSpace Item' and $METSRIGHTS-enabled">
+                <xsl:text>?rightsMDTypes=METSRIGHTS</xsl:text>
+            </xsl:if>
+        </xsl:variable>
+        <!-- This comment just displays the full URL in an HTML comment, for easy reference. -->
+        <xsl:comment> External Metadata URL: <xsl:value-of select="$externalMetadataURL"/> </xsl:comment>
+        <xsl:apply-templates select="document($externalMetadataURL)" mode="summaryView"/>
+        <!--<xsl:apply-templates /> prevents the collections section from being rendered in the default way-->
+    </xsl:template>
+
+</xsl:stylesheet>
\ No newline at end of file
diff --git a/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/xsl/theme.xsl b/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/xsl/theme.xsl
new file mode 100644
index 0000000000000000000000000000000000000000..401da1880d49a8aaf1b80cfb3702b90d65625cbd
--- /dev/null
+++ b/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/xsl/theme.xsl
@@ -0,0 +1,55 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+
+    The contents of this file are subject to the license and copyright
+    detailed in the LICENSE and NOTICE files at the root of the source
+    tree and available online at
+
+    http://www.dspace.org/license/
+
+-->
+
+<!--
+    TODO: Describe this XSL file
+    Author: Alexey Maslov
+
+-->
+
+<xsl:stylesheet xmlns:i18n="http://apache.org/cocoon/i18n/2.1"
+	xmlns:dri="http://di.tamu.edu/DRI/1.0/"
+	xmlns:mets="http://www.loc.gov/METS/"
+	xmlns:xlink="http://www.w3.org/TR/xlink/"
+	xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"
+	xmlns:dim="http://www.dspace.org/xmlns/dspace/dim"
+	xmlns:xhtml="http://www.w3.org/1999/xhtml"
+	xmlns:mods="http://www.loc.gov/mods/v3"
+	xmlns:dc="http://purl.org/dc/elements/1.1/"
+	xmlns="http://www.w3.org/1999/xhtml"
+	exclude-result-prefixes="i18n dri mets xlink xsl dim xhtml mods dc">
+
+    <!--<xsl:import href="../dri2xhtml-alt/dri2xhtml.xsl"/>-->
+    <xsl:import href="aspect/artifactbrowser/artifactbrowser.xsl"/>
+    <xsl:import href="core/global-variables.xsl"/>
+    <xsl:import href="core/elements.xsl"/>
+    <xsl:import href="core/forms.xsl"/>
+    <xsl:import href="core/page-structure.xsl"/>
+    <xsl:import href="core/navigation.xsl"/>
+    <xsl:import href="core/attribute-handlers.xsl"/>
+    <xsl:import href="core/utils.xsl"/>
+    <xsl:import href="aspect/general/choice-authority-control.xsl"/>
+    <xsl:import href="aspect/general/vocabulary-support.xsl"/>
+    <!--<xsl:import href="xsl/aspect/administrative/administrative.xsl"/>-->
+    <xsl:import href="aspect/artifactbrowser/common.xsl"/>
+    <xsl:import href="aspect/artifactbrowser/item-list.xsl"/>
+    <xsl:import href="aspect/artifactbrowser/item-view.xsl"/>
+    <xsl:import href="aspect/artifactbrowser/community-list.xsl"/>
+    <xsl:import href="aspect/artifactbrowser/collection-list.xsl"/>
+    <xsl:import href="aspect/artifactbrowser/browse.xsl"/>
+    <xsl:import href="aspect/discovery/discovery.xsl"/>
+    <xsl:import href="aspect/artifactbrowser/one-offs.xsl"/>
+    <xsl:import href="aspect/submission/submission.xsl"/>
+    <xsl:import href="additions.xsl"/>
+    <xsl:output indent="yes"/>
+
+
+</xsl:stylesheet>
diff --git a/dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/cocoon/DSpaceMETSGenerator.java b/dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/cocoon/DSpaceMETSGenerator.java
new file mode 100644
index 0000000000000000000000000000000000000000..cf79d089d743c6cfe223535a38142928e3626a40
--- /dev/null
+++ b/dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/cocoon/DSpaceMETSGenerator.java
@@ -0,0 +1,245 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.xmlui.cocoon;
+
+import org.apache.cocoon.ProcessingException;
+import org.apache.cocoon.ResourceNotFoundException;
+import org.apache.cocoon.environment.ObjectModelHelper;
+import org.apache.cocoon.environment.Request;
+import org.apache.cocoon.generation.AbstractGenerator;
+import org.dspace.app.xmlui.objectmanager.AbstractAdapter;
+import org.dspace.app.xmlui.objectmanager.ContainerAdapter;
+import org.dspace.app.xmlui.objectmanager.ItemAdapter;
+import org.dspace.app.xmlui.objectmanager.RepositoryAdapter;
+import org.dspace.app.xmlui.utils.ContextUtil;
+import org.dspace.app.xmlui.wing.WingException;
+import org.dspace.content.Collection;
+import org.dspace.content.Community;
+import org.dspace.content.DSpaceObject;
+import org.dspace.content.Item;
+import org.dspace.content.crosswalk.CrosswalkException;
+import org.dspace.content.factory.ContentServiceFactory;
+import org.dspace.content.service.CollectionService;
+import org.dspace.content.service.CommunityService;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.dspace.handle.factory.HandleServiceFactory;
+import org.dspace.handle.service.HandleService;
+import org.xml.sax.SAXException;
+
+import java.io.IOException;
+import java.sql.SQLException;
+import java.util.UUID;
+
+/**
+ * Generate a METS document for the identified item, community or collection. The object to be rendered should be
+ * identified by passing in one of the two parameters: handle or internal. If an internal ID is given then it must
+ * be of the form "type:id" i.g. item:255 or community:4 or repository:123456789. In the case of a repository the
+ * id must be the handle prefix.
+ * 
+ * In addition to rendering a METS document there are several options which can be specified for how the mets
+ * document should be rendered. All parameters are a comma-separated list of values, here is a list:
+ * 
+ * 
+ * sections:
+ * 
+ * A comma-separated list of METS sections to included. The possible values are: "metsHdr", "dmdSec", 
+ * "amdSec", "fileSec", "structMap", "structLink", "behaviorSec", and "extraSec". If no list is provided then *ALL*
+ * sections are rendered.
+ * 
+ * 
+ * dmdTypes:
+ * 
+ * A comma-separated list of metadata formats to provide as descriptive metadata. The list of available metadata
+ * types is defined in the dspace.cfg, dissemination crosswalks. If no formats are provided them DIM - DSpace 
+ * Intermediate Format - is used.
+ * 
+ * 
+ * amdTypes:
+ * 
+ * A comma-separated list of metadata formats to provide administrative metadata. DSpace does not currently
+ * support this type of metadata.
+ * 
+ * 
+ * fileGrpTypes:
+ * 
+ * A comma-separated list of file groups to render. For DSpace a bundle is translated into a METS fileGrp, so
+ * possible values are "THUMBNAIL","CONTENT", "METADATA", etc... If no list is provided then all groups are
+ * rendered.
+ * 
+ * 
+ * structTypes:
+ * 
+ * A comma-separated list of structure types to render. For DSpace there is only one structType: LOGICAL. If this
+ * is provided then the logical structType will be rendered, otherwise none will. The default operation is to
+ * render all structure types.
+ * 
+ * @author Scott Phillips
+ */
+public class DSpaceMETSGenerator extends AbstractGenerator
+{
+    protected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();
+    protected CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();
+   	protected CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();
+    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();
+
+	/**
+	 * Generate the METS Document.
+     * @throws IOException passed through.
+     * @throws SAXException passed through.
+     * @throws ProcessingException on error.
+	 */
+    @Override
+	public void generate() throws IOException, SAXException, ProcessingException {
+		try {
+			// Open a new context.
+			Context context = ContextUtil.obtainContext(objectModel);
+			
+			// Determine which adapter to use
+			AbstractAdapter adapter = resolveAdapter(context);
+            if (adapter == null)
+            {
+                throw new ResourceNotFoundException("Unable to locate object.");
+            }
+            
+            // Configure the adapter for this request.
+            configureAdapter(adapter);
+            
+			// Generate the METS document
+			contentHandler.startDocument();
+			adapter.renderMETS(context, contentHandler,lexicalHandler);
+			contentHandler.endDocument();
+			
+		} catch (WingException we) {
+			throw new ProcessingException(we);
+		} catch (CrosswalkException ce) {
+			throw new ProcessingException(ce);
+		} catch (SQLException sqle) {
+			throw new ProcessingException(sqle);
+		}
+	}
+   
+	
+	
+	/**
+	 * Determine which type of adapter to use for this object, either a community, collection, item, or
+	 * repository adapter. The decision is based upon the two supplied identifiers: a handle or an
+	 * internal id. If the handle is supplied then this is resolved and the appropriate adapter is
+	 * picked. Otherwise the internal identifier is used to resolve the correct type of adapter.
+	 * 
+	 * The internal identifier must be of the form "type:id" i.g. item:255 or collection:99. In the
+	 * case of a repository the handle prefix must be used.
+	 * 
+	 * @return Return the correct adaptor or null if none found.
+	 */
+	private AbstractAdapter resolveAdapter(Context context) throws SQLException 
+	{			
+		Request request = ObjectModelHelper.getRequest(objectModel);
+        String contextPath = request.getContextPath();
+
+        // Determine the correct adapter to use for this item
+        String handle = parameters.getParameter("handle",null);
+        String internal = parameters.getParameter("internal",null);
+		
+        AbstractAdapter adapter = null;
+		 if (handle != null)
+         {
+            // Specified using a regular handle.
+            DSpaceObject dso = handleService.resolveToObject(context, handle);
+
+            // Handles can be either items or containers.
+            if (dso instanceof Item)
+            {
+                adapter = new ItemAdapter(context, (Item) dso, contextPath);
+            }
+         	else if (dso instanceof Collection || dso instanceof Community)
+            {
+                adapter = new ContainerAdapter(context, dso, contextPath);
+            }
+         }
+         else if (internal != null)
+         {
+        	// Internal identifier, format: "type:id".
+         	String[] parts = internal.split(":");
+         	
+         	if (parts.length == 2)
+         	{
+         		String type = parts[0];
+                       String strid = parts[1];
+         		UUID id = null;
+
+                        // Handle prefixes must be treated as strings
+                        // all non-repository types need integer IDs
+                        if ("repository".equals(type))
+                        {
+                                if (handleService.getPrefix().equals(strid))
+                                {
+                                    adapter = new RepositoryAdapter(context, contextPath);
+                                }
+                        }
+                        else
+                        {
+                               id = UUID.fromString(parts[1]);
+         			if ("item".equals(type))
+         			{
+         				Item item = itemService.find(context,id);
+         				if (item != null)
+                         {
+                             adapter = new ItemAdapter(context, item, contextPath);
+                         }
+         			}
+         			else if ("collection".equals(type))
+         			{
+         				Collection collection = collectionService.find(context,id);
+         				if (collection != null)
+                         {
+                             adapter = new ContainerAdapter(context, collection, contextPath);
+                         }
+         			}
+         			else if ("community".equals(type))
+         			{
+         				Community community = communityService.find(context,id);
+         				if (community != null)
+                         {
+                             adapter = new ContainerAdapter(context, community, contextPath);
+                         }
+         			}
+			}
+         	}
+         }
+		 return adapter;
+	}
+	
+	/**
+	 * Configure the adapter according to the supplied parameters.
+     * @param adapter the adapter.
+	 */
+	public void configureAdapter(AbstractAdapter adapter)
+	{
+        // Configure the adapter based upon the passed parameters
+        Request request = ObjectModelHelper.getRequest(objectModel);
+        String sections = request.getParameter("sections");
+        String dmdTypes = request.getParameter("dmdTypes");
+        String techMDTypes = request.getParameter("techMDTypes");
+        String rightsMDTypes = request.getParameter("rightsMDTypes");
+        String sourceMDTypes = request.getParameter("sourceMDTypes");
+        String digiprovMDTypes = request.getParameter("digiprovMDTypes");
+        String fileGrpTypes = request.getParameter("fileGrpTypes");
+        String structTypes = request.getParameter("structTypes");
+        
+        adapter.setSections(sections);
+        adapter.setDmdTypes(dmdTypes);
+        adapter.setTechMDTypes(techMDTypes);
+        adapter.setRightsMDTypes(rightsMDTypes);
+        adapter.setSourceMDTypes(sourceMDTypes);
+        adapter.setDigiProvMDTypes(digiprovMDTypes);
+        adapter.setFileGrpTypes(fileGrpTypes);
+        adapter.setStructTypes(structTypes);
+	}
+
+}
diff --git a/dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/objectmanager/AbstractAdapter.java b/dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/objectmanager/AbstractAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..fdd3eee0d6ba5bca75c8b397eae36a26e51b1161
--- /dev/null
+++ b/dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/objectmanager/AbstractAdapter.java
@@ -0,0 +1,769 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.xmlui.objectmanager;
+
+import org.dspace.app.util.Util;
+import org.dspace.app.xmlui.wing.AttributeMap;
+import org.dspace.app.xmlui.wing.Namespace;
+import org.dspace.app.xmlui.wing.WingException;
+import org.dspace.content.Bitstream;
+import org.dspace.content.BitstreamFormat;
+import org.dspace.content.Item;
+import org.dspace.content.crosswalk.CrosswalkException;
+import org.dspace.content.crosswalk.DisseminationCrosswalk;
+import org.dspace.core.Context;
+import org.dspace.core.factory.CoreServiceFactory;
+import org.xml.sax.ContentHandler;
+import org.xml.sax.SAXException;
+import org.xml.sax.ext.LexicalHandler;
+import org.xml.sax.helpers.AttributesImpl;
+import org.xml.sax.helpers.NamespaceSupport;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * This is the abstract adapter containing all the common elements between
+ * the three types of adapters: item, container, and repository. Each adapter
+ * translate a given type of DSpace object into a METS document for rendering
+ * into the DRI document.
+ * 
+ * <p>This class provides the chassis for those unique parts of the document to be
+ * built upon. There are seven rendering methods that may be overridden for each
+ * section of the METS document:
+ *
+ * <ul>
+ * <li>Header</li>
+ * <li>Descriptive Section</li>
+ * <li>Administrative Section</li>
+ * <li>File Section</li>
+ * <li>Structure Map</li>
+ * <li>Structural Link</li>
+ * <li>Behavioral Section</li>
+ * </ul>
+ *
+ * @author Scott Phillips
+ */
+
+public abstract class AbstractAdapter
+{
+    /** Namespace declaration for METS and XLINK */
+    public static final String METS_URI = "http://www.loc.gov/METS/";
+    public static final Namespace METS = new Namespace(METS_URI);
+    public static final String XLINK_URI = "http://www.w3.org/TR/xlink/";
+    public static final Namespace XLINK = new Namespace(XLINK_URI);
+    public static final String XSI_URI = "http://www.w3.org/2001/XMLSchema-instance";
+    public static final Namespace XSI = new Namespace(XSI_URI);
+    public static final String DIM_URI = "http://www.dspace.org/xmlns/dspace/dim";
+    public static final Namespace DIM = new Namespace(DIM_URI);    
+    
+    /**
+     * A sequence used to generate unique mets ids.
+     */
+    private int idSequence = 0;
+    
+    /**
+     * The contextPath of this web application, used for generating URLs.
+     */
+    protected String contextPath;
+    
+    /**
+     * The SAX handlers for content and lexical events. Also the support 
+     * element for namespaces which knows the prefixes for each declared 
+     * namespace.
+     */
+    protected ContentHandler contentHandler;
+    protected LexicalHandler lexicalHandler;
+    protected NamespaceSupport namespaces;
+    
+    /**
+     * Construct a new adapter, implementers must call this method so
+     * the appropriate internal values are ensured to be set correctly.
+     * 
+     * @param contextPath
+     *            The contextPath of this web application.
+     */
+    public AbstractAdapter(String contextPath)
+    {
+        this.contextPath = contextPath;
+    }
+
+    /** The variables that dictate what part of the METS document to render */
+    List<String> sections = new ArrayList<>();
+    List<String> dmdTypes = new ArrayList<>();
+    Map<String,List> amdTypes = new HashMap<>();
+    List<String> fileGrpTypes = new ArrayList<>();
+    List<String> structTypes = new ArrayList<>();
+    
+    /**
+     * A comma-separated list of METS sections to render. If no value 
+     * is provided then all METS sections are rendered.
+     * 
+     * @param sections Comma separated list of METS sections.
+     */
+    public final void setSections(String sections)
+    {
+    	if (sections == null)
+        {
+            return;
+        }
+
+    	for (String section : sections.split(","))
+    	{
+    		this.sections.add(section);
+    	}
+    }
+    
+    /**
+     * A comma-separated list of METS descriptive metadata formats to 
+     * render. If no value is provided then only the DIM format is used.
+     * 
+     * @param dmdTypes Comma separated list of METS metadata types.
+     */
+    public final void setDmdTypes(String dmdTypes)
+    {
+    	if (dmdTypes == null)
+        {
+            return;
+        }
+
+    	for (String dmdType : dmdTypes.split(","))
+    	{
+    		this.dmdTypes.add(dmdType);
+    	}
+    }
+    
+    /**
+     * Store information about what will be rendered in the METS administrative
+     * metadata section.  HashMap format: keys = amdSec, value = List of mdTypes
+     *
+     * @param amdSec Section of {@code <amdSec>} where this administrative metadata
+     *                will be rendered.
+     * @param mdTypes Comma-separated list of METS metadata types.
+     */
+    public final void setAmdTypes(String amdSec, String mdTypes)
+    {
+    	if (mdTypes == null)
+        {
+            return;
+        }
+
+        List<String> mdTypeList = new ArrayList<>();
+    	for (String mdType : mdTypes.split(","))
+    	{
+    		mdTypeList.add(mdType);
+    	}
+        
+        this.amdTypes.put(amdSec, mdTypeList);
+    }
+
+    /**
+     * A comma-separated list of METS technical metadata formats to
+     * render.
+     *
+     * @param techMDTypes Comma-separated list of METS metadata types.
+     */
+    public final void setTechMDTypes(String techMDTypes)
+    {
+    	setAmdTypes("techMD", techMDTypes);
+    }
+
+    /**
+     * A comma-separated list of METS intellectual property rights metadata
+     * formats to render.
+     *
+     * @param rightsMDTypes Comma-separated list of METS metadata types.
+     */
+    public final void setRightsMDTypes(String rightsMDTypes)
+    {
+    	setAmdTypes("rightsMD", rightsMDTypes);
+    }
+
+    /**
+     * A comma-separated list of METS source metadata
+     * formats to render.
+     *
+     * @param sourceMDTypes Comma-separated list of METS metadata types.
+     */
+    public final void setSourceMDTypes(String sourceMDTypes)
+    {
+    	setAmdTypes("sourceMD", sourceMDTypes);
+    }
+
+    /**
+     * A comma-separated list of METS digital provenance metadata
+     * formats to render.
+     *
+     * @param digiprovMDTypes Comma-separated list of METS metadata types.
+     */
+    public final void setDigiProvMDTypes(String digiprovMDTypes)
+    {
+    	setAmdTypes("digiprovMD", digiprovMDTypes);
+    }
+    
+    /**
+     * A comma-separated list of METS fileGrps to render. If no value
+     * is provided then all groups are rendered.
+     * 
+     * @param fileGrpTypes Comma-separated list of METS file groups.
+     */
+    public final void setFileGrpTypes(String fileGrpTypes)
+    {
+    	if (fileGrpTypes == null)
+        {
+            return;
+        }
+
+    	for (String fileGrpType : fileGrpTypes.split(","))
+    	{
+    		this.fileGrpTypes.add(fileGrpType);
+    	}
+    }
+    
+    /**
+     * A comma-separated list of METS structural types to render. If no 
+     * value is provided then only the DIM format is used.
+     * 
+     * @param structTypes Comma-separated list of METS structure types.
+     */
+    public final void setStructTypes(String structTypes)
+    {
+    	if (structTypes == null)
+        {
+            return;
+        }
+
+    	for (String structType : structTypes.split(","))
+    	{
+    		this.structTypes.add(structType);
+    	}
+    }
+	
+    
+    /**
+     * 
+     * 
+     * 
+     * 
+     * 
+     * METS methods
+     * 
+     * 
+     * 
+     * 
+     * 
+     * 
+     */
+    
+    
+    /**
+     * @return the URL for this item in the interface.
+     * @throws WingException on error.
+     */
+    protected abstract String getMETSOBJID() throws WingException;
+
+    /**
+     * @return the URL for editing this item
+     */
+    protected abstract String getMETSOBJEDIT();
+
+    /**
+     * @return the METS ID of the mets document.
+     * @throws WingException on error.
+     */
+    protected abstract String getMETSID() throws WingException;
+
+    /**
+     * @return The Profile this METS document conforms to.
+     * @throws WingException on error.
+     */
+    protected abstract String getMETSProfile() throws WingException;
+
+    /**
+     * @return The label of this METS document.
+     * @throws WingException on error.
+     */
+    protected abstract String getMETSLabel() throws WingException;
+
+
+	/**
+	 * Render the complete METS document.
+     * @param context session context.
+     * @param contentHandler XML content handler.
+     * @param lexicalHandler XML lexical handler.
+     * @throws WingException passed through.
+     * @throws SAXException passed through.
+     * @throws CrosswalkException passed through.
+     * @throws IOException passed through.
+     * @throws SQLException passed through.
+	 */
+    public final void renderMETS(Context context, ContentHandler contentHandler, LexicalHandler lexicalHandler)
+            throws WingException, SAXException, CrosswalkException, IOException, SQLException
+    {
+    		this.contentHandler = contentHandler;
+    		this.lexicalHandler = lexicalHandler;
+    		this.namespaces = new NamespaceSupport();
+
+
+    		// Declare our namespaces
+    		namespaces.pushContext();
+    		namespaces.declarePrefix("mets", METS.URI);
+    		namespaces.declarePrefix("xlink", XLINK.URI);
+    		namespaces.declarePrefix("xsi", XSI.URI);
+    		namespaces.declarePrefix("dim", DIM.URI);
+    		contentHandler.startPrefixMapping("mets", METS.URI);
+    		contentHandler.startPrefixMapping("xlink", XLINK.URI);
+    		contentHandler.startPrefixMapping("xsi", XSI.URI);
+    		contentHandler.startPrefixMapping("dim", DIM.URI);
+
+    		// Send the METS element
+    		AttributeMap attributes = new AttributeMap();
+    		attributes.put("ID", getMETSID());
+    		attributes.put("PROFILE", getMETSProfile());
+    		attributes.put("LABEL", getMETSLabel());
+    		String objid = getMETSOBJID();
+    		if (objid != null)
+            {
+                attributes.put("OBJID", objid);
+            }
+
+            // Include the link for editing the item
+            objid = getMETSOBJEDIT();
+            if (objid != null)
+            {
+                attributes.put("OBJEDIT", objid);
+            }
+
+    		startElement(METS,"METS",attributes);
+
+    		// If the user requested no specific sections then render them all.
+    		boolean all = (sections.isEmpty());
+
+    		if (all || sections.contains("metsHdr"))
+            {
+                renderHeader();
+            }
+    		if (all || sections.contains("dmdSec"))
+            {
+                renderDescriptiveSection();
+            }
+    		if (all || sections.contains("amdSec"))
+            {
+                renderAdministrativeSection();
+            }
+    		if (all || sections.contains("fileSec"))
+            {
+                renderFileSection(context);
+            }
+    		if (all || sections.contains("structMap"))
+            {
+                renderStructureMap();
+            }
+    		if (all || sections.contains("structLink"))
+            {
+                renderStructuralLink();
+            }
+    		if (all || sections.contains("behaviorSec"))
+            {
+                renderBehavioralSection();
+            }
+
+    		// FIXME: this is not a met's section, it should be removed
+    		if (all || sections.contains("extraSec"))
+            {
+                renderExtraSections();
+            }
+
+    		endElement(METS,"METS");
+    		contentHandler.endPrefixMapping("mets");
+    		contentHandler.endPrefixMapping("xlink");
+    		contentHandler.endPrefixMapping("dim");
+    		namespaces.popContext();
+
+    }
+
+    /*
+     * Each of the METS sections
+     */
+	protected void renderHeader() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}
+	protected void renderDescriptiveSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}
+	protected void renderAdministrativeSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}
+	protected void renderFileSection(Context context) throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}
+	protected void renderStructureMap() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}
+	protected void renderStructuralLink() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}
+	protected void renderBehavioralSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}
+	protected void renderExtraSections() throws WingException, SAXException, CrosswalkException, SQLException, IOException {}
+
+
+
+    /**
+     * Generate a METS file element for a given bitstream.
+     *
+     * @param context
+     *            Session context.
+     * @param item
+     *            If the bitstream is associated with an item provide the item
+     *            otherwise leave null.
+     * @param bitstream
+     *            The bitstream to build a file element for.
+     * @param fileID
+     *            The unique file id for this file.
+     * @param groupID
+     *            The group id for this file, if it is derived from another file
+     *            then they should share the same groupID.
+     * @throws SAXException passed through.
+     * @throws SQLException passed through.
+     */
+	protected final void renderFile(Context context, Item item, Bitstream bitstream, String fileID, String groupID)
+            throws SAXException, SQLException
+    {
+       renderFile(context, item, bitstream, fileID, groupID, null);
+    }
+
+	/**
+     * Generate a METS file element for a given bitstream.
+     *
+     * @param context
+     *            session context.
+     * @param item
+     *            If the bitstream is associated with an item, provide the item,
+     *            otherwise leave null.
+     * @param bitstream
+     *            The bitstream to build a file element for.
+     * @param fileID
+     *            The unique file id for this file.
+     * @param groupID
+     *            The group id for this file, if it is derived from another file
+     *            then they should share the same groupID.
+     * @param admID
+     *            The IDs of the administrative metadata sections which pertain
+     *            to this file
+     * @throws SAXException passed through.
+     * @throws SQLException passed through.
+     */
+	protected final void renderFile(Context context, Item item,
+            Bitstream bitstream, String fileID, String groupID, String admID)
+            throws SAXException, SQLException
+    {
+		AttributeMap attributes;
+
+		// //////////////////////////////
+    	// Determine the file attributes
+        BitstreamFormat format = bitstream.getFormat(context);
+        String mimeType = null;
+        if (format != null)
+        {
+            mimeType = format.getMIMEType();
+        }
+        String checksumType = bitstream.getChecksumAlgorithm();
+        String checksum = bitstream.getChecksum();
+        long size = bitstream.getSize();
+
+        // ////////////////////////////////
+        // Start the actual file
+        attributes = new AttributeMap();
+        attributes.put("ID", fileID);
+        attributes.put("GROUPID",groupID);
+        if (admID != null && admID.length()>0)
+        {
+            attributes.put("ADMID", admID);
+        }
+        if (mimeType != null && mimeType.length()>0)
+        {
+            attributes.put("MIMETYPE", mimeType);
+        }
+        if (checksumType != null && checksum != null)
+        {
+        	attributes.put("CHECKSUM", checksum);
+        	attributes.put("CHECKSUMTYPE", checksumType);
+        }
+        attributes.put("SIZE", String.valueOf(size));
+        startElement(METS,"file",attributes);
+
+
+        // ////////////////////////////////////
+        // Determine the file location attributes
+        String name = bitstream.getName();
+        String description = bitstream.getDescription();
+
+
+        // If possible, reference this bitstream via a handle, however this may
+        // be null if a handle has not yet been assigned. In this case reference the
+        // item its internal id. In the last case where the bitstream is not associated
+        // with an item (such as a community logo) then reference the bitstreamID directly.
+        String identifier = null;
+        if (item != null && item.getHandle() != null)
+        {
+            identifier = "handle/" + item.getHandle();
+        }
+        else if (item != null)
+        {
+            identifier = "item/" + item.getID();
+        }
+        else
+        {
+            identifier = "id/" + bitstream.getID();
+        }
+
+
+        String url = contextPath + "/bitstream/"+identifier+"/";
+
+        // If we can, append the pretty name of the bitstream to the URL
+        try
+        {
+        	if (bitstream.getName() != null)
+            {
+                url += Util.encodeBitstreamName(bitstream.getName(), "UTF-8");
+            }
+        }
+        catch (UnsupportedEncodingException uee)
+        {
+            // just ignore it, we don't have to have a pretty
+            // name at the end of the URL because the sequence id will
+        	// locate it. However it means that links in this file might
+        	// not work....
+        }
+
+        url += "?sequence="+bitstream.getSequenceID();
+
+
+        // //////////////////////
+        // Start the file location
+        attributes = new AttributeMap();
+        AttributeMap attributesXLINK = new AttributeMap();
+        attributesXLINK.setNamespace(XLINK);
+        attributes.put("LOCTYPE", "URL");
+        attributesXLINK.put("type","locator");
+        attributesXLINK.put("title", name);
+        if (description != null)
+        {
+            attributesXLINK.put("label", description);
+        }
+        attributesXLINK.put("href", url);
+        startElement(METS,"FLocat",attributes,attributesXLINK);
+
+
+        // ///////////////////////
+        // End file location
+        endElement(METS,"FLocate");
+
+        // ////////////////////////////////
+        // End the file
+        endElement(METS,"file");
+	}
+
+
+	/**
+     *
+     * Generate a unique METS id. For consistency, all prefixes should probably
+     * end in an underscore, "_".
+     *
+     * @param prefix
+     *            Prefix to prepend to the id for readability.
+     *
+     * @return A unique METS id.
+     */
+    protected final String getGenericID(String prefix)
+    {
+        return prefix + (idSequence++);
+    }
+
+    /**
+     * Return a dissemination crosswalk for the given name.
+     *
+     * @param crosswalkName name of crosswalk plugin to be looked up.
+     * @return The crosswalk.
+     * @throws WingException if crosswalk not found.
+     */
+    public final DisseminationCrosswalk getDisseminationCrosswalk(String crosswalkName) throws WingException
+    {
+    	// FIXME add some caching here
+    	DisseminationCrosswalk crosswalk
+                = (DisseminationCrosswalk) CoreServiceFactory.getInstance()
+                        .getPluginService()
+                        .getNamedPlugin(DisseminationCrosswalk.class, crosswalkName);
+
+	    if (crosswalk == null)
+        {
+            throw new WingException("Unable to find named DisseminationCrosswalk: " + crosswalkName);
+        }
+
+	    return crosswalk;
+    }
+
+    /**
+     * The METS defined types of Metadata, if a format is not listed here
+     * then it should use the string "OTHER" and provide additional
+     * attributes describing the metadata type
+     */
+    public static final String[] METS_DEFINED_TYPES =
+    	{"MARC","MODS","EAD","DC","NISOIMG","LC-AV","VRA","TEIHDR","DDI","FGDC","PREMIS"/*,"OTHER"*/};
+
+    /**
+     * Determine if the provided metadata type is a standard METS
+     * defined type. If it is not, use the other string.
+     *
+     * @param metadataType type name
+     * @return True if METS defined
+     */
+    public final boolean isDefinedMETStype(String metadataType)
+    {
+       for (String definedType : METS_DEFINED_TYPES)
+       {
+           if (definedType.equals(metadataType))
+           {
+               return true;
+           }
+       }
+       return false;
+    }
+
+
+
+
+
+    /**
+	 *
+	 *
+	 * SAX Helper methods
+	 *
+	 *
+	 *
+	 */
+
+	/**
+     * Send the SAX events to start this element.
+     *
+     * @param namespace
+     *            (Required) The namespace of this element.
+     * @param name
+     *            (Required) The local name of this element.
+     * @param attributes
+     *            (May be null) Attributes for this element
+     * @throws SAXException passed through.
+     */
+    protected final void startElement(Namespace namespace, String name,
+            AttributeMap... attributes) throws SAXException
+    {
+        contentHandler.startElement(namespace.URI, name, qName(namespace, name),
+                map2sax(namespace,attributes));
+    }
+
+    /**
+     * Send the SAX event for these plain characters, not wrapped in any
+     * elements.
+     *
+     * @param characters
+     *            (May be null) Characters to send.
+     * @throws SAXException passed through.
+     */
+    protected final void sendCharacters(String characters) throws SAXException
+    {
+        if (characters != null)
+        {
+            char[] contentArray = characters.toCharArray();
+            contentHandler.characters(contentArray, 0, contentArray.length);
+        }
+    }
+
+    /**
+     * Send the SAX events to end this element.
+     *
+     * @param namespace
+     *            (Required) The namespace of this element.
+     * @param name
+     *            (Required) The local name of this element.
+     * @throws SAXException passed through.
+     */
+    protected final void endElement(Namespace namespace, String name)
+            throws SAXException
+    {
+        contentHandler.endElement(namespace.URI, name, qName(namespace, name));
+    }
+
+    /**
+     * Build the SAX attributes object based upon Java's String map. This
+     * convenience method will build, or add to an existing attributes object,
+     * the attributes detailed in the AttributeMap.
+     * 
+     * @param elementNamespace
+     *            SAX Helper class to keep track of namespaces able to determine
+     *            the correct prefix for a given namespace URI.
+     * @param attributes
+     *            An existing SAX AttributesImpl object to add attributes to.
+     *            If the value is null then a new attributes object will be
+     *            created to house the attributes.
+     * @param attributeMap
+     *            A map of attributes and values.
+     * @return
+     */
+    private AttributesImpl map2sax(Namespace elementNamespace, AttributeMap ... attributeMaps)
+    {
+
+        AttributesImpl attributes = new AttributesImpl();
+        for (AttributeMap attributeMap : attributeMaps)
+        {
+            boolean differentNamespaces = false;
+            Namespace attributeNamespace = attributeMap.getNamespace();
+            if (attributeNamespace != null && !(attributeNamespace.URI.equals(elementNamespace.URI)))
+            {
+                differentNamespaces = true;
+            }
+
+            // copy each one over.
+            for (Map.Entry<String, String> attr : attributeMap.entrySet())
+            {
+                if (attr.getValue() == null)
+                {
+                    continue;
+                }
+
+                if (differentNamespaces)
+                {
+                    attributes.addAttribute(attributeNamespace.URI, attr.getKey(),
+                            qName(attributeNamespace, attr.getKey()), "CDATA", attr.getValue());
+
+                }
+                else
+                {
+                    attributes.addAttribute("", attr.getKey(), attr.getKey(), "CDATA", attr.getValue());
+                }
+            }
+        }
+        return attributes;
+    }
+    
+    /**
+     * Create the qName for the element with the given localName and namespace
+     * prefix.
+     * 
+     * @param namespace
+     *            (May be null) The namespace prefix.
+     * @param localName
+     *            (Required) The element's local name.
+     * @return
+     */
+    private String qName(Namespace namespace, String localName)
+    {
+    	String prefix = namespaces.getPrefix(namespace.URI);
+        if (prefix == null || prefix.equals(""))
+        {
+            return localName;
+        }
+        else
+        {
+            return prefix + ":" + localName;
+        }
+    }
+    
+}
diff --git a/dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/objectmanager/ItemAdapter.java b/dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/objectmanager/ItemAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..64cac32dc5584de67d00795f9ce5d144e961a936
--- /dev/null
+++ b/dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/objectmanager/ItemAdapter.java
@@ -0,0 +1,1241 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.xmlui.objectmanager;
+
+import org.dspace.app.util.Util;
+import org.dspace.app.util.factory.UtilServiceFactory;
+import org.dspace.app.util.service.MetadataExposureService;
+import org.dspace.app.xmlui.wing.AttributeMap;
+import org.dspace.app.xmlui.wing.WingException;
+import org.dspace.authority.AuthorityUtil;
+import org.dspace.authority.AuthorityValue;
+import org.dspace.authority.factory.AuthorityServiceFactory;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.authorize.factory.AuthorizeServiceFactory;
+import org.dspace.authorize.service.AuthorizeService;
+import org.dspace.content.*;
+import org.dspace.content.authority.Choices;
+import org.dspace.content.crosswalk.CrosswalkException;
+import org.dspace.content.crosswalk.DisseminationCrosswalk;
+import org.dspace.content.factory.ContentServiceFactory;
+import org.dspace.content.service.BitstreamService;
+import org.dspace.content.service.BundleService;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Constants;
+import org.dspace.core.Context;
+import org.dspace.services.factory.DSpaceServicesFactory;
+import org.dspace.utils.DSpace;
+import org.jdom.Element;
+import org.jdom.JDOMException;
+import org.jdom.output.SAXOutputter;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+import org.xml.sax.XMLReader;
+import org.xml.sax.helpers.XMLReaderFactory;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static org.apache.commons.lang.StringUtils.isNotBlank;
+
+
+/**
+ * This is an adapter which translates a DSpace item into a METS document
+ * following the DSpace METS profile, err well mostly. At least if you use
+ * the proper configuration it will be fully compliant with the profile,
+ * however this adapter will allow you to configure it to be incorrect.
+ *
+ * <p>When we are configured to be non-compliant with the profile, the MET's
+ * profile is changed to reflect the deviation. The DSpace profile states
+ * that metadata should be given in MODS format. However, you can configure
+ * this adapter to use any metadata crosswalk. When that case is detected we
+ * change the profile to say that we are deviating from the standard profile
+ * and it lists what metadata has been added.
+ *
+ * <p>There are four parts to an item's METS document: descriptive metadata,
+ * file section, structural map, and extra sections.
+ *
+ * <p>Request item-support
+ * <p>Original Concept, JSPUI version:    Universidade do Minho   at www.uminho.pt
+ * <p>Sponsorship of XMLUI version:    Instituto Oceanográfico de España at www.ieo.es
+ *
+ * @author Scott Phillips
+ * @author Adán Román Ruiz at arvo.es (for request item support)
+ */
+
+public class ItemAdapter extends AbstractAdapter
+{
+    /** The item this METS adapter represents */
+    private final Item item;
+
+    /** List of bitstreams which should be publicly viewable */
+    private final List<Bitstream> contentBitstreams = new ArrayList<>();
+
+    /** The primary bitstream, or null if none specified */
+    private Bitstream primaryBitstream;
+
+    /** A space-separated list of descriptive metadata sections */
+    private StringBuffer dmdSecIDS;
+
+    /** A space-separated list of administrative metadata sections (for item)*/
+    private StringBuffer amdSecIDS;
+
+    /** A hashmap of all Files and their corresponding space separated list of
+        administrative metadata sections */
+    private final Map<String,StringBuffer> fileAmdSecIDs = new HashMap<>();
+
+    // DSpace DB context
+    private final Context context;
+
+    protected AuthorizeService authorizeService = AuthorizeServiceFactory.getInstance().getAuthorizeService();
+    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();
+    protected BundleService bundleService = ContentServiceFactory.getInstance().getBundleService();
+    protected BitstreamService bitstreamService = ContentServiceFactory.getInstance().getBitstreamService();
+    protected MetadataExposureService metadataExposureService = UtilServiceFactory.getInstance().getMetadataExposureService();
+
+
+    /**
+     * Construct a new ItemAdapter
+     *
+     * @param context
+     *            Session context.
+     * @param item
+     *            The DSpace item to adapt.
+     * @param contextPath
+     *            The context path for this web application.
+     */
+    public ItemAdapter(Context context, Item item, String contextPath)
+    {
+        super(contextPath);
+        this.item = item;
+        this.context = context;
+    }
+
+    /** @return the item. */
+    public Item getItem()
+    {
+        return this.item;
+    }
+
+
+
+    /**
+     *
+     *
+     *
+     * Required abstract methods
+     *
+     *
+     *
+     */
+
+    /**
+     * @return the URL of this item in the interface.
+     */
+    @Override
+    protected String getMETSOBJID()
+    {
+        if (item.getHandle() != null)
+        {
+            return contextPath + "/handle/" + item.getHandle();
+        }
+        return null;
+    }
+
+    /**
+     * @return the URL for editing this item
+     */
+    @Override
+    protected String getMETSOBJEDIT()
+    {
+        return contextPath+"/admin/item?itemID=" + item.getID();
+    }
+
+    /**
+     * @return the item's handle as the METS ID
+     */
+    @Override
+    protected String getMETSID()
+    {
+        if (item.getHandle() == null)
+        {
+            return "item:" + item.getID();
+        }
+        else
+        {
+            return "hdl:" + item.getHandle();
+        }
+    }
+
+    /**
+     * @return the official METS SIP Profile.
+     * @throws WingException never.
+     */
+    @Override
+    protected String getMETSProfile() throws WingException
+    {
+        return "DSPACE METS SIP Profile 1.0";
+    }
+
+    /**
+     * @return a helpful label that this is a DSpace Item.
+     */
+    @Override
+    protected String getMETSLabel()
+    {
+        return "DSpace Item";
+    }
+
+    /**
+     * @param bitstream a Bitstream.
+     * @return a unique id for a bitstream.
+     */
+    protected String getFileID(Bitstream bitstream)
+    {
+        return "file_" + bitstream.getID();
+    }
+
+    /**
+     * @param bitstream a Bitstream.
+     * @return a group id for a bitstream.
+     */
+    protected String getGroupFileID(Bitstream bitstream)
+    {
+        return "group_file_" + bitstream.getID();
+    }
+
+    /**
+     * @param admSecName section.
+     * @param mdType type.
+     * @param dso object.
+     * @return a techMD id for a bitstream.
+     */
+    protected String getAmdSecID(String admSecName, String mdType, DSpaceObject dso)
+    {
+        if (dso.getType() == Constants.BITSTREAM)
+        {
+            return admSecName + "_" + getFileID((Bitstream) dso) + "_" + mdType;
+        }
+        else
+        {
+            return admSecName + "_" + dso.getID() + "_" + mdType;
+        }
+    }
+
+    /**
+     * Render the METS descriptive section. This will create a new metadata
+     * section for each crosswalk configured. Furthermore, a special check
+     * has been added that will add MODS descriptive metadata if it is
+     * available in DSpace.
+     *
+     * <p>Example:
+     *
+     * <pre>{@code
+     * <dmdSec>
+     *  <mdWrap MDTYPE="MODS">
+     *    <xmlData>
+     *      ... content from the crosswalk ...
+     *    </xmlDate>
+     *  </mdWrap>
+     * </dmdSec
+     * }</pre>
+     * @throws WingException on XML errors.
+     * @throws SAXException passed through.
+     * @throws CrosswalkException passed through.
+     * @throws IOException passed through.
+     * @throws SQLException passed through.
+     */
+    @Override
+    protected void renderDescriptiveSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException
+    {
+        AttributeMap attributes;
+        String groupID = getGenericID("group_dmd_");
+        dmdSecIDS = new StringBuffer();
+
+        // Add DIM descriptive metadata if it was requested or if no metadata types
+        // were specified. Furthermore, since this is the default type we also use a
+        // faster rendering method that the crosswalk API.
+        if(dmdTypes.isEmpty() || dmdTypes.contains("DIM"))
+        {
+                // Metadata element's ID
+                String dmdID = getGenericID("dmd_");
+                // Keep track of all descriptive sections
+                dmdSecIDS.append(dmdID);
+
+                        ////////////////////////////////
+                        // Start a metadata wrapper
+                        attributes = new AttributeMap();
+                        attributes.put("ID", dmdID);
+                        attributes.put("GROUPID", groupID);
+                        startElement(METS, "dmdSec", attributes);
+
+                         ////////////////////////////////
+                        // Start a metadata wrapper
+                        attributes = new AttributeMap();
+                        attributes.put("MDTYPE","OTHER");
+                        attributes.put("OTHERMDTYPE", "DIM");
+                        startElement(METS,"mdWrap",attributes);
+
+                        // ////////////////////////////////
+                        // Start the xml data
+                        startElement(METS,"xmlData");
+
+
+                        // ///////////////////////////////
+                        // Start the DIM element
+                        attributes = new AttributeMap();
+                        attributes.put("dspaceType", Constants.typeText[item.getType()]);
+            if (item.isWithdrawn())
+            {
+                attributes.put("withdrawn", "y");
+            }
+            startElement(DIM,"dim",attributes);
+
+            String orcidURL = new DSpace().getConfigurationService().getProperty("orcid.connector.url", "https://orcid.org/");
+            if (isNotBlank(orcidURL)) {
+                orcidURL=orcidURL+(orcidURL.endsWith("/")?"":"/");
+            }
+            List<MetadataValue> metadataValues = itemService.getMetadata(item, Item.ANY, Item.ANY, Item.ANY, Item.ANY);
+                for (MetadataValue metadataValue : metadataValues)
+                {
+                    MetadataField metadataField = metadataValue.getMetadataField();
+                    if (!metadataExposureService.isHidden(context, metadataValue.getMetadataField().getMetadataSchema().getName(), metadataField.getElement(), metadataField.getQualifier())) {
+                        // ///////////////////////////////
+                        // Field element for each metadata field.
+                        attributes = new AttributeMap();
+                        attributes.put("mdschema", metadataField.getMetadataSchema().getName());
+                        attributes.put("element", metadataField.getElement());
+                        if (metadataField.getQualifier() != null) {
+                            attributes.put("qualifier", metadataField.getQualifier());
+                        }
+                        if (metadataValue.getLanguage() != null) {
+                            attributes.put("language", metadataValue.getLanguage());
+                        }
+                        if (metadataValue.getAuthority() != null || metadataValue.getConfidence() != Choices.CF_UNSET) {
+                            attributes.put("authority", metadataValue.getAuthority());
+                            addORCIDIdIfPresent(attributes, orcidURL, metadataValue);
+                            attributes.put("confidence", Choices.getConfidenceText(metadataValue.getConfidence()));
+                        }
+                        startElement(DIM, "field", attributes);
+                        sendCharacters(metadataValue.getValue());
+                        endElement(DIM,"field");
+                }
+                }
+
+                // ///////////////////////////////
+                        // End the DIM element
+                        endElement(DIM,"dim");
+
+                // ////////////////////////////////
+                // End elements
+                endElement(METS,"xmlData");
+                endElement(METS,"mdWrap");
+                endElement(METS,"dmdSec");
+
+        }
+
+
+        // Add any extra crosswalks that may configured.
+        for (String dmdType : dmdTypes)
+        {
+                // If DIM was requested then it was generated above without using
+                // the crosswalk API. So we can skip this one.
+                if ("DIM".equals(dmdType))
+                {
+                    continue;
+                }
+
+                DisseminationCrosswalk crosswalk = getDisseminationCrosswalk(dmdType);
+
+                if (crosswalk == null)
+                {
+                    continue;
+                }
+
+                String dmdID = getGenericID("dmd_");
+                // Add our id to the list.
+                dmdSecIDS.append(" ").append(dmdID);
+
+                ////////////////////////////////
+                // Start a metadata wrapper
+                attributes = new AttributeMap();
+                attributes.put("ID", dmdID);
+                attributes.put("GROUPID", groupID);
+                startElement(METS, "dmdSec", attributes);
+
+                ////////////////////////////////
+                // Start a metadata wrapper
+                attributes = new AttributeMap();
+                if (isDefinedMETStype(dmdType))
+                {
+                        attributes.put("MDTYPE", dmdType);
+                }
+                else
+                {
+                        attributes.put("MDTYPE","OTHER");
+                        attributes.put("OTHERMDTYPE", dmdType);
+                }
+                startElement(METS,"mdWrap",attributes);
+
+                // ////////////////////////////////
+                // Start the xml data
+                startElement(METS,"xmlData");
+
+
+                // ///////////////////////////////
+                // Send the actual XML content
+                try {
+                        Element dissemination = crosswalk.disseminateElement(context, item);
+
+                        SAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);
+                        // Allow the basics for XML
+                        filter.allowElements().allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();
+
+                    SAXOutputter outputter = new SAXOutputter();
+                    outputter.setContentHandler(filter);
+                    outputter.setLexicalHandler(filter);
+                                outputter.output(dissemination);
+                        }
+            catch (JDOMException jdome)
+                        {
+                                throw new WingException(jdome);
+                        }
+                        catch (AuthorizeException ae)
+                        {
+                                // just ignore the authorize exception and continue on
+                                // without parsing the xml document.
+                        }
+
+
+            // ////////////////////////////////
+            // End elements
+            endElement(METS,"xmlData");
+            endElement(METS,"mdWrap");
+            endElement(METS,"dmdSec");
+        }
+
+
+        // Check to see if there is an in-line MODS document
+        // stored as a bitstream. If there is then we should also
+        // include these metadata in our METS document. However,
+        // we don't really know what the document describes, so we
+        // but it in its own dmd group.
+
+        Boolean include = DSpaceServicesFactory.getInstance().getConfigurationService().getBooleanProperty("xmlui.bitstream.mods");
+        if (include && dmdTypes.contains("MODS"))
+        {
+                // Generate a second group id for any extra metadata added.
+                String groupID2 = getGenericID("group_dmd_");
+
+                List<Bundle> bundles = itemService.getBundles(item, "METADATA");
+                for (Bundle bundle : bundles)
+                {
+                        Bitstream bitstream = bundleService.getBitstreamByName(bundle, "MODS.xml");
+
+                        if (bitstream == null)
+                        {
+                            continue;
+                        }
+
+
+                        String dmdID = getGenericID("dmd_");
+
+
+                        ////////////////////////////////
+                        // Start a metadata wrapper
+                        attributes = new AttributeMap();
+                        attributes.put("ID", dmdID);
+                        attributes.put("GROUPID", groupID2);
+                        startElement(METS, "dmdSec", attributes);
+
+                         ////////////////////////////////
+                        // Start a metadata wrapper
+                        attributes = new AttributeMap();
+                        attributes.put("MDTYPE", "MODS");
+                        startElement(METS,"mdWrap",attributes);
+
+                        // ////////////////////////////////
+                        // Start the xml data
+                        startElement(METS,"xmlData");
+
+
+                        // ///////////////////////////////
+                        // Send the actual XML content
+
+                        SAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);
+                        // Allow the basics for XML
+                        filter.allowElements().allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();
+
+                        XMLReader reader = XMLReaderFactory.createXMLReader();
+                        reader.setContentHandler(filter);
+                        reader.setProperty("http://xml.org/sax/properties/lexical-handler", filter);
+                        try {
+                                InputStream is = bitstreamService.retrieve(context, bitstream);
+                                reader.parse(new InputSource(is));
+                        }
+                        catch (AuthorizeException ae)
+                        {
+                                // just ignore the authorize exception and continue on
+                                // without parsing the xml document.
+                        }
+
+                        // ////////////////////////////////
+                    // End elements
+                    endElement(METS,"xmlData");
+                    endElement(METS,"mdWrap");
+                    endElement(METS, "dmdSec");
+                }
+        }
+
+    }
+
+    private void addORCIDIdIfPresent(AttributeMap attributes, String orcidURL, MetadataValue metadataValue) {
+
+        if (new AuthorityUtil().isPersonAuthority(metadataValue.getMetadataField())) {
+
+            AuthorityValue authorityValue = AuthorityServiceFactory.getInstance().getAuthorityValueService().findByUID(context, metadataValue.getAuthority());
+            if (authorityValue != null) {
+                String orcidId = (String) authorityValue.getSolrInputDocument().getFieldValue("orcid_id");
+                if (isNotBlank(orcidId)) {
+                    attributes.put("orcidID", orcidURL + orcidId);
+                }
+            }
+        }
+    }
+
+    /**
+     * Render the METS administrative section.
+     *
+     * <p>Example:
+     *
+     * <pre>{@code
+     * <amdSec>
+     *  <mdWrap MDTYPE="OTHER" OTHERMDTYPE="METSRights">
+     *    <xmlData>
+     *      ... content from the crosswalk ...
+     *    </xmlDate>
+     *  </mdWrap>
+     * </amdSec>
+     * }</pre>
+     *
+     * @throws WingException passed through.
+     * @throws SAXException passed through.
+     * @throws CrosswalkException passed through.
+     * @throws IOException passed through.
+     * @throws SQLException passed through.
+     */
+    @Override
+    protected void renderAdministrativeSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException
+    {
+        AttributeMap attributes;
+        String groupID;
+
+        // Only create an <amdSec>, if we have amdTypes (or sub-sections) specified...
+        // (this keeps our METS file small, by default, and hides all our admin metadata)
+        if(amdTypes.size() > 0)
+        {
+          ////////////////////////////////
+          // Start an administrative wrapper
+
+          // Administrative element's ID
+          String amdID = getGenericID("amd_");
+          attributes = new AttributeMap();
+          attributes.put("ID", amdID);
+          startElement(METS, "amdSec", attributes);
+
+          groupID = getGenericID("group_amd_");
+          attributes.put("GROUPID", groupID);
+        }
+
+        // For each administrative metadata section specified
+        for (String amdSecName : amdTypes.keySet())
+        {
+          // get a list of metadata crosswalks which will be used to build
+          // this administrative metadata section
+          List<String> mdTypes = amdTypes.get(amdSecName);
+
+          // For each crosswalk
+          for (String mdType : mdTypes)
+          {
+            // get our dissemination crosswalk
+            DisseminationCrosswalk crosswalk = getDisseminationCrosswalk(mdType);
+
+            // skip, if we cannot find this crosswalk in config file
+            if (crosswalk == null)
+            {
+                continue;
+            }
+
+            // First, check if this crosswalk can handle disseminating Item-level Administrative metadata
+            if(crosswalk.canDisseminate(item))
+            {
+              // Since this crosswalk works with items, first render a section for entire item
+              renderAmdSubSection(amdSecName, mdType, crosswalk, item);
+            }
+
+            // Next, we'll try and render Bitstream-level administrative metadata
+            // (Although, we're only rendering this metadata for the bundles specified)
+            List<Bundle> bundles = findEnabledBundles();
+            for (Bundle bundle : bundles)
+            {
+              List<Bitstream> bitstreams = bundle.getBitstreams();
+
+              // Create a sub-section of <amdSec> for each bitstream in bundle
+              for(Bitstream bitstream : bitstreams)
+              {
+                 // Only render the section if crosswalk works with bitstreams
+                 if(crosswalk.canDisseminate(bitstream))
+                 {
+                    renderAmdSubSection(amdSecName, mdType, crosswalk, bitstream);
+                 }
+              } // end for each bitstream
+            } // end for each bundle
+          } // end for each crosswalk
+        } // end for each amdSec
+
+        if(amdTypes.size() > 0)
+        {
+          //////////////////////////////////
+          // End administrative section
+          endElement(METS,"amdSec");
+        }
+    }
+
+    /**
+     * Render a sub-section of the administrative metadata section.
+     * Valid sub-sections include: techMD, rightsMD, sourceMD, digiprovMD
+     *
+     * <p>Example:
+     *
+     * <pre>{@code
+     * <techMD>
+     *   <mdWrap MDTYPE="PREMIS">
+     *     <xmlData>
+     *       [PREMIS content ... ]
+     *     </xmlData>
+     *   </mdWrap>
+     * </techMD>
+     * }</pre>
+     *
+     * @param amdSecName Name of administrative metadata section
+     * @param mdType Type of metadata section (e.g. PREMIS)
+     * @param crosswalk The DisseminationCrosswalk to use to generate this section
+     * @param dso The current DSpace object to use the crosswalk on
+     * @throws WingException on XML errors.
+     * @throws SAXException passed through.
+     * @throws CrosswalkException passed through.
+     * @throws IOException passed through.
+     * @throws SQLException passed through.
+     */
+    protected void renderAmdSubSection(String amdSecName, String mdType, DisseminationCrosswalk crosswalk, DSpaceObject dso)
+            throws WingException, SAXException, CrosswalkException, IOException, SQLException
+    {
+        /////////////////////////////////
+        // Start administrative metadata section wrapper
+        String amdSecID = getAmdSecID(amdSecName, mdType, dso);
+        AttributeMap attributes = new AttributeMap();
+        attributes.put("ID", amdSecID);
+        startElement(METS, amdSecName, attributes);
+
+        // If this is a bitstream
+        if (dso.getType() == Constants.BITSTREAM)
+        {
+          // Add this to our list of each file's administrative section IDs
+          String fileID = getFileID((Bitstream) dso);
+          if(fileAmdSecIDs.containsKey(fileID))
+          {
+              fileAmdSecIDs.get(fileID).append(" ").append(amdSecID);
+          }
+          else
+          {
+              fileAmdSecIDs.put(fileID, new StringBuffer(amdSecID));
+          }
+        } // else if an Item
+        else if (dso.getType() == Constants.ITEM)
+        {
+           // Add this to our list of item's administrative section IDs
+           if(amdSecIDS==null)
+           {
+               amdSecIDS = new StringBuffer(amdSecID);
+           }
+           else
+           {
+               amdSecIDS.append(" ").append(amdSecID);
+           }
+        }
+
+        ////////////////////////////////
+        // Start a metadata wrapper
+        attributes = new AttributeMap();
+        if (isDefinedMETStype(mdType))
+        {
+            attributes.put("MDTYPE", mdType);
+        }
+        else
+        {
+            attributes.put("MDTYPE","OTHER");
+            attributes.put("OTHERMDTYPE", mdType);
+        }
+        startElement(METS,"mdWrap",attributes);
+
+        //////////////////////////////////
+        // Start the xml data
+        startElement(METS,"xmlData");
+
+        /////////////////////////////////
+        // Send the actual XML content,
+        // using the PREMIS crosswalk for each bitstream
+        try {
+            Element dissemination = crosswalk.disseminateElement(context, dso);
+
+            SAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);
+            // Allow the basics for XML
+            filter.allowElements().allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();
+
+            SAXOutputter outputter = new SAXOutputter();
+            outputter.setContentHandler(filter);
+            outputter.setLexicalHandler(filter);
+            outputter.output(dissemination);
+        }
+        catch (JDOMException jdome)
+        {
+            throw new WingException(jdome);
+        }
+        catch (AuthorizeException ae)
+        {
+            // just ignore the authorize exception and continue on
+            // without parsing the xml document.
+        }
+
+        // ////////////////////////////////
+        // End elements
+        endElement(METS,"xmlData");
+        endElement(METS,"mdWrap");
+        endElement(METS,amdSecName);
+    }
+
+    /**
+     * Render the METS file section. This will contain a list of all bitstreams in the
+     * item. Each bundle, even those that are not typically displayed will be listed.
+     *
+     * <p>Example:
+     *
+     * <pre>{@code
+     * <fileSec>
+     *   <fileGrp USE="CONTENT">
+     *     <file ... >
+     *       <fLocate ... >
+     *     </file>
+     *   </fileGrp>
+     *   <fileGrp USE="TEXT">
+     *     <file ... >
+     *       <fLocate ... >
+     *     </file>
+     *   </fileGrp>
+     * </fileSec>
+     * }</pre>
+     *
+     * @param context session context.
+     * @throws SQLException passed through.
+     * @throws SAXException passed through.
+     */
+    @Override
+    protected void renderFileSection(Context context) throws SQLException, SAXException
+    {
+        AttributeMap attributes;
+
+        // //////////////////////
+        // Start a new file section
+        startElement(METS,"fileSec");
+
+        // Check if the user is requested a specific bundle or
+        // the all bundles.
+        List<Bundle> bundles = findEnabledBundles();
+
+        // Suppress license?
+        Boolean showLicense = DSpaceServicesFactory.getInstance().getConfigurationService().getBooleanProperty("webui.licence_bundle.show");
+
+        // Check if ORIGINAL bundle included (either explicitly or via include all fileGrp types)
+        boolean includeContentBundle = this.fileGrpTypes.isEmpty() ? true : this.fileGrpTypes.contains("ORIGINAL");
+
+        // Loop over all requested bundles
+        for (Bundle bundle : bundles)
+        {
+
+            // Use the bitstream's name as the use parameter unless we
+            // are the original bundle. In this case rename it to
+            // content.
+            String use = bundle.getName();
+            boolean isContentBundle = false; // remember the content bundle.
+            boolean isDerivedBundle = false;
+            if ("ORIGINAL".equals(use))
+            {
+                use = "CONTENT";
+                isContentBundle = true;
+            }
+            if ("TEXT".equals(bundle.getName()) || "THUMBNAIL".equals(bundle.getName()))
+            {
+                isDerivedBundle = true;
+            }
+            if ("LICENSE".equals(bundle.getName()) && ! showLicense)
+            {
+                continue;
+            }
+
+            // /////////////////////////////////////
+            // Determine which bitstreams to include in bundle
+            List<Bitstream> bitstreams = new ArrayList<Bitstream>();
+
+            // If this is the THUMBNAIL bundle, and we are NOT including content bundle,
+            // Then assume this is an item summary page, and we can just include the main thumbnail.
+            if ("THUMBNAIL".equals(bundle.getName()) && !includeContentBundle)
+            {
+                Thumbnail thumbnail = itemService.getThumbnail(context, item, false);
+                if(thumbnail != null) {
+                    bitstreams.add(thumbnail.getThumb());
+                }
+            }
+            else
+            {   // Default to including all bitstreams
+                bitstreams = bundle.getBitstreams();
+            }
+
+
+            // ///////////////////
+            // Start bundle's file group
+            attributes = new AttributeMap();
+            attributes.put("USE", use);
+            startElement(METS,"fileGrp",attributes);
+
+            for (Bitstream bitstream : bitstreams)
+            {
+                // //////////////////////////////
+                // Determine the file's IDs
+                String fileID = getFileID(bitstream);
+
+                Bitstream originalBitstream = null;
+                // If we are looping through a derived bundle and content bundle is included,
+                // ensure each derived bitstream and original bitstream share the same groupID
+                if (isDerivedBundle && includeContentBundle)
+                {
+                    originalBitstream = findOriginalBitstream(item, bitstream);
+                }
+                String groupID = getGroupFileID((originalBitstream == null) ? bitstream : originalBitstream );
+
+                // Check if there were administrative metadata sections corresponding to this file
+                String admIDs = null;
+                if(fileAmdSecIDs.containsKey(fileID))
+                {
+                    admIDs = fileAmdSecIDs.get(fileID).toString();
+                }
+
+                // Render the actual file & flocate elements.
+                renderFileWithAllowed(item, bitstream, fileID, groupID, admIDs);
+
+                // Remember all the viewable content bitstreams for later in the
+                // structMap.
+                if (isContentBundle)
+                {
+                    contentBitstreams.add(bitstream);
+                    if (bundle.getPrimaryBitstream() != null && bundle.getPrimaryBitstream().equals(bitstream))
+                    {
+                        primaryBitstream = bitstream;
+                    }
+                }
+            }
+
+            // ///////////////////
+            // End the bundle's file group
+            endElement(METS,"fileGrp");
+        }
+
+        // //////////////////////
+        // End the file section
+        endElement(METS,"fileSec");
+    }
+
+
+    /**
+     * Render the item's structural map. This includes a list of
+     * content bitstreams, those are bitstreams that are typically
+     * viewable by the end user.
+     *
+     * <p>Example:
+     *
+     * <pre>{@code
+     * <structMap TYPE="LOGICAL" LABEL="DSpace">
+     *   <div TYPE="DSpace Item" DMDID="space-separated list of ids">
+     *     <fptr FILEID="primary bitstream"/>
+     *     ... a div for each content bitstream.
+     *   </div>
+     * </structMap>
+     * }</pre>
+     * @throws SQLException passed through.
+     * @throws SAXException passed through.
+     */
+    @Override
+    protected void renderStructureMap() throws SQLException, SAXException
+    {
+        AttributeMap attributes;
+
+        // ///////////////////////
+        // Start a new structure map
+        attributes = new AttributeMap();
+        attributes.put("TYPE", "LOGICAL");
+        attributes.put("LABEL", "DSpace");
+        startElement(METS,"structMap",attributes);
+
+        // ////////////////////////////////
+        // Start the special first division
+        attributes = new AttributeMap();
+        attributes.put("TYPE", "DSpace Item");
+        // add references to the Descriptive metadata
+        if (dmdSecIDS != null)
+        {
+            attributes.put("DMDID", dmdSecIDS.toString());
+        }
+        // add references to the Administrative metadata
+        if (amdSecIDS != null)
+        {
+            attributes.put("AMDID", amdSecIDS.toString());
+        }
+        startElement(METS,"div",attributes);
+
+        // add a fptr pointer to the primary bitstream.
+        if (primaryBitstream != null)
+        {
+                // ////////////////////////////////
+                // Start & end a reference to the primary bitstream.
+                attributes = new AttributeMap();
+                String fileID = getFileID(primaryBitstream);
+                attributes.put("FILEID", fileID);
+
+                startElement(METS,"fptr",attributes);
+                endElement(METS,"fptr");
+        }
+
+        for (Bitstream bitstream : contentBitstreams)
+        {
+                // ////////////////////////////////////
+                // Start a div for each publicly viewable bitstream
+                attributes = new AttributeMap();
+                attributes.put("ID", getGenericID("div_"));
+                attributes.put("TYPE", "DSpace Content Bitstream");
+                startElement(METS,"div",attributes);
+
+                // ////////////////////////////////
+                // Start a the actualy pointer to the bitstream FIXME: what?
+                attributes = new AttributeMap();
+                String fileID = getFileID(bitstream);
+                attributes.put("FILEID", fileID);
+
+                startElement(METS,"fptr",attributes);
+                endElement(METS,"fptr");
+
+                // ///////////////////////////////
+                // End the div
+                endElement(METS,"div");
+        }
+
+        // ////////////////////////////////
+        // End the special first division
+        endElement(METS,"div");
+
+        // ///////////////////////
+        // End the structure map
+        endElement(METS,"structMap");
+    }
+
+
+
+    /**
+     * Render any extra METS section. If the item contains a METS.xml document
+     * then all of that document's sections are included in this document's
+     * METS document.
+     * @throws SAXException passed through.
+     * @throws SQLException passed through.
+     * @throws IOException passed through.
+     */
+    @Override
+    protected void renderExtraSections() throws SAXException, SQLException, IOException
+    {
+        Boolean include = DSpaceServicesFactory.getInstance().getConfigurationService().getBooleanProperty("xmlui.bitstream.mets");
+        if (!include)
+        {
+            return;
+        }
+
+
+        List<Bundle> bundles = itemService.getBundles(item, "METADATA");
+
+        for (Bundle bundle : bundles)
+        {
+                Bitstream bitstream = bundleService.getBitstreamByName(bundle, "METS.xml");
+
+                if (bitstream == null)
+                {
+                    continue;
+                }
+
+                // ///////////////////////////////
+                // Send the actual XML content
+                try {
+                        SAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);
+                        // Allow the basics for XML
+                        filter.allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();
+                        // Special option, only allow elements below the second level to pass through. This
+                        // will trim out the METS declaration and only leave the actual METS parts to be
+                        // included.
+                        filter.allowElements(1);
+
+
+                        XMLReader reader = XMLReaderFactory.createXMLReader();
+                        reader.setContentHandler(filter);
+                        reader.setProperty("http://xml.org/sax/properties/lexical-handler", filter);
+                        reader.parse(new InputSource(bitstreamService.retrieve(context, bitstream)));
+                }
+                        catch (AuthorizeException ae)
+                        {
+                                // just ignore the authorize exception and continue on
+                                // without parsing the xml document.
+                        }
+        }
+    }
+
+
+    /**
+     * Checks which Bundles of current item a user has requested.
+     * If none specifically requested, then all Bundles are returned.
+     *
+     * @return List of enabled bundles
+     * @throws SQLException passed through.
+     */
+    protected List<Bundle> findEnabledBundles() throws SQLException
+    {
+        // Check if the user is requested a specific bundle or
+        // the all bundles.
+        List<Bundle> bundles;
+        if (fileGrpTypes.isEmpty())
+        {
+            bundles = item.getBundles();
+        }
+        else
+        {
+                bundles = new ArrayList<>();
+                for (String fileGrpType : fileGrpTypes)
+                {
+                        for (Bundle newBundle : itemService.getBundles(item, fileGrpType))
+                        {
+                                bundles.add(newBundle);
+                        }
+                }
+        }
+
+        return bundles;
+    }
+
+
+    /**
+     * For a bitstream that's a thumbnail or extracted text, find the
+     * corresponding bitstream it was derived from, in the ORIGINAL bundle.
+     *
+     * @param item
+     *            the item we're dealing with
+     * @param derived
+     *            the derived bitstream
+     *
+     * @return the corresponding original bitstream (or null)
+     * @throws SQLException passed through.
+     */
+    protected static Bitstream findOriginalBitstream(Item item,Bitstream derived) throws SQLException
+    {
+        // FIXME: this method is a copy of the one found below. However, the
+        // original method is protected so we can't use it here. I think that
+        // perhaps this should be folded into the DSpace bitstream API. Until
+        // when a good final solution can be determined I am just going to copy
+        // the method here.
+        //
+        // return org.dspace.content.packager.AbstractMetsDissemination
+        // .findOriginalBitstream(item, derived);
+
+        List<Bundle> bundles = item.getBundles();
+
+        // Filename of original will be filename of the derived bitstream
+        // minus the extension (ie everything from and including the last "." character)
+       int endIndex = derived.getName().lastIndexOf(".");
+       String originalFilename = derived.getName().substring(0, endIndex>0?endIndex:(derived.getName().length()-1));
+
+        // First find "original" bundle
+        for (Bundle bundle : bundles)
+        {
+            if ((bundle.getName() != null)
+                    && bundle.getName().equals("ORIGINAL"))
+            {
+                // Now find the corresponding bitstream
+                List<Bitstream> bitstreams = bundle.getBitstreams();
+
+                for (Bitstream bitstream : bitstreams)
+                {
+                    if (bitstream.getName().equals(originalFilename))
+                    {
+                        return bitstream;
+                    }
+                }
+            }
+        }
+
+        // Didn't find it
+        return null;
+    }
+
+    /**
+     * Generate a METS file element for a given bitstream.
+     *
+     * @param item
+     *            If the bitstream is associated with an item provide the item
+     *            otherwise leave null.
+     * @param bitstream
+     *            The bitstream to build a file element for.
+     * @param fileID
+     *            The unique file id for this file.
+     * @param groupID
+     *            The group id for this file, if it is derived from another file
+     *            then they should share the same groupID.
+     * @param admID
+     *            The IDs of the administrative metadata sections which pertain
+     *            to this file
+     * @throws SAXException passed through.
+     * @throws SQLException passed through.
+     */
+
+    // FIXME: this method is a copy of the one inherited. However the
+    // original method is final so we must rename it.
+	protected void renderFileWithAllowed(Item item, Bitstream bitstream, String fileID, String groupID, String admID) throws SAXException, SQLException
+    {
+		AttributeMap attributes;
+
+		// //////////////////////////////
+    	// Determine the file attributes
+        BitstreamFormat format = bitstream.getFormat(context);
+        String mimeType = null;
+        if (format != null)
+        {
+            mimeType = format.getMIMEType();
+        }
+        String checksumType = bitstream.getChecksumAlgorithm();
+        String checksum = bitstream.getChecksum();
+        long size = bitstream.getSize();
+
+        // ////////////////////////////////
+        // Start the actual file
+        attributes = new AttributeMap();
+        attributes.put("ID", fileID);
+        attributes.put("GROUPID",groupID);
+        if (admID != null && admID.length()>0)
+        {
+            attributes.put("ADMID", admID);
+        }
+        if (mimeType != null && mimeType.length()>0)
+        {
+            attributes.put("MIMETYPE", mimeType);
+        }
+        if (checksumType != null && checksum != null)
+        {
+        	attributes.put("CHECKSUM", checksum);
+        	attributes.put("CHECKSUMTYPE", checksumType);
+        }
+        attributes.put("SIZE", String.valueOf(size));
+        startElement(METS,"file",attributes);
+
+
+        // ////////////////////////////////////
+        // Determine the file location attributes
+        String name = bitstream.getName();
+        String description = bitstream.getDescription();
+
+
+        // If possible reference this bitstream via a handle, however this may
+        // be null if a handle has not yet been assigned. In this case reference the
+        // item its internal id. In the last case where the bitstream is not associated
+        // with an item (such as a community logo) then reference the bitstreamID directly.
+        String identifier = null;
+        if (item != null && item.getHandle() != null)
+        {
+            identifier = "handle/" + item.getHandle();
+        }
+        else if (item != null)
+        {
+            identifier = "item/" + item.getID();
+        }
+        else
+        {
+            identifier = "id/" + bitstream.getID();
+        }
+
+
+        String url = contextPath + "/bitstream/"+identifier+"/";
+
+        // If we can put the pretty name of the bitstream on the end of the URL
+        try
+        {
+        	if (bitstream.getName() != null)
+            {
+                url += Util.encodeBitstreamName(bitstream.getName(), "UTF-8");
+            }
+        }
+        catch (UnsupportedEncodingException uee)
+        {
+            // just ignore it, we don't have to have a pretty
+            // name on the end of the URL because the sequence id will
+        	// locate it. However it means that links in this file might
+        	// not work....
+        }
+
+        url += "?sequence="+bitstream.getSequenceID();
+
+	// Test if we are allowed to see this item
+	String isAllowed = "n";
+	try {
+	    if (authorizeService.authorizeActionBoolean(context, bitstream, Constants.READ)) {
+		isAllowed = "y";
+	    }
+	} catch (SQLException e) {/* Do nothing */}
+
+	url += "&isAllowed=" + isAllowed;
+
+        // //////////////////////
+        // Start the file location
+        attributes = new AttributeMap();
+        AttributeMap attributesXLINK = new AttributeMap();
+        attributesXLINK.setNamespace(XLINK);
+        attributes.put("LOCTYPE", "URL");
+        attributesXLINK.put("type","locator");
+        attributesXLINK.put("title", name);
+        if (description != null)
+        {
+            attributesXLINK.put("label", description);
+        }
+        attributesXLINK.put("href", url);
+        startElement(METS,"FLocat",attributes,attributesXLINK);
+
+
+        // ///////////////////////
+        // End file location
+        endElement(METS,"FLocate");
+
+        // ////////////////////////////////
+        // End the file
+        endElement(METS,"file");
+	}
+}
diff --git a/dspace/modules/xmlui/src/main/resources/aspects/Discovery/i18n/messages.xml b/dspace/modules/xmlui/src/main/resources/aspects/Discovery/i18n/messages.xml
new file mode 100644
index 0000000000000000000000000000000000000000..a1c07bf5b5e1abbdbdd9f575419220b91f54e7f4
--- /dev/null
+++ b/dspace/modules/xmlui/src/main/resources/aspects/Discovery/i18n/messages.xml
@@ -0,0 +1,173 @@
+<?xml version="1.0"?>
+<!--
+
+    The contents of this file are subject to the license and copyright
+    detailed in the LICENSE and NOTICE files at the root of the source
+    tree and available online at
+
+    http://www.dspace.org/license/
+
+-->
+<catalogue xml:lang="en" xmlns:i18n="http://apache.org/cocoon/i18n/2.1" xmlns="http://apache.org/cocoon/i18n/2.1">
+
+    <!--
+		The format used by all keys is as follows
+
+		xmlui.<Aspect>.<Java Class>.<name>
+
+		There are a few exceptions to this naming format,
+		1) Some general keys are in the xmlui.general namespace
+		   because they are used very frequently.
+		2) Some general keys which are specific to a particular aspect
+		   may be found at xmlui.<Aspect> without specifiying a
+		   particular java class.
+
+		Advanced Search related keys
+		Filter name:               xmlui.ArtifactBrowser.SimpleSearch.filter.author
+		Facet heading:             xmlui.ArtifactBrowser.AdvancedSearch.type_author
+		"Filter by" page heading:  xmlui.Discovery.AbstractSearch.type_author
+
+		To overlay this file, copy it to [dspace-source]/dspace/modules/xmlui/src/main/resources/aspects/Discovery/i18n/messages.xml.
+		-->
+
+
+    <!-- org.dspace.app.xmlui.artifactbrowser.AbstractSearch.java -->
+
+
+
+
+    <!-- org.dspace.app.xmlui.artifactbrowser.AdvancedSearch.java -->
+    <!-- Note: As of DSpace 6.0, org.dspace.app.xmlui.aspect.artifactbrowser.AdvancedSearch has been removed.
+         The following i18n keys will be left as is as they're referenced by the Discovery SidebarFacetsTransformer
+         but in future, they should be refactored to a more relevant key prefix -->
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_dc.contributor.author_filter">Author</message>
+
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_dc.subject_filter">Subject</message>
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_dc.type_filter">Content Type</message>
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_dc.date.issued">Date Issued</message>
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_dateIssued">Date Issued</message>
+
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_has_content_in_original_bundle">Has File(s)</message>
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.value_has_content_in_original_bundle_true">Yes</message>
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.value_has_content_in_original_bundle_false">No</message>
+
+
+    <!-- Site Level Recently Added Content -->
+    <message key="xmlui.ArtifactBrowser.SiteViewer.head_recent_submissions">Recently Added</message>
+
+    <message key="xmlui.ArtifactBrowser.AbstractRecentSubmissionTransformer.recent_submissions_more">View more</message>
+    <message key="xmlui.Discovery.RecentSubmissions.RecentSubmissionTransformer.head">{0}: Recent submissions</message>
+    <message key="xmlui.Discovery.RecentSubmissions.RecentSubmissionTransformer.trail">Recent submissions</message>
+    <message key="xmlui.Discovery.RecentSubmissions.RecentSubmissionTransformer.recent.head">Recently added</message>
+
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_type_filter">Kind</message>
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_publisher_filter">Publisher</message>
+
+
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.sort_by.ispartof">Parent</message>
+
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.group_by">Group Results By</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.group_by.none">None</message>
+
+
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.group_by.publication_grp">Publication</message>
+
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_location.comm">Community</message>
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_location.coll">Collection</message>
+
+
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_dc.relation.ispartofseries_filter">Series</message>
+
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_dc.contributor.author_browse">Browsing by: Author</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_dc.title_browse">Browsing by: Title</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_dc.subject_browse">Browsing by: Subject</message>
+        
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_dc.description.abstract_browse">Browsing by: Abstract</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_series_browse">Browsing by: Series</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_sponsor_browse">Browsing by: Sponsor</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_identifier_browse">Browsing by: Identifier</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_language_browse">Browsing by: Language (ISO)</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_keyword_browse">Browsing by: Keyword</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_taxon_browse">Browsing by: Scientific Name</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_contributor_browse">Browsing by: Contributor</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_creator_browse">Browsing by: Creator</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_subject_browse">Browsing by: Subject</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_description_browse">Browsing by: Description</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_relation_browse">Browsing by: Relation</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_mime_browse">Browsing by: Mime-Type</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_other_browse">Browsing by: Other Contributor</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_advisor_browse">Browsing by: Advisor</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_department_browse">Browsing by: Department</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_dateissued_dt_browse">Browsing by: Issue date</message>
+
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.title">Title</message>
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.dateIssued">Date issued</message>
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.has_content_in_original_bundle">Has File(s)</message>
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.original_bundle_filenames">Filename</message>
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.original_bundle_descriptions">File description</message>
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.orcidid">ORCID iD</message>
+
+
+    <message key="xmlui.dri2xhtml.structural.pagination-info.nototal">Now showing items {0}-{1}</message>
+
+    <message key="xmlui.Discovery.AbstractSearch.type_author">Filter by: Author</message>
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.author">Author</message>
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.author_filter">Author</message>
+    <message key="xmlui.Discovery.AbstractSearch.type_subject">Filter by: Subject</message>
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.subject">Subject</message>
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.subject_filter">Subject</message>
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.dateIssued.year">Date Issued</message>
+
+
+    <message key="xmlui.Discovery.AbstractSearch.startswith">Starts with</message>
+    <message key="xmlui.Discovery.AbstractSearch.startswith.help">Or enter first few letters:</message>
+
+    <message key="xmlui.Discovery.AbstractSearch.sort_by.head">Sort Options:</message>
+    <message key="xmlui.Discovery.AbstractSearch.sort_by.relevance">Relevance</message>
+    <message key="xmlui.Discovery.AbstractSearch.sort_by.dc.title_sort_desc">Title Desc</message>
+    <message key="xmlui.Discovery.AbstractSearch.sort_by.dc.date.issued_dt_desc">Issue Date Desc</message>
+
+    <message key="xmlui.Discovery.AbstractSearch.sort_by.dc.title_sort_asc">Title Asc</message>
+    <message key="xmlui.Discovery.AbstractSearch.sort_by.dc.date.issued_dt_asc">Issue Date Asc</message>
+
+    <message key="xmlui.Discovery.AbstractSearch.rpp">Results Per Page:</message>
+
+
+    <message key="xmlui.Discovery.AbstractSearch.filters.controls.add-filter">Add Filter</message>
+    <message key="xmlui.Discovery.AbstractSearch.filters.controls.apply-filters">Apply</message>
+    <message key="xmlui.Discovery.AbstractSearch.filters.controls.remove-filter">Remove</message>
+    <message key="xmlui.Discovery.AbstractSearch.filters.controls.new-filters.head">New Filters:</message>
+    <message key="xmlui.Discovery.AbstractSearch.filters.controls.current-filters.head">Current Filters:</message>
+    <message key="xmlui.Discovery.AbstractSearch.filters.display">Add filters</message>
+
+    <message key="xmlui.discovery.SearchFacetFilter.no-results">No filter values found</message>
+
+    <message key="xmlui.discovery.AbstractFiltersTransformer.filters.head">Discover</message>
+    <message key="xmlui.discovery.AbstractFiltersTransformer.filters.view-more">... View More</message>
+
+
+    <message key="xmlui.Discovery.SimpleSearch.search_scope">Search</message>
+    <message key="xmlui.discovery.SimpleSearch.search_label">Search</message>
+    <message key="xmlui.Discovery.SimpleSearch.filter_head">Filters</message>
+    <message key="xmlui.Discovery.SimpleSearch.filter_help">Use filters to refine the search results.</message>
+
+    <message key="xmlui.Discovery.SimpleSearch.filter.contains">Contains</message>
+    <message key="xmlui.Discovery.SimpleSearch.filter.equals">Equals</message>
+    <message key="xmlui.Discovery.SimpleSearch.filter.authority">ID</message>
+	<message key="xmlui.Discovery.SimpleSearch.filter.notcontains">Not Contains</message>
+    <message key="xmlui.Discovery.SimpleSearch.filter.notequals">Not Equals</message>
+    <message key="xmlui.Discovery.SimpleSearch.filter.notauthority">Not ID</message>
+    
+    <message key="xmlui.Discovery.RelatedItems.head">Related items</message>
+    <message key="xmlui.Discovery.RelatedItems.help">Showing items related by title, author, creator and subject.</message>
+
+    <message key="xmlui.Discovery.AbstractSearch.head1_community">Showing {0} out of a total of {1} results for community: {2}. <span class="searchTime">({3} seconds)</span></message>
+   	<message key="xmlui.Discovery.AbstractSearch.head1_collection">Showing {0} out of a total of {1} results for collection: {2}. <span class="searchTime">({3} seconds)</span></message>
+   	<message key="xmlui.Discovery.AbstractSearch.head1_none">Showing {0} out of a total of {1} results. <span class="searchTime">({2} seconds)</span></message>
+
+    <message key="xmlui.Discovery.AbstractSearch.head2">Communities or Collections matching your query</message>
+   	<message key="xmlui.Discovery.AbstractSearch.head3">Items matching your query</message>
+
+   	<message key="xmlui.Discovery.SimpleSearch.did_you_mean">Did you mean: </message>
+
+</catalogue>
diff --git a/dspace/modules/xmlui/src/main/webapp/themes/Mirage/Mirage.xsl b/dspace/modules/xmlui/src/main/webapp/themes/Mirage/Mirage.xsl
new file mode 100644
index 0000000000000000000000000000000000000000..4fb4b101216f098332c79042125bb2aea8a26b19
--- /dev/null
+++ b/dspace/modules/xmlui/src/main/webapp/themes/Mirage/Mirage.xsl
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+
+    The contents of this file are subject to the license and copyright
+    detailed in the LICENSE and NOTICE files at the root of the source
+    tree and available online at
+
+    http://www.dspace.org/license/
+
+-->
+<!--
+    TODO: Describe this XSL file
+    Author: Alexey Maslov
+
+-->
+
+<xsl:stylesheet xmlns:i18n="http://apache.org/cocoon/i18n/2.1"
+	xmlns:dri="http://di.tamu.edu/DRI/1.0/"
+	xmlns:mets="http://www.loc.gov/METS/"
+	xmlns:xlink="http://www.w3.org/TR/xlink/"
+	xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"
+	xmlns:dim="http://www.dspace.org/xmlns/dspace/dim"
+	xmlns:xhtml="http://www.w3.org/1999/xhtml"
+	xmlns:mods="http://www.loc.gov/mods/v3"
+	xmlns:dc="http://purl.org/dc/elements/1.1/"
+	xmlns="http://www.w3.org/1999/xhtml"
+	exclude-result-prefixes="i18n dri mets xlink xsl dim xhtml mods dc">
+
+    <xsl:import href="../dri2xhtml-alt/dri2xhtml.xsl"/>
+    <xsl:import href="lib/xsl/core/global-variables.xsl"/>
+    <xsl:import href="lib/xsl/core/page-structure.xsl"/>
+    <xsl:import href="lib/xsl/core/navigation.xsl"/>
+    <xsl:import href="lib/xsl/core/elements.xsl"/>
+    <xsl:import href="lib/xsl/core/forms.xsl"/>
+    <xsl:import href="lib/xsl/core/attribute-handlers.xsl"/>
+    <xsl:import href="lib/xsl/core/utils.xsl"/>
+    <xsl:import href="lib/xsl/aspect/general/choice-authority-control.xsl"/>
+    <xsl:import href="lib/xsl/aspect/administrative/administrative.xsl"/>
+    <xsl:import href="lib/xsl/aspect/artifactbrowser/item-list.xsl"/>
+    <xsl:import href="lib/xsl/aspect/artifactbrowser/item-view.xsl"/>
+    <xsl:import href="lib/xsl/aspect/artifactbrowser/community-list.xsl"/>
+    <xsl:import href="lib/xsl/aspect/artifactbrowser/collection-list.xsl"/>
+    <xsl:import href="lib/xsl/additions.xsl"/>
+    <xsl:output indent="yes"/>
+    
+
+</xsl:stylesheet>
diff --git a/dspace/modules/xmlui/src/main/webapp/themes/Mirage/images/orcid_icon.png b/dspace/modules/xmlui/src/main/webapp/themes/Mirage/images/orcid_icon.png
new file mode 100644
index 0000000000000000000000000000000000000000..ef109145bc74c3f884d712ae2782ccedd29d096d
GIT binary patch
literal 1261
zcmbVMTWs4@7<LKtvaPIxQ4tX0;39;yB|f&}*f9x9V#hRN>8dnhK|*4#ebRWX?aX!;
zw;<GRg8@QQ1ur0ws02u`ham<+NC;MTsVGBz7#d<oyj7hTNU#<O#%&z8N#UW|1D5P_
z{&W8C`|p0Pzwe>W4R>rH2%<CJD;M$F6};`O_<Q&AH5D&mFIV;k?21=c9Ykbwdk}%V
zsScqcQuVR@b0|p=p^8x|d*#9|QM1jc8t6oQvxd<Gk=)_eRBae}U=R%%R*L-T<C7#X
z^c1;=E5JfcLRF)8+(855eI;#tSWD>Sjt4=~7cqf}JQeunh~<iYid^9p@jf`FNU);f
z4X4Oer^<zXAlVKATogt$7>6KEM`<?3^Za(eKpIkzp=c&T^CHWL5Q4@-Vr!0G5sR|Y
zu!W@*S@pb{NKy5AJz8g@wlhT0i9{mcV3-Kjh`3{xr}`1g?P)T|$kiO9<{7pH0!DSv
z9`#Zr_H;D_vsNgq5nFB}Q8;Ckuhu9!3MtbJ;#$#my(0S8jdiu%(pU{qMdaF}j)v<|
z>1l#-?yherP{iJdyBz};MIDiCZPY}TmzPr{zKQCFE^@piGf;pG$H2Hi<M3lrg5_vd
ziOU&*<C`4oVOds^gsc)%6pp9q94+t}A(s_|xWZ>8877+8yybeTrJ<%>1KVw2+3R9O
z$w8`TJ0;s5X?8$=)%I++YS(}?z=49Q8CD<%<ynnZMvid+>55~UU?snzv5tL3;uV_a
zV~}se%_%vVPta1F&cT>0lMSr?e{x1)XQ-e#{?jbYBiw<(cCGcXur@r%!V}}*(O5oI
z{e&P|?#j!VlK<_Xo(`RxfAl`$9UmM>za$c8Hooz~Q7YZ7%je%F-uycBUQ6hyTFbMc
z$<`FH|K+LJ>utu-SaNoH+bduGy!chyW33b0h0Pa2G_mh}B6KB996K_(<?^MgFs#3t
z`>m^Tf?kGy{{F{J-%ZQi)rrqC$N%D<*+wlgKc2jJj##>x@t3Z2ot`@q`MmWkt9F=M
z;nnHx(@V>bY<j}J1lyfs%<Xeq!NU*0EkAs}=ka;^HUFD0rte>Pnw*!jGn1W}wtK^1
zRy%xQB6Mcohg0uXKDuVzx%2XkXHR9HZ0UIZwuQ3rtA4|YU$RPdXL7fE%WUuYnT3(|
zjfc|U@ASdN&HbsV^x?`Tsj8@eWW%SJTYKKR7zQ)MJumM4)bIFUSMUSM=lbO1*}Vt<
E0ecprk^lez

literal 0
HcmV?d00001

diff --git a/dspace/modules/xmlui/src/main/webapp/themes/Mirage/lib/css/style.css b/dspace/modules/xmlui/src/main/webapp/themes/Mirage/lib/css/style.css
new file mode 100644
index 0000000000000000000000000000000000000000..af203a1e256ad8aa1fcec1f4fb4769f2fbcd504a
--- /dev/null
+++ b/dspace/modules/xmlui/src/main/webapp/themes/Mirage/lib/css/style.css
@@ -0,0 +1,1531 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+/*
+ * style.css
+ *
+ * Primary Styles
+ */
+
+/*Font size percentages based on the tables at developer.yahoo.com/yui/fonts/ */
+h1 {
+    font-size: 182%;
+    color: #1F3F5E;
+    text-align: justify;
+}
+
+h2{
+    font-size: 123.1%;
+}
+
+h3 {
+    font-size: 116%;
+}
+
+h4 {
+    font-size: 108%;
+}
+
+h5, h6 {
+    font-size: 100%;
+}
+
+/*fix for firefox in os x, where selects get the incorrect
+height if it's not explicitly set this shouldn't be noticeable in
+other browsers*/
+select {
+    height: 20px;
+}
+
+select.multiple {
+    height: auto;
+}
+
+#ds-header-wrapper {
+    background-color: #1F3F5E;
+    color: white;
+    min-width: 950px;
+}
+
+#ds-header-logo-link {
+    text-decoration: none;
+    cursor: pointer;
+}
+
+#ds-header-logo {
+    float:left;
+    width: 48px;
+    height: 50px;
+    margin-top: 10px;
+    background: url('../../images/dspace-logo-only.png');
+    background-repeat: no-repeat;
+    background-color: transparent;
+    margin-right: 15px;
+}
+
+#ds-header-logo-text {
+    font-size: 400%;
+    color: white;
+    line-height: 70px;
+    font-weight: normal;
+    vertical-align: middle;
+    float: left;
+}
+
+#ds-user-box {
+    right: 0;
+    top: 17px;
+    position: absolute;
+    color: white;
+}
+
+#ds-language-selection {
+    right: 0;
+    top: 40px;
+    position: absolute;
+    color: white;
+}
+
+#ds-user-box a, #ds-language-selection a {
+    color: white;
+}
+
+#ds-trail-wrapper {
+    background-color: #b6c8d9;
+    margin: 0;
+    padding: 0;
+    border-top: 1px solid #9cacba;
+    border-bottom: 1px solid #9cacba;
+    min-width: 950px;
+}
+
+#ds-trail {
+    list-style: none;
+    line-height: 138.5%;
+    margin: 0;
+    padding: 3px 0;
+}
+
+#ds-trail li {
+    display: inline;
+    color: #1F3F5E;
+    margin-right: 5px;
+}
+
+#ds-trail a {
+    color: #1F3F5E;
+}
+
+#no-js-warning,
+#ds-trail,
+#ds-header,
+#ds-footer,
+#ds-content {
+    width: 950px;
+    margin: auto;
+    position: relative;
+}
+
+/*ie6 uses quirks mode for strict xhtml pages, and in quirks mode margin: auto; doesn't center things*/
+.ie6 #no-js-warning-wrapper,
+.ie6 #ds-trail-wrapper,
+.ie6 #ds-header-wrapper,
+.ie6 #ds-footer-wrapper,
+.ie6 #ds-content-wrapper {
+    text-align: center;
+}
+
+.ie6 #ds-trail,
+.ie6 #ds-header,
+.ie6 #ds-footer,
+.ie6 #ds-content {
+    margin: 0;
+    text-align: left;
+}
+
+#ds-footer-wrapper {
+    margin-top: 40px;
+}
+
+#ds-footer {
+    border-top: 1px solid #9CACBA;
+    padding-top: 10px;
+    font-size: 93%;
+    line-height: 1.6em;
+}
+
+#ds-footer-left {
+    float: left;
+}
+
+#ds-footer-right {
+    float:right;
+}
+
+#ds-footer-right span.theme-by{
+    display: inline-block;
+    vertical-align: top;
+}
+
+#ds-footer-logo-link {
+    text-decoration:none;
+    line-height: 40px;
+    cursor: pointer;
+}
+
+#ds-footer-logo {
+    display: inline-block;
+    background: url('../../images/atmire-logo-small.svg');
+    background-repeat: no-repeat;
+    width: 110px;
+    height: 30px;
+}
+
+#ds-footer-links {
+    clear: left;
+}
+
+.ie6 #ds-footer-links {
+    display: inline;
+}
+
+/*make transparent PNGs invisible in IE6 until PNG-fix is applied*/
+.ie6 #ds-header-logo,
+.ie6 #ds-footer-logo {
+    visibility: hidden;
+}
+
+
+#ds-body {
+    float: left;
+    width: 675px;
+    padding-top: 10px;
+}
+
+#ds-options-wrapper {
+    float: right;
+    width: 249px;
+    padding-top:10px;
+}
+
+#ds-options {
+    padding: 0;
+}
+
+h1.ds-option-set-head {
+    margin-top: 20px;
+    background-color: #f0f2f5;
+    padding: 3px 10px;
+    border: 1px solid #d8e8eb;
+    border-bottom: none;
+    font-size: 108%;
+}
+
+#ds-search-option-head{
+    margin-top: 0;
+}
+
+div.ds-option-set {
+    border: 1px solid #d8e8eb;
+    border-top: none;
+}
+
+div.ds-option-set ul {
+    list-style: none;
+    margin-left: 10px;
+    padding-top: 5px;
+    padding-bottom: 5px;
+}
+
+div.ds-option-set .ds-sublist-head {
+    font-weight: normal;
+    font-size: 100%;
+}
+
+div.ds-option-set ul.sublist {
+    margin-left: 20px;
+    padding-top: 0;
+    padding-bottom: 0;
+}
+
+div#ds-feed-option li
+{
+    padding-top: 4px;
+}
+
+div#ds-feed-option a
+{
+    padding: 0px 0px 2px 20px;
+}
+
+#ds-search-option {
+    padding: 10px;
+}
+
+#ds-search-form {
+    margin-bottom: 10px;
+}
+
+#ds-search-form input.ds-text-field{
+    width: 169px;
+}
+
+#ds-search-form input.ds-button-field {
+    margin-left: 6px;
+}
+
+#ds-search-form input.ds-text-field,
+#ds-search-form input.ds-button-field{
+    margin-bottom: 10px;
+}
+
+p {
+    margin-bottom: 10px;
+}
+
+#aspect_eperson_EditProfile_list_form,
+.submission fieldset.ds-form-list,
+.administrative fieldset.ds-form-list {
+    margin-bottom: 25px;
+}
+
+.primary {
+    margin-top: 10px;
+    margin-bottom: 30px;
+}
+
+ol {
+    margin: 0;
+    list-style: none;
+}
+
+th,
+td {
+    padding: 5px;
+    vertical-align: middle;
+}
+
+.ds-button-field,
+#aspect_eperson_StartRegistration_list_registration-progress li {
+    background-color: #6d859c;
+    border: 1px solid #1F3F5E;
+    padding: 2px 5px;
+    color: #FFFFFF;
+    font-weight: bold;
+    cursor: pointer;
+}
+
+.ds-button-field[disabled="disabled"],
+.ds-button-field.disabled,
+li.button.disabled input {
+    opacity: 0.35;
+    cursor: auto;
+}
+
+#aspect_eperson_StartRegistration_list_registration-progress li {
+    cursor: default;
+}
+
+#aspect_eperson_StartRegistration_list_registration-progress li.arrow {
+    background-color: inherit;
+    border: none;
+    color: inherit;
+    font-weight: normal;
+}
+
+.ie6 #aspect_eperson_StartRegistration_list_registration-progress li.arrow,
+.ie7 #aspect_eperson_StartRegistration_list_registration-progress li.arrow {
+    background-color: #FFFFFF;
+    color: #444444;
+}
+
+.ie6 #aspect_eperson_StartRegistration_list_registration-progress li.arrow {
+    padding-top: 5px;
+}
+
+ul.ds-progress-list {
+    margin: 0 0 10px 0;
+    padding: 2px 0;
+    text-align: center;
+}
+
+ul.ds-progress-list li {
+    font-weight: bold;
+    overflow: hidden;
+    display: inline;
+    padding: 0;
+    margin: 0;
+    max-width: 400px;
+}
+
+ul.ds-progress-list li.button {
+        padding: 0;
+}
+
+ul.ds-progress-list li.button input.ds-button-field {
+        font-size: 77%;
+}
+
+.ie6 ul.ds-progress-list li.button input.ds-button-field,
+.ie7 ul.ds-progress-list li.button input.ds-button-field {
+    padding-left: 0;
+    padding-right: 0;
+}
+
+ul.ds-progress-list li.current input.ds-button-field,
+#aspect_eperson_StartRegistration_list_registration-progress li.current {
+    background-color: #499c73;
+    border: 1px solid #1f5e3f;
+}
+
+ul.ds-progress-list li.disabled input.ds-button-field
+#aspect_eperson_StartRegistration_list_registration-progress li.disabled {
+    background-color: #F0F2F5;
+    border: 1px solid #D8E8EB;
+    color: #444444;
+    cursor: default;
+}
+
+.ie6 .disabled,
+.ie6 li.disabled input,
+.ie7 .ds-button-field.disabled,
+.ie7 li.button.disabled input,
+.ie8 .ds-button-field.disabled,
+.ie8 li.button.disabled input {
+    filter: progid:DXImageTransform.Microsoft.Alpha(opacity = 50);
+    zoom: 1;
+    cursor: auto;
+}
+
+
+ul.ds-progress-list li.arrow {
+        border: none;
+        background: none;
+        font-size: 116%;
+        font-weight: normal;
+        margin-left: 3px;
+        margin-right: 3px;
+}
+
+.ie6 ul.ds-progress-list li.arrow {
+    height: 25px;
+    width: 25px;
+    margin: 0;
+}
+
+textarea.ds-textarea-field,
+input.ds-text-field,
+input.ds-file-field,
+input.ds-button-field,
+input.ds-password-field {
+    margin-bottom: 5px;
+    margin-top: 5px;
+    font-size: 93%;
+}
+
+textarea.ds-textarea-field,
+input.ds-text-field,
+input.ds-password-field {
+    padding: 3px;
+    border: 1px solid #AAAAAA;
+}
+
+.ie6 input.ds-text-field,
+.ie6 input.ds-password-field {
+    font-size: 85%;
+    height: 22px;
+}
+
+.submission .ds-form-list input.ds-text-field,
+.administrative .ds-form-list input.ds-text-field,
+textarea.ds-textarea-field {
+    width: 500px;
+}
+
+table textarea.ds-textarea-field {
+    width: 400px;
+}
+
+#aspect_administrative_item_EditItemMetadataForm_field_value {
+    width: 570px;
+}
+
+#aspect_administrative_registries_EditMetadataSchema_list_edit-schema-new-field-form .ds-text-field,
+#aspect_administrative_item_EditItemMetadataForm_field_language,
+.ds-composite-component input.ds-text-field {
+    width: auto;
+}
+
+textarea.ds-textarea-field:focus,
+input.ds-text-field:focus,
+input.input.ds-password-field:focus {
+    border-color: #5F9DE4;
+}
+
+/*
+ * Show a blue glow around a focused text field
+ * only target browsers that support rgba colors and boxshadows
+ * see http://www.modernizr.com/docs/
+ */
+.rgba.boxshadow textarea.ds-textarea-field:focus,
+.rgba.boxshadow input.ds-text-field:focus,
+.rgba.boxshadow input.ds-password-field:focus {
+    -moz-box-shadow:0 0 8px rgba(95, 158, 212, 0.5);
+    -webkit-box-shadow:0 0 8px rgba(95, 158, 212, 0.5);
+    box-shadow:0 0 8px rgba(95, 158, 212, 0.5);
+    border-color:rgba(95, 158, 212, 0.75);
+    outline:medium none;
+}
+
+span.error {
+    clear: both;
+    display: block;
+    color: #c22121;
+    font-size: 0.9em;
+    margin-top: 3px;
+}
+
+textarea.ds-textarea-field.error,
+input.ds-text-field.error,
+input.ds-password-field.error {
+    border-color: #c22121;
+    background-color: #fff2f2;
+}
+
+.rgba.boxshadow textarea.ds-textarea-field.error:focus,
+.rgba.boxshadow input.ds-text-field.error:focus,
+.rgba.boxshadow input.ds-password-field.error:focus {
+    -moz-box-shadow:0 0 8px rgba(194, 33, 33, 0.5);
+    -webkit-box-shadow:0 0 8px rgba(194, 33, 33, 0.5);
+    box-shadow:0 0 8px rgba(194, 33, 33, 0.5);
+    border-color:rgba(194, 33, 33, 0.75) !important;
+    outline:medium none;
+}
+
+
+.ds-form-list {
+    margin-top: 15px;
+}
+
+.submission h2,
+.ds-form-list legend{
+    font-size: 182%;
+    margin-bottom: 15px;
+    color: #1F3F5E;
+}
+
+.ds-form-item legend {
+    font-size: 100%;
+    margin:0;
+    color: inherit;
+}
+
+fieldset ol {
+    margin: 0;
+}
+
+li.ds-form-item {
+    list-style: none;
+    margin-bottom: 35px;
+    vertical-align: middle !important;
+    position: relative;
+    clear: left;
+}
+
+li.ds-form-item.last {
+    margin-bottom: 0;
+}
+
+li.ds-form-item .ds-form-label{
+    font-weight: bold;
+    font-size: 123.1%;
+}
+
+li.ds-form-item label.ds-composite-component{
+    display: block;
+    float: left;
+    font-size: 93%;
+    padding:0 8px 0 0;
+}
+
+li.ds-form-item label.ds-composite-component input.ds-text-field{
+    font-size: 100%;
+    width: 242px;
+}
+
+li.ds-form-item .ds-select-field {
+    margin-top: 5px;
+}
+
+.ds-add-button,
+label.ds-composite-component .ds-select-field {
+    margin-top: 6px;
+    margin-bottom: 6px;
+}
+
+li.ds-form-item label.ds-composite-component.last{
+    padding:0;
+}
+
+.ds-add-button {
+    vertical-align: top;
+    margin-left: 8px;
+}
+
+
+.ds-form-content input.ds-button-field {
+    font-size: 93%;
+}
+
+select#aspect_submission_submit_SelectCollectionStep_field_handle {
+    max-width: 350px;
+}
+
+#aspect_submission_StepTransformer_field_dc_date_issued_year,
+#aspect_submission_StepTransformer_field_dc_date_issued_day {
+    width: 50px;
+}
+
+#aspect_submission_StepTransformer_field_dc_identifier_value {
+    width: 130px;
+    margin-bottom: 0;
+}
+
+span.composite-help,
+span.field-help {
+    display: block;
+    font-size: 93%;
+    margin-top: 3px;
+    width: 506px;
+    text-align: justify;
+}
+
+.ds-checkbox-field input,
+.ds-radio-field input {
+    margin-left: 0;
+}
+
+.ds-checkbox-field label,
+.ds-radio-field label {
+    margin-right: 3px;
+}
+/*hide the double label for checkboxes & radio buttons*/
+.ds-checkbox-field legend,
+.ds-radio-field legend {
+    display: none;
+}
+
+.ds-previous-values {
+    margin-top: 10px;
+    clear: both;
+}
+
+#aspect_submission_Submissions_div_submissions .ds-static-div,
+.submission .ds-form-sublist ol {
+    background-color: #fafafa;
+    border: 1px solid #ebebeb;
+    margin-top: 3px;
+    margin-bottom: 30px;
+    padding: 10px;
+}
+
+#aspect_submission_Submissions_div_submissions table,
+#aspect_submission_Submissions_div_submissions table tr,
+#aspect_submission_Submissions_div_submissions table td,
+#aspect_submission_Submissions_div_submissions table th {
+    background-color: #FFFFFF;
+    border: 1px solid #9CACBA;
+}
+
+#aspect_submission_Submissions_div_submissions table tr.ds-table-header-row, 
+#aspect_submission_Submissions_div_submissions table tr.ds-table-header-row th {
+    background-color: #B6C8D9;
+    border: 1px solid #9CACBA;
+    
+}
+
+.submission .ds-form-sublist li.ds-form-item {
+    margin-bottom: 5px;
+}
+
+.submission .ds-form-sublist .ds-form-label {
+    font-weight: bold;
+}
+
+
+.administrative.tabbed ul.horizontal {
+    list-style: none;
+    margin: 15px 0 0;
+    border-bottom: 1px solid #9cacba;
+}
+
+.administrative.tabbed ul.horizontal li{
+    float: left;
+    border: 1px solid #9cacba;
+    padding: 5px;
+    margin-bottom: -1px;
+    margin-right: 7px;
+    border-bottom: none;
+}
+
+.administrative.tabbed ul.horizontal li a{
+    text-decoration: none;
+    color: #444444;
+}
+
+.administrative.tabbed ul.horizontal li.active-tab{
+    background-color: #fafafa;
+    z-index: 1;
+    font-weight: bold;
+}
+
+.pane {
+    padding: 10px;
+    clear: both;
+    background-color: #fafafa;
+    border: 1px solid #9cacba;
+    margin-bottom: 25px;
+    margin-top: 0;
+}
+
+.pane .ds-form-list {
+    margin-top: 0;
+}
+
+.administrative.tabbed .pane {
+    border-top: none;
+}
+
+.pagination,
+.pagination-masked {
+    padding: 7px;
+    background-color: #fafafa;
+    border: 1px solid #ebebeb;
+    line-height: 1em;
+    vertical-align:middle;
+}
+
+.pagination-links {
+    list-style: none;
+    float: right;
+    margin: 0;
+}
+
+.pagination-links li {
+    display: inline;
+    padding-left: 2px;
+    padding-right: 2px;
+}
+
+.current-page-link {
+    font-weight: bold;
+    color: #1F3F5E;
+}
+
+.current-page-link a{
+    color: #1F3F5E;
+}
+
+.pagination-info {
+    float: left;
+    margin:0;
+}
+
+.pagination-masked.top {
+    margin-top: 5px;
+}
+
+.ds-artifact-list {
+    list-style: none;
+    margin: 0;
+    line-height: 153.9%;
+}
+
+.file-wrapper,
+.ds-artifact-item {
+    padding-top: 15px;
+    padding-bottom: 15px;
+}
+
+.ds-artifact-item.collection,
+.ds-artifact-item.community {
+    padding-top: 1px;
+    padding-bottom: 1px;
+}
+
+.community .artifact-title a {
+    font-weight: bold;
+}
+
+.collection .artifact-title a {
+    font-weight: normal;
+}
+
+#aspect_artifactbrowser_CommunityBrowser_div_comunity-browser .short-description, #aspect_discovery_SiteRecentSubmissions_div_site-home .short-description {
+    display: none;
+}
+
+#aspect_artifactbrowser_SimpleSearch_div_search-results li, #aspect_discovery_SimpleSearch_div_search-results li, #aspect_artifactbrowser_AdvancedSearch_div_search-results li {
+    padding-top: 15px;
+    padding-bottom: 15px;
+}
+
+#aspect_artifactbrowser_SimpleSearch_div_search-results ul, #aspect_discovery_SimpleSearch_div_search-results ul, #aspect_artifactbrowser_AdvancedSearch_div_search-results ul {
+    margin-bottom: 25px;
+}
+
+.artifact-title {
+    font-size: 123.1%;
+}
+
+.result-query,
+.artifact-info {
+    color: gray;
+}
+
+.artifact-abstract {
+    text-align: justify;
+}
+
+ul.alphabet {
+    list-style: none;
+    margin: 0;
+}
+
+ul.alphabet li {
+    display:inline;
+}
+
+#aspect_eperson_PasswordLogin_list_password-login .ds-form-item {
+    float: left;
+    margin: 0;
+    margin-right: 25px;
+}
+
+#aspect_eperson_PasswordLogin_list_password-login .ds-form-item a {
+    margin-left: 20px;
+}
+
+#aspect_eperson_PasswordLogin_list_password-login .ds-form-item.last {
+    clear: left;
+}
+
+
+#aspect_eperson_PasswordLogin_list_password-login .ds-form-item.last .ds-form-label{
+    display: none;
+}
+
+td select.ds-select-field {
+    margin-left: 5px;
+}
+
+form.search,
+div.discoverySearchBox
+{
+    background-color: #fafafa;
+    border: 1px solid #ebebeb;
+    padding: 10px;
+    margin-bottom: 15px;
+}
+
+form.search label,
+div.discoverySearchBox label
+{
+    font-weight: bold;
+}
+
+form.search p.ds-paragraph.button-list,
+div.discoverySearchBox p.ds-paragraph.button-list
+{
+    text-align: center;
+    margin: 0;
+}
+
+form.search fieldset,
+div.discoverySearchBox fieldset {
+    margin: 0;
+}
+
+form.search .ds-form-item,
+div.discoverySearchBox .ds-form-item
+{
+    margin: 0;
+    padding-bottom: 5px;
+}
+
+form.search .ds-form-item select,
+div.discoverySearchBox .ds-form-item select
+{
+    margin-top: 0;
+}
+
+form.search label.ds-composite-component .ds-select-field,
+div.discoverySearchBox label.ds-composite-component .ds-select-field
+{
+    margin-top: 6px;
+}
+
+form.search .ds-form-item label,
+div.discoverySearchBox .ds-form-item label
+{
+    font-size: 100%;
+}
+
+form.search .ds-form-content,
+div.discoverySearchBox .ds-form-content
+{
+    display: inline;
+}
+
+form.search table input.ds-text-field,
+div.discoverySearchBox table input.ds-text-field
+{
+   margin: 0;
+}
+
+form.search .field-help,
+div.discoverySearchBox .field-help
+{
+    margin: 3px 0;
+}
+
+.collection .search,
+.community .search {
+    margin-top: 25px;
+}
+
+#aspect_discovery_CollectionSearch_p_search-query,
+#aspect_discovery_CommunitySearch_p_search-query{
+    margin-bottom:0;
+}
+
+.result-query {
+    margin-bottom: 30px;
+}
+
+#aspect_administrative_registries_EditMetadataSchema_table_metadata-schema-edit-existing-fields,
+#aspect_administrative_registries_MetadataRegistryMain_table_metadata-registry-main-table,
+#aspect_administrative_registries_FormatRegistryMain_table_bitstream-format-registry,
+#aspect_submission_Submissions_table_unfinished-submissions,
+#aspect_submission_Submissions_table_submissions-inprogress,
+#aspect_submission_Submissions_table_completed-submissions,
+table.detailtable {
+    margin-top: 10px;
+    margin-bottom: 10px;
+    border-collapse: collapse;
+}
+
+#aspect_administrative_registries_EditMetadataSchema_table_metadata-schema-edit-existing-fields tr,
+#aspect_administrative_registries_MetadataRegistryMain_table_metadata-registry-main-table tr,
+#aspect_administrative_registries_FormatRegistryMain_table_bitstream-format-registry tr,
+#aspect_submission_Submissions_table_unfinished-submissions tr,
+#aspect_submission_Submissions_table_submissions-inprogress tr,
+#aspect_submission_Submissions_table_completed-submissions tr,
+table.detailtable tr {
+    line-height: 1.6em;
+    border: 1px solid #ebebeb;
+}
+
+#aspect_administrative_registries_EditMetadataSchema_table_metadata-schema-edit-existing-fields tr.even,
+#aspect_administrative_registries_MetadataRegistryMain_table_metadata-registry-main-table tr.even,
+#aspect_administrative_registries_FormatRegistryMain_table_bitstream-format-registry tr.even,
+#aspect_submission_Submissions_table_unfinished-submissions tr.even,
+#aspect_submission_Submissions_table_submissions-inprogress tr.even,
+#aspect_submission_Submissions_table_completed-submissions tr.even,
+table.detailtable tr.even {
+    background-color: #fafafa;
+}
+
+#aspect_administrative_registries_EditMetadataSchema_table_metadata-schema-edit-existing-fields td,
+#aspect_administrative_registries_MetadataRegistryMain_table_metadata-registry-main-table td,
+#aspect_administrative_registries_FormatRegistryMain_table_bitstream-format-registry td,
+#aspect_submission_Submissions_table_unfinished-submissions td,
+#aspect_submission_Submissions_table_submissions-inprogress td,
+#aspect_submission_Submissions_table_completed-submissions td,
+table.detailtable td {
+    padding: 5px 10px;
+    text-align: justify;
+    border: 1px solid #ebebeb;
+    vertical-align: top;
+}
+
+#aspect_administrative_registries_EditMetadataSchema_table_metadata-schema-edit-existing-fields tr.ds-table-header-row,
+#aspect_administrative_registries_MetadataRegistryMain_table_metadata-registry-main-table tr.ds-table-header-row,
+#aspect_administrative_registries_FormatRegistryMain_table_bitstream-format-registry tr.ds-table-header-row,
+#aspect_submission_Submissions_table_unfinished-submissions tr.ds-table-header-row,
+#aspect_submission_Submissions_table_submissions-inprogress tr.ds-table-header-row,
+#aspect_submission_Submissions_table_completed-submissions tr.ds-table-header-row {
+    border: none;
+}
+
+
+table.detailtable td.label-cell {
+    font-weight: bold;
+    text-align: left;
+    width: 100px;
+}
+
+div.item-summary-view-metadata h1,
+div.item-summary-view-metadata h2 {
+    line-height: normal;
+}
+
+div.item-summary-view-metadata {
+    text-align: justify;
+    line-height: 161.6%;
+    margin-bottom: 30px;
+}
+
+div.simple-item-view-authors {
+    font-size: 123.1%;
+    font-weight: bold;
+    border-bottom:1px solid #D8E8EB;
+    padding-bottom: 2px;
+    margin-bottom: 20px;
+    text-align: justify;
+}
+
+div.simple-item-view-authors span{
+    text-align: justify;
+}
+
+#aspect_artifactbrowser_ItemViewer_div_item-view h2,
+div.item-summary-view-metadata p.item-view-toggle-bottom,
+div.simple-item-view-description {
+    margin-top: 20px;
+}
+
+#aspect_artifactbrowser_ItemViewer_div_item-view h2,
+div.simple-item-view-description h3{
+    border-bottom:1px solid #D8E8EB;
+    margin-bottom: 3px;
+}
+
+#aspect_artifactbrowser_ItemViewer_div_item-view h2 {
+    margin-bottom: 10px;
+}
+
+div.spacer{
+    height: 15px;
+}
+
+.thumbnail-wrapper,
+.file-metadata,
+.file-link {
+    float: left;
+    margin-right: 15px;
+}
+
+.item-metadata {
+    float: left;
+}
+
+.file-metadata {
+    width: 300px;
+}
+
+.file-metadata span,
+.item-metadata span {
+    float: left;
+}
+
+.item-metadata span.content span {
+    float: none;
+}
+
+.file-metadata span.bold,
+.item-metadata span.bold {
+    width: 80px;
+    clear: left;
+    text-align: right;
+    margin-right: 7px;
+}
+
+#ds-system-wide-alert,
+.notice {
+    padding: 10px;
+    margin: 10px 0;
+    border: 1px solid #bfc221;
+    background-color: #fffff2;
+}
+
+.notice.success
+{
+    border-color: #21c221;
+    background-color: #f2fff2;
+}
+
+#ds-system-wide-alert,
+.notice.failure
+{
+    border-color: #c22121;
+    background-color: #fff2f2;
+}
+
+#ds-system-wide-alert p {
+    margin: 0;
+}
+
+#aspect_artifactbrowser_CommunityViewer_div_community-home h2,
+#aspect_artifactbrowser_CollectionViewer_div_collection-home h2 {
+    margin-top: 30px;
+    border-bottom:1px solid #D8E8EB;
+    margin-bottom: 3px;
+}
+
+.ds-logo-wrapper {
+    display: block;
+}
+
+#aspect_administrative_item_FindItemForm_list_find-item-form .ds-form-item {
+    margin:0;
+}
+
+#aspect_administrative_registries_EditMetadataSchema_div_edit-schema-new-field  .ds-form-item.last {
+    margin-top: -25px;
+}
+
+#no-js-warning {
+    margin-top: 15px;
+    margin-bottom: 10px;
+    text-align: center;
+}
+
+form.discover-search-box{
+    margin-bottom: 10px;
+}
+
+
+form.discover-sort-box select{
+    margin: 0 4px;
+}
+
+.hidden {
+    display:none;
+    visibility:hidden;
+}
+
+.pre {
+    white-space:pre;
+}
+
+.icon-button{
+    padding:4px;
+    cursor: pointer;
+    margin: 2px;
+    background-color: #6D859C;
+    border: 1px solid #1F3F5E;
+    text-indent: -1000px;
+    width: 30px;
+    height: 30px;
+    display:block;
+    /*Required for IE*/
+    font-size: 0;
+    line-height: 0;
+}
+
+.icon-button.arrowUp{
+    background-image: url(../../images/arrow_up_ffffff_16x16.png);
+    background-repeat: no-repeat;
+    background-position: center center;
+}
+
+.icon-button.arrowDown{
+    background-image: url(../../images/arrow_down_ffffff_16x16.png);
+    background-repeat: no-repeat;
+    background-position: center center;
+}
+
+/* FOR CC License */
+span.floatleft {
+	border:none;
+	float:right;
+	display:inline;
+}
+
+/* FOR CC PAGE to GROUP ITEMS horizontally */
+ul.horizontal li span.bold a { color: black; }
+
+/* group items horizontally in a list */
+
+ul.horizontalVanilla
+{
+font-weight: bold;
+list-style-type: none;
+padding: 0px;
+padding-left: 0px;
+padding-bottom: 15px;
+border-left: 1px solid white;
+border-right: 1px solid white;
+margin: 10px -1px 5px -1px;
+width: inherit;
+}
+
+ul.horizontalVanilla li
+{
+float: left;
+height: 100%;
+background-color: rgb(255, 255, 255);
+margin: 2px 2px 0px 2px;
+/* border: 1px solid rgb(240, 240, 210); */
+}
+
+/* Controlled vocabulary support css START*/
+ul.vocabulary {
+    margin-left: 0;
+}
+
+ul.vocabulary,
+ul.vocabulary ul,
+ul.vocabulary li
+{
+    list-style: none;
+}
+
+ul.vocabulary div.vocabulary-node-icon{
+    cursor: pointer;
+    width: 15px;
+    height: 12px;
+    display: inline-block;
+}
+
+ul.vocabulary div.vocabulary-node-icon.vocabulary-doc{
+    background-image: url(../../images/controlledvocabulary/voc_doc_222222.png);
+}
+
+ul.vocabulary div.vocabulary-node-icon.vocabulary-open{
+    background-image: url(../../images/controlledvocabulary/voc_open_222222.png);
+}
+
+ul.vocabulary div.vocabulary-node-icon.vocabulary-closed{
+    background-image: url(../../images/controlledvocabulary/voc_closed_222222.png);
+    background-repeat: no-repeat;
+}
+
+div.vocabulary-container li.error{
+    color: #c22121;
+}
+/* Controlled vocabulary support css END*/
+
+#aspect_administrative_authorization_EditPolicyForm_field_start_date{
+    width: 100px;
+}
+#aspect_administrative_authorization_EditPolicyForm_field_end_date{
+    width: 100px;
+}
+#aspect_administrative_authorization_EditItemPolicies_table_policies-confirm-delete tr,
+#aspect_administrative_authorization_EditItemPolicies_table_policies-confirm-delete td
+{
+    border: 1px solid lightgray;
+}
+
+
+#aspect_administrative_authorization_AdvacedAuthorizationsForm_field_end_date{
+    width: 100px;
+}
+#aspect_administrative_authorization_AdvacedAuthorizationsForm_field_start_date{
+    width: 100px;
+}
+#aspect_submission_StepTransformer_field_embargo_until_date{
+    width: 100px;
+}
+
+#aspect_administrative_item_AddBitstreamForm_field_embargo_until_date{
+    width: 100px;
+}
+
+#aspect_administrative_item_EditBitstreamForm_field_embargo_until_date{
+    width: 100px;
+}
+
+#aspect_submission_StepTransformer_table_policies tr,
+#aspect_submission_StepTransformer_table_policies td
+{
+    border: 1px solid lightgray;
+}
+
+table.detailtable {
+    background-color: #D8E8EB;
+}
+
+table.detailtable th{
+    background-color: #F0F2F5;
+    word-wrap: normal;
+}
+
+table.detailtable td{
+    background-color: #FFFFFF;
+    text-align: right;
+}
+
+
+span.highlight{
+    font-weight: bold;
+}
+
+div.gear-icon{
+    background-image: url('../../images/gear_6D859C_25x25.png');
+}
+
+ul.gear-selection li.gear-option-selected{
+    background: url('../../images/check_606060_15x15.png') no-repeat 3px center;
+}
+
+input#aspect_discovery_SimpleSearch_field_query{
+    width: 565px;
+}
+
+input.search-icon{
+    background-image: url('../../images/search_icon_ffffff_20x20.png');
+    background-repeat: no-repeat;
+    background-position: center center;
+    text-indent: -1000px;
+        /*Css props below are required for IE*/
+    font-size: 0;
+    display:block;
+    line-height: 0;
+}
+
+div#aspect_discovery_SimpleSearch_div_search p.pagination-info{
+    display: none;
+}
+
+div#aspect_discovery_SimpleSearch_div_search .pagination-links{
+    float: left;
+}
+
+table.discovery-filters{
+    width: 100%;
+    background-color: #FFFFFF;
+}
+
+table.discovery-filters tr{
+    border-top: 1px solid #EBEBEB;
+}
+table.discovery-filters td{
+    padding: 0;
+}
+
+table.discovery-filters td.selection{
+    width: 1%;
+}
+
+table.discovery-filters th.new-filter-header{
+    text-align: left;
+    padding-top: 20px;
+}
+
+
+table.discovery-filters td.discovery-filter-input-cell {
+    padding-left: 3px;
+}
+
+
+table.discovery-filters tr.apply-filter{
+    background-color: #FAFAFA;
+}
+
+table.discovery-filters tr.apply-filter input{
+    width: 65px;
+    height: 25px;
+    margin-left: auto;
+    margin-right: auto;
+    font-size: 108%;
+    display: block;
+    margin-top: 10px;
+}
+
+
+table.discovery-filters td.filter-controls{
+    width: 50px;
+}
+
+table.discovery-filters input.filter-control {
+    margin-left: 5px;
+    text-indent: -1000px;
+    background-repeat: no-repeat;
+    background-position: center center;
+    height: 17px;
+    width: 17px;
+    float: left;
+    background-color: transparent;
+    border: none;
+    /*Css props below are required for IE*/
+    font-size: 0;
+    display:block;
+    line-height: 0;
+}
+
+table.discovery-filters input.filter-control.filter-remove{
+    margin-left: 7px;
+    background-image: url('../../images/button_minus.png');
+}
+
+table.discovery-filters input.filter-control.filter-add{
+    background-image: url('../../images/button_plus.png');
+}
+
+table.discovery-filters tr.search-filter.filler
+{
+    background-color: #FAFAFA;
+    height: 25px;
+}
+
+table.discovery-filters th.new-filter-header
+{
+    padding-top: 5px;
+}
+
+
+.searchTime{
+    color: #999999;
+}
+
+.didYouMean{
+    font-size: 18px;
+}
+
+.didYouMean a{
+    font-weight: bold;
+}
+
+.recentSubmissionViewMore {
+    text-align: right;
+    font-size: 100%;
+}
+
+
+/*Sherpa Colour Styles*/
+.sherpaList{
+    list-style-type: none;
+    margin-left: 0;
+    margin-bottom: 20px;
+}
+
+.sherpaLogo{
+    float:left;
+    margin-right:10px;
+    width: 100px;
+    height: 54px;
+}
+
+.sherpaBold{
+    font-weight:bold;
+    float:left;
+    margin-right: 3px;
+}
+
+.green{
+    background-color: #008000;
+    color: #ffffff;
+}
+
+.white{
+    background-color: #ffffff;
+    color: #000000;
+}
+
+.yellow{
+    background-color: #ffff00;
+    color: #000000;
+}
+
+.blue{
+    background-color: #0000ff;
+    color: #ffffff;
+}
+
+.gray{
+    background-color: #aaaaaa;
+    color: #000000;
+}
+
+.sherpaMoreInfo{
+    font-size: 75%;
+}
+
+.sherpaStyle {
+    display: inline;
+    padding: .2em .6em .3em;
+    font-size: 75%;
+    font-weight: 700;
+    line-height: 1;
+    text-align: center;
+    white-space: nowrap;
+    vertical-align: baseline;
+    border-radius: .25em;
+    float:left;
+    border: 1px solid #cccccc;
+    margin-right: 3px;
+}
+
+#impact-altmetric {
+    float:right;
+    margin:0 30px 0 30px;
+}
+
+#impact-plumx {
+    float:right;
+}
+
+/* Restore standard styling of lists in class ds-ordered-list */
+
+ol.ds-ordered-list {
+    list-style-type: decimal;
+    margin: 1.12em 0;
+    margin-left: 40px;
+}
+
+ol.ds-ordered-list ol.ds-ordered-list {
+    list-style-type: lower-alpha;
+}
+
+ol.ds-ordered-list ol.ds-ordered-list ol.ds-ordered-list {
+    list-style-type: lower-roman;
+}
+.publication-records-modal, .publication-records-modal ul {
+    list-style-type: none;
+    padding-left: 0px;
+}
+
+.publication-records-import-btn {
+    margin: 5px 0px 15px 0px;
+}
+
+.imported {
+    background-color: #E2E2E2;
+}
+
+
+#aspect_submission_StepTransformer_div_StartSubmissionLookupStep #aspect_submission_StepTransformer_field_search {
+    width: 81%;
+    display: inline;
+}
+
+#aspect_submission_StepTransformer_div_StartSubmissionLookupStep #aspect_submission_StepTransformer_field_lookup {
+    width:19%
+}
+
+#aspect_submission_StepTransformer_div_StartSubmissionLookupStep .modal .modal-body {
+    max-height: 500px;
+    overflow-y: auto;
+}
+
+#aspect_submission_StepTransformer_div_StartSubmissionLookupStep #aspect_submission_StepTransformer_item_publication-title{
+    margin-bottom:5px;
+}
+
+.break-all{
+    -ms-word-break:   break-all;
+    word-break:       break-all;
+    word-wrap:        break-word;
+}
+
+.orcid_icon {
+    text-decoration: none;
+    margin-top: -2px;
+}
diff --git a/dspace/modules/xmlui/src/main/webapp/themes/Mirage/lib/xsl/additions.xsl b/dspace/modules/xmlui/src/main/webapp/themes/Mirage/lib/xsl/additions.xsl
new file mode 100644
index 0000000000000000000000000000000000000000..a6a8581f6a8f2854928078b711ec29c88920a0c3
--- /dev/null
+++ b/dspace/modules/xmlui/src/main/webapp/themes/Mirage/lib/xsl/additions.xsl
@@ -0,0 +1,312 @@
+<!--
+
+    The contents of this file are subject to the license and copyright
+    detailed in the LICENSE and NOTICE files at the root of the source
+    tree and available online at
+
+    http://www.dspace.org/license/
+
+-->
+<!--
+    Rendering specific to the item display page.
+
+    Author: art.lowel at atmire.com
+    Author: lieven.droogmans at atmire.com
+    Author: ben at atmire.com
+    Author: Alexey Maslov
+
+-->
+
+<xsl:stylesheet
+    xmlns:i18n="http://apache.org/cocoon/i18n/2.1"
+    xmlns:dri="http://di.tamu.edu/DRI/1.0/"
+    xmlns:mets="http://www.loc.gov/METS/"
+    xmlns:dim="http://www.dspace.org/xmlns/dspace/dim"
+    xmlns:xlink="http://www.w3.org/TR/xlink/"
+    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"
+    xmlns="http://www.w3.org/1999/xhtml"
+    xmlns:xalan="http://xml.apache.org/xalan"
+    xmlns:encoder="xalan://java.net.URLEncoder"
+    xmlns:util="org.dspace.app.xmlui.utils.XSLUtils"
+    xmlns:jstring="java.lang.String"
+    xmlns:rights="http://cosimo.stanford.edu/sdr/metsrights/"
+    xmlns:confman="org.dspace.core.ConfigurationManager"
+    exclude-result-prefixes="xalan encoder i18n dri mets dim xlink xsl util jstring rights confman">
+
+    <xsl:output indent="yes"/>
+
+    <xsl:template name="itemSummaryView-DIM-fields">
+        <xsl:param name="clause" select="'1'"/>
+        <xsl:param name="phase" select="'even'"/>
+        <xsl:variable name="otherPhase">
+            <xsl:choose>
+                <xsl:when test="$phase = 'even'">
+                    <xsl:text>odd</xsl:text>
+                </xsl:when>
+                <xsl:otherwise>
+                    <xsl:text>even</xsl:text>
+                </xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+
+        <xsl:choose>
+            <!-- Title row -->
+            <xsl:when test="$clause = 1">
+
+                <xsl:choose>
+                    <xsl:when test="descendant::text() and (count(dim:field[@element='title'][not(@qualifier)]) &gt; 1)">
+                        <!-- display first title as h1 -->
+                        <h1>
+                            <xsl:value-of select="dim:field[@element='title'][not(@qualifier)][1]/node()"/>
+                        </h1>
+                        <div class="simple-item-view-other">
+                            <span class="bold"><i18n:text>xmlui.dri2xhtml.METS-1.0.item-title</i18n:text>:</span>
+                            <span>
+                                <xsl:for-each select="dim:field[@element='title'][not(@qualifier)]">
+                                    <xsl:value-of select="./node()"/>
+                                    <xsl:if test="count(following-sibling::dim:field[@element='title'][not(@qualifier)]) != 0">
+                                        <xsl:text>; </xsl:text>
+                                        <br/>
+                                    </xsl:if>
+                                </xsl:for-each>
+                            </span>
+                        </div>
+                    </xsl:when>
+                    <xsl:when test="dim:field[@element='title'][descendant::text()] and count(dim:field[@element='title'][not(@qualifier)]) = 1">
+                        <h1>
+                            <xsl:value-of select="dim:field[@element='title'][not(@qualifier)][1]/node()"/>
+                        </h1>
+                    </xsl:when>
+                    <xsl:otherwise>
+                        <h1>
+                            <i18n:text>xmlui.dri2xhtml.METS-1.0.no-title</i18n:text>
+                        </h1>
+                    </xsl:otherwise>
+                </xsl:choose>
+                <xsl:call-template name="itemSummaryView-DIM-fields">
+                    <xsl:with-param name="clause" select="($clause + 1)"/>
+                    <xsl:with-param name="phase" select="$otherPhase"/>
+                </xsl:call-template>
+            </xsl:when>
+
+            <!-- Author(s) row -->
+            <xsl:when test="$clause = 2 and (dim:field[@element='contributor'][@qualifier='author' and descendant::text()] or dim:field[@element='creator' and descendant::text()] or dim:field[@element='contributor' and descendant::text()])">
+                <div class="simple-item-view-authors">
+                    <xsl:choose>
+                        <xsl:when test="dim:field[@element='contributor'][@qualifier='author']">
+                            <xsl:for-each select="dim:field[@element='contributor'][@qualifier='author']">
+                                <span>
+                                    <xsl:if test="@authority">
+                                        <xsl:attribute name="class"><xsl:text>ds-dc_contributor_author-authority</xsl:text></xsl:attribute>
+                                    </xsl:if>
+                                    <xsl:choose>
+                                        <xsl:when test="@orcidID">
+                                            <xsl:call-template name="renderDiscovery">
+                                                <xsl:with-param name="value" select="node()"/>
+                                                <xsl:with-param name="orcidID" select="@orcidID"/>
+                                            </xsl:call-template>
+                                            <xsl:call-template name="renderORCID"/>
+                                        </xsl:when>
+                                        <xsl:otherwise>
+                                            <xsl:copy-of select="node()"/>
+                                        </xsl:otherwise>
+                                    </xsl:choose>
+                                </span>
+                                <xsl:if test="count(following-sibling::dim:field[@element='contributor'][@qualifier='author']) != 0">
+                                    <xsl:text>; </xsl:text>
+                                </xsl:if>
+                            </xsl:for-each>
+                        </xsl:when>
+                        <xsl:when test="dim:field[@element='creator']">
+                            <xsl:for-each select="dim:field[@element='creator']">
+                                <xsl:copy-of select="node()"/>
+                                <xsl:if test="count(following-sibling::dim:field[@element='creator']) != 0">
+                                    <xsl:text>; </xsl:text>
+                                </xsl:if>
+                            </xsl:for-each>
+                        </xsl:when>
+                        <xsl:when test="dim:field[@element='contributor']">
+                            <xsl:for-each select="dim:field[@element='contributor']">
+                                <xsl:copy-of select="node()"/>
+                                <xsl:if test="count(following-sibling::dim:field[@element='contributor']) != 0">
+                                    <xsl:text>; </xsl:text>
+                                </xsl:if>
+                            </xsl:for-each>
+                        </xsl:when>
+                        <xsl:otherwise>
+                            <i18n:text>xmlui.dri2xhtml.METS-1.0.no-author</i18n:text>
+                        </xsl:otherwise>
+                    </xsl:choose>
+                </div>
+                <xsl:call-template name="itemSummaryView-DIM-fields">
+                    <xsl:with-param name="clause" select="($clause + 1)"/>
+                    <xsl:with-param name="phase" select="$otherPhase"/>
+                </xsl:call-template>
+            </xsl:when>
+
+            <!-- identifier.uri row -->
+            <xsl:when test="$clause = 3 and (dim:field[@element='identifier' and @qualifier='uri' and descendant::text()])">
+                <div class="simple-item-view-other">
+                    <span class="bold"><i18n:text>xmlui.dri2xhtml.METS-1.0.item-uri</i18n:text>:</span>
+                    <span>
+                        <xsl:for-each select="dim:field[@element='identifier' and @qualifier='uri']">
+                            <a>
+                                <xsl:attribute name="href">
+                                    <xsl:copy-of select="./node()"/>
+                                </xsl:attribute>
+                                <xsl:copy-of select="./node()"/>
+                            </a>
+                            <xsl:if test="count(following-sibling::dim:field[@element='identifier' and @qualifier='uri']) != 0">
+                                <br/>
+                            </xsl:if>
+                        </xsl:for-each>
+                    </span>
+                </div>
+                <xsl:call-template name="itemSummaryView-DIM-fields">
+                    <xsl:with-param name="clause" select="($clause + 1)"/>
+                    <xsl:with-param name="phase" select="$otherPhase"/>
+                </xsl:call-template>
+            </xsl:when>
+
+            <!-- date.issued row -->
+            <xsl:when test="$clause = 4 and (dim:field[@element='date' and @qualifier='issued' and descendant::text()])">
+                <div class="simple-item-view-other">
+                    <span class="bold"><i18n:text>xmlui.dri2xhtml.METS-1.0.item-date</i18n:text>:</span>
+                    <span>
+                        <xsl:for-each select="dim:field[@element='date' and @qualifier='issued']">
+                            <xsl:copy-of select="substring(./node(),1,10)"/>
+                            <xsl:if test="count(following-sibling::dim:field[@element='date' and @qualifier='issued']) != 0">
+                                <br/>
+                            </xsl:if>
+                        </xsl:for-each>
+                    </span>
+                </div>
+                <xsl:call-template name="itemSummaryView-DIM-fields">
+                    <xsl:with-param name="clause" select="($clause + 1)"/>
+                    <xsl:with-param name="phase" select="$otherPhase"/>
+                </xsl:call-template>
+            </xsl:when>
+
+            <!-- Abstract row -->
+            <xsl:when test="$clause = 5 and (dim:field[@element='description' and @qualifier='abstract' and descendant::text()])">
+                <div class="simple-item-view-description">
+                    <h3><i18n:text>xmlui.dri2xhtml.METS-1.0.item-abstract</i18n:text>:</h3>
+                    <div>
+                        <xsl:if test="count(dim:field[@element='description' and @qualifier='abstract']) &gt; 1">
+                            <div class="spacer">&#160;</div>
+                        </xsl:if>
+                        <xsl:for-each select="dim:field[@element='description' and @qualifier='abstract']">
+                            <xsl:choose>
+                                <xsl:when test="node()">
+                                    <xsl:copy-of select="node()"/>
+                                </xsl:when>
+                                <xsl:otherwise>
+                                    <xsl:text>&#160;</xsl:text>
+                                </xsl:otherwise>
+                            </xsl:choose>
+                            <xsl:if test="count(following-sibling::dim:field[@element='description' and @qualifier='abstract']) != 0">
+                                <div class="spacer">&#160;</div>
+                            </xsl:if>
+                        </xsl:for-each>
+                        <xsl:if test="count(dim:field[@element='description' and @qualifier='abstract']) &gt; 1">
+                            <div class="spacer">&#160;</div>
+                        </xsl:if>
+                    </div>
+                </div>
+                <xsl:call-template name="itemSummaryView-DIM-fields">
+                    <xsl:with-param name="clause" select="($clause + 1)"/>
+                    <xsl:with-param name="phase" select="$otherPhase"/>
+                </xsl:call-template>
+            </xsl:when>
+
+            <!-- Description row -->
+            <xsl:when test="$clause = 6 and (dim:field[@element='description' and not(@qualifier) and descendant::text()])">
+                <div class="simple-item-view-description">
+                    <h3 class="bold"><i18n:text>xmlui.dri2xhtml.METS-1.0.item-description</i18n:text>:</h3>
+                    <div>
+                        <xsl:if test="count(dim:field[@element='description' and not(@qualifier)]) &gt; 1 and not(count(dim:field[@element='description' and @qualifier='abstract']) &gt; 1)">
+                            <div class="spacer">&#160;</div>
+                        </xsl:if>
+                        <xsl:for-each select="dim:field[@element='description' and not(@qualifier)]">
+                            <xsl:copy-of select="./node()"/>
+                            <xsl:if test="count(following-sibling::dim:field[@element='description' and not(@qualifier)]) != 0">
+                                <div class="spacer">&#160;</div>
+                            </xsl:if>
+                        </xsl:for-each>
+                        <xsl:if test="count(dim:field[@element='description' and not(@qualifier)]) &gt; 1">
+                            <div class="spacer">&#160;</div>
+                        </xsl:if>
+                    </div>
+                </div>
+                <xsl:call-template name="itemSummaryView-DIM-fields">
+                    <xsl:with-param name="clause" select="($clause + 1)"/>
+                    <xsl:with-param name="phase" select="$otherPhase"/>
+                </xsl:call-template>
+            </xsl:when>
+
+            <xsl:when test="$clause = 7 and $ds_item_view_toggle_url != ''">
+                <p class="ds-paragraph item-view-toggle item-view-toggle-bottom">
+                    <a>
+                        <xsl:attribute name="href"><xsl:value-of select="$ds_item_view_toggle_url"/></xsl:attribute>
+                        <i18n:text>xmlui.ArtifactBrowser.ItemViewer.show_full</i18n:text>
+                    </a>
+                </p>
+            </xsl:when>
+
+            <!-- recurse without changing phase if we didn't output anything -->
+            <xsl:otherwise>
+                <!-- IMPORTANT: This test should be updated if clauses are added! -->
+                <xsl:if test="$clause &lt; 8">
+                    <xsl:call-template name="itemSummaryView-DIM-fields">
+                        <xsl:with-param name="clause" select="($clause + 1)"/>
+                        <xsl:with-param name="phase" select="$phase"/>
+                    </xsl:call-template>
+                </xsl:if>
+            </xsl:otherwise>
+        </xsl:choose>
+
+        <!-- Generate the Creative Commons license information from the file section (DSpace deposit license hidden by default) -->
+        <xsl:apply-templates select="mets:fileSec/mets:fileGrp[@USE='CC-LICENSE']"/>
+    </xsl:template>
+
+    <xsl:template name="renderDiscovery">
+        <xsl:param name="value"/>
+        <xsl:param name="orcidID"/>
+        <a>
+            <xsl:attribute name="href">
+                <xsl:value-of select="$context-path"/>
+                <xsl:text>/discover?filtertype_1=orcidid</xsl:text>
+                <xsl:text>&amp;filter_relational_operator_1=equals&amp;filter_1=</xsl:text>
+                <xsl:value-of select="substring-after($orcidID, confman:getProperty('orcid.connector.url'))"/>
+            </xsl:attribute>
+            <xsl:value-of select="$value"/>
+        </a>
+    </xsl:template>
+
+    <xsl:template name="renderORCID">
+        <a class="orcid_icon" target="_blank" href="{@orcidID}">
+            <xsl:text> </xsl:text>
+            <img src="{$theme-path}/images/orcid_icon.png" alt="cc"/>
+        </a>
+    </xsl:template>
+
+    <xsl:template match="dri:reference" mode="summaryView">
+        <!-- simplified check to verify whether access rights are available in METS -->
+        <xsl:variable name='METSRIGHTS-enabled' select="contains(confman:getProperty('plugin.named.org.dspace.content.crosswalk.DisseminationCrosswalk'), 'METSRIGHTS')" />
+        <xsl:variable name="externalMetadataURL">
+            <xsl:text>cocoon:/</xsl:text>
+            <xsl:value-of select="@url"/>
+            <!-- If this is an Item, display the METSRIGHTS section, so we
+                 know which files have access restrictions.
+                 This requires the METSRightsCrosswalk to be enabled! -->
+            <xsl:if test="@type='DSpace Item' and $METSRIGHTS-enabled">
+                <xsl:text>?rightsMDTypes=METSRIGHTS</xsl:text>
+            </xsl:if>
+        </xsl:variable>
+        <!-- This comment just displays the full URL in an HTML comment, for easy reference. -->
+        <xsl:comment> External Metadata URL: <xsl:value-of select="$externalMetadataURL"/> </xsl:comment>
+        <xsl:apply-templates select="document($externalMetadataURL)" mode="summaryView"/>
+        <xsl:apply-templates />
+    </xsl:template>
+
+</xsl:stylesheet>
diff --git a/dspace/pom.xml b/dspace/pom.xml
index 5a8c643b98c0919f2198b4877e8e6302b491ad89..08054de31c0bcf9f11d0cf544ce3aea451d349bf 100644
--- a/dspace/pom.xml
+++ b/dspace/pom.xml
@@ -150,6 +150,10 @@
     </profiles>
 
     <dependencies>
+        <dependency>
+            <groupId>org.dspace.modules</groupId>
+            <artifactId>additions</artifactId>
+        </dependency>
     	<!-- This dependency ensures DSpace OAI JAR is added to [dspace]/lib/,
              so that the 'dspace oai' launcher.xml command works.  -->
     	<dependency>
diff --git a/dspace/solr/search/conf/schema.xml b/dspace/solr/search/conf/schema.xml
index 4b2f0ee88de501af4350721493f04cae0c9b9459..2855f0da883323d431641d1041aaa54e3edf31fa 100644
--- a/dspace/solr/search/conf/schema.xml
+++ b/dspace/solr/search/conf/schema.xml
@@ -586,6 +586,8 @@
     <dynamicField name="*.year" type="sint" indexed="true" stored="true" multiValued="true" omitNorms="true" />
     <dynamicField name="*_dt" type="date" indexed="true" stored="true" multiValued="false" omitNorms="true"  docValues="true"/>
 
+    <field name="orcid_id" type="string" multiValued="true" indexed="true" stored="true" required="false"/>
+     <copyField source="orcid_id" dest="orcidid_keyword"/>
 
     <!--Used for matching on all other fields -->
      <dynamicField name="*" type="text" multiValued="true"/>
