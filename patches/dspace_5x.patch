diff --git a/build.properties b/build.properties
new file mode 100644
index 0000000000000000000000000000000000000000..2c46f65d069bb6d4e11d52293814565e85d59fb1
--- /dev/null
+++ b/build.properties
@@ -0,0 +1,171 @@
+# DSpace build.properties
+# This file should be customised to suit your build environment.
+# Note that not all configuration is handled here, only the most common
+# properties that tend to differ between build environments. 
+# For adjusting global settings or more complex settings, edit the relevant config file.
+#
+# IMPORTANT: Do not remove or comment out settings in build.properties
+# When you edit the "build.properties" file (or a custom *.properties file),
+# take care not to remove or comment out any settings. Doing so, may cause
+# your final "dspace.cfg" file to be misconfigured with regards to that
+# particular setting.  Instead, if you wish to remove/disable a particular
+# setting, just clear out its value.  For example, if you don't want to be
+# notified of new user registrations, ensure the "mail.registration.notify"
+# setting has no value, e.g. "mail.registration.notify="
+#
+
+##########################
+# SERVER CONFIGURATION #
+##########################
+
+# DSpace installation directory. This is the location where you want
+# to install DSpace. NOTE: this value will be copied over to the
+# "dspace.dir" setting in the final "dspace.cfg" file. It can be
+# modified later on in your "dspace.cfg", if needed.
+dspace.install.dir=/dspace
+
+# DSpace host name - should match base URL.  Do not include port number
+dspace.hostname = localhost
+
+# DSpace base host URL.  Include port number etc.
+dspace.baseUrl = http://localhost:8080
+
+# The user interface you will be using for DSpace. Common usage is either xmlui or jspui
+dspace.ui = xmlui
+
+# Full link your end users will use to access DSpace. In most cases, this will be the baseurl followed by
+# the context path to the UI you are using.
+#
+# Alternatively, you can use a url redirect or deploy the web application under the servlet container root.
+# In this case, make sure to remove the /${dspace.ui} from the dspace.url property.
+dspace.url = ${dspace.baseUrl}/${dspace.ui}
+
+# Name of the site
+dspace.name = DSpace at My University
+
+# Solr server
+solr.server=http://localhost:8080/solr
+
+# Default language for metadata values
+default.language = en_US
+
+##########################
+# DATABASE CONFIGURATION #
+##########################
+
+# Uncomment the appropriate block below for your database.
+# postgres
+db.driver=org.postgresql.Driver
+db.url=jdbc:postgresql://localhost:5432/dspace
+db.username=dspace
+db.password=dspace
+
+# oracle
+#db.driver= oracle.jdbc.OracleDriver
+#db.url=jdbc:oracle:thin:@//localhost:1521/xe
+#db.username=dspace
+#db.password=dspace
+
+# Schema name - if your database contains multiple schemas, you can avoid
+# problems with retrieving the definitions of duplicate object names by
+# specifying the schema name that is used for DSpace.
+# ORACLE USAGE NOTE: In Oracle, schema is equivalent to "username". This means
+# specifying a "db.schema" is often unnecessary (i.e. you can leave it blank),
+# UNLESS your Oracle DB Account (in db.username) has access to multiple schemas.
+db.schema = 
+
+# Maximum number of DB connections in pool
+db.maxconnections = 30
+
+# Maximum time to wait before giving up if all connections in pool are busy (milliseconds)
+db.maxwait = 5000
+
+# Maximum number of idle connections in pool (-1 = unlimited)
+db.maxidle = -1
+
+# Determine if prepared statement should be cached. (default is true)
+db.statementpool = true
+
+# Specify a name for the connection pool (useful if you have multiple applications sharing Tomcat's dbcp)
+# If not specified, defaults to 'dspacepool'
+db.poolname = dspacepool
+
+#######################
+# EMAIL CONFIGURATION #
+#######################
+
+# SMTP mail server
+mail.server = smtp.example.com
+
+# SMTP mail server authentication username and password (if required)
+# mail.server.username = myusername
+# mail.server.password = mypassword
+mail.server.username=
+mail.server.password=
+
+# SMTP mail server alternate port (defaults to 25)
+mail.server.port = 25
+
+# From address for mail
+mail.from.address = dspace-noreply@myu.edu
+
+# Currently limited to one recipient!
+mail.feedback.recipient = dspace-help@myu.edu
+
+# General site administration (Webmaster) e-mail
+mail.admin = dspace-help@myu.edu
+
+# Recipient for server errors and alerts
+#mail.alert.recipient = email-address-here
+mail.alert.recipient=
+
+# Recipient for new user registration emails
+#mail.registration.notify = email-address-here
+mail.registration.notify=
+
+
+########################
+# HANDLE CONFIGURATION #
+########################
+
+# Canonical Handle URL prefix
+#
+# By default, DSpace is configured to use http://hdl.handle.net/
+# as the canonical URL prefix when generating dc.identifier.uri
+# during submission, and in the 'identifier' displayed in JSPUI
+# item record pages.
+#
+# If you do not subscribe to CNRI's handle service, you can change this
+# to match the persistent URL service you use, or you can force DSpace
+# to use your site's URL, eg.
+#handle.canonical.prefix = ${dspace.url}/handle/
+#
+# Note that this will not alter dc.identifer.uri metadata for existing
+# items (only for subsequent submissions), but it will alter the URL 
+# in JSPUI's 'identifier' message on item record pages for existing items.
+#
+# If omitted, the canonical URL prefix will be http://hdl.handle.net/
+handle.canonical.prefix = http://hdl.handle.net/
+
+# CNRI Handle prefix
+handle.prefix = 123456789
+
+#######################
+# PROXY CONFIGURATION #
+#######################
+# uncomment and specify both properties if proxy server required
+# proxy server for external http requests - use regular hostname without port number
+http.proxy.host =
+
+# port number of proxy server
+http.proxy.port =
+
+#####################
+# LOGLEVEL SETTINGS #
+#####################
+loglevel.other = INFO
+# loglevel.other: Log level for other third-party tools/APIs used by DSpace
+# Possible values (from most to least info): DEBUG, INFO, WARN, ERROR, FATAL
+loglevel.dspace = INFO
+# loglevel.dspace: Log level for all DSpace-specific code (org.dspace.*)
+# Possible values (from most to least info): DEBUG, INFO, WARN, ERROR, FATAL
diff --git a/dspace/config/dspace.cfg b/dspace/config/dspace.cfg
index 5b6b8c6ef5d2108444df40105e59c3bf4de61091..929707d2284274a1ea93404efa5fa9678ccfe779 100644
--- a/dspace/config/dspace.cfg
+++ b/dspace/config/dspace.cfg
@@ -753,7 +753,7 @@ event.dispatcher.default.class = org.dspace.event.BasicDispatcher
 # Add doi here if you are using org.dspace.identifier.DOIIdentifierProvider to generate DOIs.
 # Adding doi here makes DSpace send metadata updates to your doi registration agency.
 # Add rdf here, if you are using dspace-rdf to export your repository content as RDF.
-event.dispatcher.default.consumers = versioning, discovery, eperson, harvester
+event.dispatcher.default.consumers = authority, versioning, discovery, eperson, harvester
 
 # The noindex dispatcher will not create search or browse indexes (useful for batch item imports)
 event.dispatcher.noindex.class = org.dspace.event.BasicDispatcher
@@ -797,7 +797,7 @@ event.consumer.versioning.filters = Item+Install
 
 # authority consumer
 event.consumer.authority.class = org.dspace.authority.indexer.AuthorityConsumer
-event.consumer.authority.filters = Item+Modify|Modify_Metadata
+event.consumer.authority.filters = Item+Modify|Modify_Metadata|Install
 
 # ...set to true to enable testConsumer messages to standard output
 #testConsumer.verbose = true
@@ -1604,16 +1604,16 @@ sherpa.romeo.url = http://www.sherpa.ac.uk/romeo/api29.php
 # sherpa.romeo.apikey = YOUR-API-KEY
 
 #####  Authority Control Settings  #####
-#plugin.named.org.dspace.content.authority.ChoiceAuthority = \
+;plugin.named.org.dspace.content.authority.ChoiceAuthority = \
 # org.dspace.content.authority.SampleAuthority = Sample, \
 # org.dspace.content.authority.LCNameAuthority = LCNameAuthority, \
 # org.dspace.content.authority.SHERPARoMEOPublisher = SRPublisher, \
 # org.dspace.content.authority.SHERPARoMEOJournalTitle = SRJournalTitle, \
-#  org.dspace.content.authority.SolrAuthority = SolrAuthorAuthority
+;  org.dspace.content.authority.SolrAuthority = SolrAuthorAuthority
 
 #Uncomment to enable ORCID authority control
-#plugin.named.org.dspace.content.authority.ChoiceAuthority = \
-#    org.dspace.content.authority.SolrAuthority = SolrAuthorAuthority
+plugin.named.org.dspace.content.authority.ChoiceAuthority = \
+    org.dspace.content.authority.SolrAuthority = SolrAuthorAuthority
 
 ## The DCInputAuthority plugin is automatically configured with every
 ## value-pairs element in input-forms.xml, namely:
@@ -1652,13 +1652,19 @@ sherpa.romeo.url = http://www.sherpa.ac.uk/romeo/api29.php
 ## See manual or org.dspace.content.authority.Choices source for descriptions.
 authority.minconfidence = ambiguous
 
+# Uncomment to disable allowing updates of person authority values through the REST api.
+# authority.allow-rest-updates.person = false
+
+# Uncomment to disable allowing updates of ORCIDS authority values through the REST api.
+# authority.allow-rest-updates.orcid = false
+
 # Configuration settings for ORCID based authority control, uncomment the lines below to enable configuration
-#solr.authority.server=${solr.server}/authority
-#choices.plugin.dc.contributor.author = SolrAuthorAuthority
-#choices.presentation.dc.contributor.author = authorLookup
-#authority.controlled.dc.contributor.author = true
+solr.authority.server=${solr.server}/authority
+choices.plugin.dc.contributor.author = SolrAuthorAuthority
+choices.presentation.dc.contributor.author = authorLookup
+authority.controlled.dc.contributor.author = true
 #
-#authority.author.indexer.field.1=dc.contributor.author
+authority.author.indexer.field.1=dc.contributor.author
 
 ## demo: use LC plugin for author
 #choices.plugin.dc.contributor.author =  LCNameAuthority
@@ -1699,6 +1705,10 @@ authority.minconfidence = ambiguous
 # Change number of choices shown in the select in Choices lookup popup
 #xmlui.lookup.select.size = 12
 
+# Putting orcid.connector.url in the config.
+# This property is not only used in the spring config, but also in actual code, so the config is used to link it as well.
+orcid.connector.url =https://orcid.org/
+
 
 #### Ordering of bitstreams ####
 
diff --git a/dspace/config/spring/api/discovery.xml b/dspace/config/spring/api/discovery.xml
index 3a8f91db4c3fc3ddb0c67dc4d23f5c8af3e76d1b..918504232eaefae6263a31fd6ea12d3bd644cdf1 100644
--- a/dspace/config/spring/api/discovery.xml
+++ b/dspace/config/spring/api/discovery.xml
@@ -24,6 +24,7 @@
 
     <bean id="solrServiceResourceIndexPlugin" class="org.dspace.discovery.SolrServiceResourceRestrictionPlugin" scope="prototype"/>
     <bean id="SolrServiceSpellIndexingPlugin" class="org.dspace.discovery.SolrServiceSpellIndexingPlugin" scope="prototype"/>
+    <bean id="orcidIdIndexingPlugin" class="com.atmire.dspace.discovery.ORCIDIdIndexingPlugin"/>
 
     <alias name="solrServiceResourceIndexPlugin" alias="org.dspace.discovery.SolrServiceResourceRestrictionPlugin"/>
 
@@ -109,6 +110,7 @@
                 <ref bean="searchFilterAuthor" />
                 <ref bean="searchFilterSubject" />
                 <ref bean="searchFilterIssued" />
+                <ref bean="searchFilterOrcidFromAuthority" />
             </list>
         </property>
         <!--The sort filters for the discovery search-->
@@ -214,6 +216,7 @@
                 <ref bean="searchFilterAuthor" />
                 <ref bean="searchFilterSubject" />
                 <ref bean="searchFilterIssued" />
+                <ref bean="searchFilterOrcidFromAuthority" />
             </list>
         </property>
         <!--The sort filters for the discovery search (same as defaultConfiguration above)-->
@@ -405,6 +408,16 @@
         <property name="sortOrder" value="VALUE"/>
     </bean>
 
+    <bean class="org.dspace.discovery.configuration.DiscoverySearchFilter" id="searchFilterOrcidFromAuthority">
+        <property name="indexFieldName" value="orcidid" />
+        <property name="metadataFields">
+            <list>
+                <value>dc.identifier.orcid</value>
+                <value>orcid_id</value>
+            </list>
+        </property>
+    </bean>
+
     <!--Sort properties-->
     <bean id="sortTitle" class="org.dspace.discovery.configuration.DiscoverySortFieldConfiguration">
         <property name="metadataField" value="dc.title"/>
diff --git a/dspace/config/spring/api/orcid-authority-services.xml b/dspace/config/spring/api/orcid-authority-services.xml
index 7cf5e43dcf99c253d2a8a10b15f67565f4ff9393..cc2698c3d5043523db758cee63d3a08a7aac68b8 100644
--- a/dspace/config/spring/api/orcid-authority-services.xml
+++ b/dspace/config/spring/api/orcid-authority-services.xml
@@ -44,6 +44,9 @@
     <alias name="OrcidSource" alias="AuthoritySource"/>
     <bean name="OrcidSource" class="org.dspace.authority.orcid.Orcidv2" init-method="init">
         <constructor-arg value="https://pub.orcid.org/v2.1"/>
+        <constructor-arg value="https://api.orcid.org/oauth/token"/>
+        <constructor-arg value=""/>
+        <constructor-arg value=""/>
     </bean>
 
 
diff --git a/dspace/modules/additions/src/main/java/com/atmire/dspace/discovery/ORCIDIdIndexingPlugin.java b/dspace/modules/additions/src/main/java/com/atmire/dspace/discovery/ORCIDIdIndexingPlugin.java
new file mode 100644
index 0000000000000000000000000000000000000000..1f7a4cc6ef65b30bfe139f1d543ce670a4454e87
--- /dev/null
+++ b/dspace/modules/additions/src/main/java/com/atmire/dspace/discovery/ORCIDIdIndexingPlugin.java
@@ -0,0 +1,66 @@
+package com.atmire.dspace.discovery;
+
+import org.apache.commons.lang.StringUtils;
+import org.apache.solr.common.SolrInputDocument;
+import org.dspace.authority.AuthorityValue;
+import org.dspace.authority.AuthorityValueFinder;
+import org.dspace.authority.PersonAuthorityValue;
+import org.dspace.content.DSpaceObject;
+import org.dspace.content.Item;
+import org.dspace.content.Metadatum;
+import org.dspace.core.Constants;
+import org.dspace.core.Context;
+import org.dspace.discovery.SolrServiceIndexPlugin;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Created by jonas - jonas@atmire.com on 07/06/2018.
+ */
+public class ORCIDIdIndexingPlugin implements SolrServiceIndexPlugin {
+
+    private static final String ORCID_ID_FIELD = "orcid_id";
+
+    @Override
+    public void additionalIndex(Context context, DSpaceObject dso, SolrInputDocument document) {
+        if (dso != null && dso.getType() == Constants.ITEM) {
+            Item item = (Item) dso;
+
+            List<String> personAuthorityFields = new ArrayList<>();
+            for (Map.Entry<String, AuthorityValue> fieldDefaults : AuthorityValue.getAuthorityTypes().getFieldDefaults().entrySet()) {
+                if (fieldDefaults.getValue() instanceof PersonAuthorityValue) {
+                    personAuthorityFields.add(fieldDefaults.getKey());
+                }
+            }
+
+            for (String personAuthorityFieldKey : personAuthorityFields) {
+                String[] split = personAuthorityFieldKey.split("_");
+                Metadatum[] metadata = item.getMetadata(split[0], split[1], (split.length > 2) ? split[2] : null, Item.ANY);
+                for (Metadatum metadatum : metadata) {
+                    checkAndIndexMetadata(context, document, metadatum);
+                }
+            }
+
+        }
+    }
+
+    private void checkAndIndexMetadata(Context context, SolrInputDocument document, Metadatum metadatum) {
+        String authority = metadatum.authority;
+        if (StringUtils.isNotBlank(authority)) {
+
+            AuthorityValue value = new AuthorityValueFinder().findByUID(context, authority);
+            if (value != null) {
+                String orcidId = (String) value.getSolrInputDocument().getFieldValue(ORCID_ID_FIELD);
+                if (StringUtils.isNotBlank(orcidId)) {
+                    Collection<Object> fieldValues = document.getFieldValues(ORCID_ID_FIELD);
+                    if (fieldValues == null || !fieldValues.contains(orcidId)) {
+                        document.addField(ORCID_ID_FIELD, orcidId);
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/dspace/modules/additions/src/main/java/org/dspace/authority/AuthorityUtil.java b/dspace/modules/additions/src/main/java/org/dspace/authority/AuthorityUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..e6f2d157b471d9b0a9a8fdf4300b9575d637a098
--- /dev/null
+++ b/dspace/modules/additions/src/main/java/org/dspace/authority/AuthorityUtil.java
@@ -0,0 +1,190 @@
+package org.dspace.authority;
+
+import org.apache.log4j.Logger;
+import org.apache.solr.client.solrj.SolrServerException;
+import org.dspace.authority.indexer.AuthorityIndexingService;
+import org.dspace.authority.orcid.Orcidv2AuthorityValue;
+import org.dspace.content.Item;
+import org.dspace.content.ItemIterator;
+import org.dspace.content.Metadatum;
+import org.dspace.content.authority.Choice;
+import org.dspace.content.authority.ChoiceAuthorityManager;
+import org.dspace.content.authority.Choices;
+import org.dspace.content.authority.MetadataAuthorityManager;
+import org.dspace.core.Constants;
+import org.dspace.core.Context;
+import org.dspace.storage.rdbms.TableRowIterator;
+import org.dspace.utils.DSpace;
+
+import java.io.IOException;
+import java.sql.SQLException;
+import java.util.Date;
+
+import static org.apache.commons.lang.StringUtils.isNotBlank;
+import static org.apache.log4j.Logger.getLogger;
+import static org.dspace.storage.rdbms.DatabaseManager.queryTable;
+
+public class AuthorityUtil {
+
+    protected static final Logger log = getLogger(AuthorityUtil.class);
+
+    private AuthorityIndexingService indexingService = new DSpace().getServiceManager()
+            .getServiceByName(AuthorityIndexingService.class.getName(), AuthorityIndexingService.class);
+
+    public void addMetadataWithOrcid(Context context, Item item, Metadatum metadatum) {
+
+        String orcidID = metadatum.authority;
+        String orcidAuthorityID = null;
+
+        if (isOrcidFormat(orcidID)) {
+
+            AuthorityValue orcidAuthority = new AuthorityValueFinder().findByOrcidID(context, orcidID);
+            if (orcidAuthority == null) {
+                orcidAuthorityID = createOrcidAuthority(metadatum, orcidID);
+            } else {
+                orcidAuthorityID = orcidAuthority.getId();
+            }
+        }
+
+        if (orcidAuthorityID != null) {
+            item.addMetadata(metadatum.schema, metadatum.element, metadatum.qualifier, metadatum.language,
+                    metadatum.value, orcidAuthorityID, Choices.CF_ACCEPTED);
+
+        } else {
+            item.addMetadata(metadatum.schema, metadatum.element, metadatum.qualifier, metadatum.language,
+                    metadatum.value);
+        }
+    }
+
+    private String createOrcidAuthority(final Metadatum metadatum, final String orcidID) {
+
+        return createSolrOrcidAuthority(metadatum, orcidID);
+    }
+
+    private String createSolrOrcidAuthority(final Metadatum metadatum, final String orcidID) {
+
+        Orcidv2AuthorityValue authorityValue = Orcidv2AuthorityValue.create();
+        authorityValue.setValue(metadatum.value);
+        authorityValue.setField(metadatum.getField().replaceAll("\\.", "_"));
+
+        return updateOrcidAuthorityValue(orcidID, authorityValue);
+    }
+
+    public boolean isOrcidFormat(final String authority) {
+
+        return isNotBlank(authority) && authority.matches("\\d{4}-\\d{4}-\\d{4}-(\\d{3}X|\\d{4})");
+    }
+
+    private String updateOrcidAuthorityValue(String orcidID, Orcidv2AuthorityValue value) {
+
+        if (value == null) {
+            return null;
+        }
+
+        value.setOrcid_id(orcidID);
+        Date now = new Date();
+        value.setLastModified(now);
+        value.setCreationDate(now);
+        indexingService.indexContent(value, false);
+        indexingService.commit();
+        return value.getId();
+    }
+
+    public void addMetadata(Context context, Item dspaceItem, String[] field, String value, String language) throws SQLException {
+
+        String[] splitAuthority = splitAuthority(value);
+
+        Metadatum metadatum = new Metadatum();
+        metadatum.schema = field[0];
+        metadatum.element = field[1];
+        metadatum.qualifier = field[2];
+        metadatum.language = language;
+        metadatum.value = splitAuthority[0];
+
+        if (splitAuthority.length > 1) {
+
+            metadatum.authority = splitAuthority[1];
+            if (isOrcidFormat(metadatum.authority)) {
+                addMetadataWithOrcid(context, dspaceItem, metadatum);
+            } else {
+                addMetadataWithAuthority(context, dspaceItem, metadatum);
+            }
+        } else {
+            addMetadataWhenNoAuthorityIsProvided(context, dspaceItem, metadatum);
+        }
+    }
+
+    private String[] splitAuthority(final String value) {
+        return value.split("::");
+    }
+
+    public void addMetadataWithAuthority(Context context, Item item, final Metadatum metadatum) {
+        String authorityValue = getAuthorityValue(context, metadatum);
+        if (authorityValue != null) {
+            item.addMetadata(metadatum.schema, metadatum.element, metadatum.qualifier, metadatum.language,
+                    authorityValue, metadatum.authority, Choices.CF_ACCEPTED);
+        } else {
+            item.addMetadata(metadatum.schema, metadatum.element, metadatum.qualifier, metadatum.language,
+                    metadatum.value);
+        }
+    }
+
+    public void addMetadataWhenNoAuthorityIsProvided(Context context, Item item, Metadatum metadatum) {
+        MetadataAuthorityManager mam = MetadataAuthorityManager.getManager();
+        String fieldKey = MetadataAuthorityManager
+                .makeFieldKey(metadatum.schema, metadatum.element, metadatum.qualifier);
+
+        boolean fieldAdded = false;
+
+        if ( mam.isAuthorityControlled(fieldKey)) {
+            if (isPersonAuthority(fieldKey)) {
+
+                Choices c = ChoiceAuthorityManager.getManager().getMatches(fieldKey, metadatum.value, -1, 0, 0, null);
+                for (Choice choice : c.values) {
+                    AuthorityValue matchedAuthority = new AuthorityValueFinder().findByUID(context, c.values[0].authority);
+                    if (!(matchedAuthority instanceof Orcidv2AuthorityValue)) {
+                        item.addMetadata(metadatum.schema, metadatum.element, metadatum.qualifier,
+                                metadatum.language,
+                                metadatum.value, choice.authority, c.confidence);
+                        fieldAdded = true;
+                        break;
+                    }
+                }
+            }
+        }
+
+        // make sure the field is always added to the metadata
+        if(!fieldAdded) {
+            item.addMetadata(metadatum.schema, metadatum.element, metadatum.qualifier, metadatum.language,
+                    new String[]{metadatum.value}, null, null);
+        }
+    }
+
+    public boolean isPersonAuthority(final String fieldKey) {
+
+        return AuthorityValue.getAuthorityTypes().getFieldDefaults()
+                .get(fieldKey.replaceAll("\\.", "_")) instanceof PersonAuthorityValue;
+    }
+
+    private String getAuthorityValue(Context context, final Metadatum metadatum) {
+
+        AuthorityValue authority = new AuthorityValueFinder().findByUID(context, metadatum.authority);
+
+        return authority != null ? authority.getValue() : null;
+    }
+
+    public ItemIterator findItemsByAuthorityValue(Context context, String value)
+            throws SQLException {
+
+        TableRowIterator rows = queryTable(context, "item",
+                "SELECT item.* FROM metadatavalue,item WHERE "+
+                        "item.item_id = metadatavalue.resource_id AND authority = ? AND resource_type_id = ?", value, Constants.ITEM);
+
+        return new ItemIterator(context, rows);
+    }
+
+    public void deleteAuthorityValueById(String id) throws IOException, SolrServerException {
+        ((AuthoritySolrServiceImpl) indexingService).getSolr().deleteByQuery("id:\"" + id + "\"");
+        indexingService.commit();
+    }
+}
diff --git a/dspace/modules/additions/src/main/java/org/dspace/authority/AuthorityValueFinder.java b/dspace/modules/additions/src/main/java/org/dspace/authority/AuthorityValueFinder.java
new file mode 100644
index 0000000000000000000000000000000000000000..ed4a9b4491670004043d5ab7bc9d64228c056cf0
--- /dev/null
+++ b/dspace/modules/additions/src/main/java/org/dspace/authority/AuthorityValueFinder.java
@@ -0,0 +1,133 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.authority;
+
+import org.apache.commons.lang.StringUtils;
+import org.apache.log4j.Logger;
+import org.apache.solr.client.solrj.SolrQuery;
+import org.apache.solr.client.solrj.response.QueryResponse;
+import org.apache.solr.common.SolrDocument;
+import org.dspace.authority.orcid.Orcidv2AuthorityValue;
+import org.dspace.content.authority.SolrAuthority;
+import org.dspace.core.Context;
+import org.dspace.core.LogManager;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ *
+ * @author Antoine Snyers (antoine at atmire.com)
+ * @author Kevin Van de Velde (kevin at atmire dot com)
+ * @author Ben Bosman (ben at atmire dot com)
+ * @author Mark Diggory (markd at atmire dot com)
+ */
+public class AuthorityValueFinder {
+
+    /**
+     * log4j logger
+     */
+    private static Logger log = Logger.getLogger(AuthorityValueFinder.class);
+
+    /**
+     * Item.ANY does not work here.
+     */
+    public AuthorityValue findByUID(Context context, String authorityID) {
+        //Ensure that if we use the full identifier to match on
+        String queryString = "id:\"" + authorityID + "\"";
+        List<AuthorityValue> findings = find(context, queryString);
+        return findings.size() > 0 ? findings.get(0) : null;
+    }
+
+    public List<AuthorityValue> findByExactValue(Context context, String field, String value) {
+        String queryString = "value:\"" + value + "\" AND field:" + field;
+        return find(context, queryString);
+    }
+
+    public List<AuthorityValue> findByValue(Context context, String field, String value) {
+        String queryString = "value:" + value + " AND field:" + field;
+        return find(context, queryString);
+    }
+
+    public List<AuthorityValue> findByValue(Context context, String schema, String element, String qualifier, String value) {
+        String field = fieldParameter(schema, element, qualifier);
+        return findByValue(context, field, qualifier);
+    }
+
+    public AuthorityValue findByOrcidID(Context context, String orcid_id) {
+        String queryString = "orcid_id:" + orcid_id;
+        List<AuthorityValue> findings = find(context, queryString);
+        return findings.size() > 0 ? findings.get(0) : null;
+    }
+
+    public List<AuthorityValue> findByName(Context context, String schema, String element, String qualifier, String name) {
+        String field = fieldParameter(schema, element, qualifier);
+        String queryString = "first_name:" + name + " OR last_name:" + name + " OR name_variant:" + name + " AND field:" + field;
+        return find(context, queryString);
+    }
+
+    public List<AuthorityValue> findByAuthorityMetadata(Context context, String schema, String element, String qualifier, String value) {
+        String field = fieldParameter(schema, element, qualifier);
+        String queryString = "all_Labels:" + value + " AND field:" + field;
+        return find(context, queryString);
+    }
+
+    public List<AuthorityValue> findOrcidHolders(Context context) {
+        String queryString = "orcid_id:*";
+        return find(context, queryString);
+    }
+
+    public List<AuthorityValue> findAll(Context context) {
+        String queryString = "*:*";
+        return find(context, queryString);
+    }
+
+    private List<AuthorityValue> find(Context context, String queryString) {
+        List<AuthorityValue> findings = new ArrayList<AuthorityValue>();
+        try {
+            SolrQuery solrQuery = new SolrQuery();
+            solrQuery.setQuery(filtered(queryString));
+            log.debug("AuthorityValueFinder makes the query: " + queryString);
+            QueryResponse queryResponse = SolrAuthority.getSearchService().search(solrQuery);
+            if (queryResponse != null && queryResponse.getResults() != null && 0 < queryResponse.getResults().getNumFound()) {
+                for (SolrDocument document : queryResponse.getResults()) {
+                    AuthorityValue authorityValue;
+                    if ("orcid".equals(document.getFieldValue("authority_type"))) {
+                        authorityValue = new Orcidv2AuthorityValue(document);
+                        ((Orcidv2AuthorityValue) authorityValue).setOrcid_id((String) document.getFieldValue("orcid_id"));
+                    } else if (new AuthorityUtil().isPersonAuthority(document.getFieldValue("field") + "")) {
+                        authorityValue = new PersonAuthorityValue(document);
+                    } else {
+                        authorityValue = new AuthorityValue(document);
+                    }
+                    findings.add(authorityValue);
+                    log.debug("AuthorityValueFinder found: " + authorityValue.getValue());
+                }
+            }
+        } catch (Exception e) {
+            log.error(LogManager.getHeader(context, "Error while retrieving AuthorityValue from solr", "query: " + queryString),e);
+        }
+
+        return findings;
+    }
+
+    private String filtered(String queryString) throws InstantiationException, IllegalAccessException {
+        String instanceFilter = "-deleted:true";
+        if (StringUtils.isNotBlank(instanceFilter)) {
+            queryString += " AND " + instanceFilter;
+        }
+        return queryString;
+    }
+
+    private String fieldParameter(String schema, String element, String qualifier) {
+        return schema + "_" + element + ((qualifier != null) ? "_" + qualifier : "");
+    }
+
+
+}
diff --git a/dspace/modules/additions/src/main/java/org/dspace/authority/PersonAuthorityValue.java b/dspace/modules/additions/src/main/java/org/dspace/authority/PersonAuthorityValue.java
new file mode 100644
index 0000000000000000000000000000000000000000..0653d9e02aaec0ed7451fb500423a322dbbd45c9
--- /dev/null
+++ b/dspace/modules/additions/src/main/java/org/dspace/authority/PersonAuthorityValue.java
@@ -0,0 +1,276 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.authority;
+
+import org.apache.commons.codec.digest.DigestUtils;
+import org.apache.commons.lang.ObjectUtils;
+import org.apache.commons.lang.StringUtils;
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.SolrInputDocument;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+
+/**
+ *
+ * @author Antoine Snyers (antoine at atmire.com)
+ * @author Kevin Van de Velde (kevin at atmire dot com)
+ * @author Ben Bosman (ben at atmire dot com)
+ * @author Mark Diggory (markd at atmire dot com)
+ */
+public class PersonAuthorityValue extends AuthorityValue {
+
+    private String firstName;
+    private String lastName;
+    private List<String> nameVariants = new ArrayList<String>();
+    private String institution;
+    private List<String> emails = new ArrayList<String>();
+
+    public PersonAuthorityValue() {
+    }
+
+    public PersonAuthorityValue(SolrDocument document) {
+        super(document);
+    }
+
+    @Override
+    public String getId() {
+        // A PersonValue is considered unique with the first & last name.
+        String nonDigestedIdentifier;
+        if(StringUtils.isNotBlank(firstName)) {
+            nonDigestedIdentifier = org.dspace.authority.PersonAuthorityValue.class.toString() + "field: Person " + "lastName: " + lastName + ", firstName: " + firstName;
+        }
+        else {
+            nonDigestedIdentifier = org.dspace.authority.PersonAuthorityValue.class.toString() + "field: Person " + "lastName: " + lastName ;
+        }
+        // We return an md5 digest of the toString, this will ensure a unique identifier for the same value each time
+        return DigestUtils.md5Hex(nonDigestedIdentifier);
+    }
+
+    public String getName() {
+        String name = "";
+        if (StringUtils.isNotBlank(lastName)) {
+            name = lastName;
+            if (StringUtils.isNotBlank(firstName)) {
+                name += ", ";
+            }
+        }
+        if (StringUtils.isNotBlank(firstName)) {
+            name += firstName;
+        }
+        return name;
+    }
+
+    public void setName(String name) {
+        if (StringUtils.isNotBlank(name)) {
+            String[] split = name.split(",");
+            if (split.length > 0) {
+                setLastName(split[0].trim());
+                if (split.length > 1) {
+                    setFirstName(split[1].trim());
+                } else {
+                    setFirstName(null);
+                }
+            }
+        }
+        if (!StringUtils.equals(getValue(), name)) {
+            setValue(name);
+        }
+    }
+
+    @Override
+    public void setValue(String value) {
+        super.setValue(value);
+        setName(value);
+    }
+
+    public String getFirstName() {
+        return firstName;
+    }
+
+    public void setFirstName(String firstName) {
+        this.firstName = firstName;
+    }
+
+    public String getLastName() {
+        return lastName;
+    }
+
+    public void setLastName(String lastName) {
+        this.lastName = lastName;
+    }
+
+    public List<String> getNameVariants() {
+        return nameVariants;
+    }
+
+    public void addNameVariant(String name) {
+        if (StringUtils.isNotBlank(name)) {
+            nameVariants.add(name);
+        }
+    }
+
+    public String getInstitution() {
+        return institution;
+    }
+
+    public void setInstitution(String institution) {
+        this.institution = institution;
+    }
+
+    public List<String> getEmails() {
+        return emails;
+    }
+
+    public void addEmail(String email) {
+        if (StringUtils.isNotBlank(email)) {
+            emails.add(email);
+        }
+    }
+
+    @Override
+    public SolrInputDocument getSolrInputDocument() {
+        SolrInputDocument doc = super.getSolrInputDocument();
+        if (StringUtils.isNotBlank(getFirstName())) {
+            doc.addField("first_name", getFirstName());
+        }
+        if (StringUtils.isNotBlank(getLastName())) {
+            doc.addField("last_name", getLastName());
+        }
+        for (String nameVariant : getNameVariants()) {
+            doc.addField("name_variant", nameVariant);
+        }
+
+        for (String email : emails) {
+            doc.addField("email", email);
+        }
+        doc.addField("institution", getInstitution());
+        return doc;
+    }
+
+    @Override
+    public void setValues(SolrDocument document) {
+        super.setValues(document);
+        this.firstName = ObjectUtils.toString(document.getFieldValue("first_name"));
+        this.lastName = ObjectUtils.toString(document.getFieldValue("last_name"));
+        nameVariants = new ArrayList<String>();
+        Collection<Object> document_name_variant = document.getFieldValues("name_variant");
+        if (document_name_variant != null) {
+            for (Object name_variants : document_name_variant) {
+                addNameVariant(String.valueOf(name_variants));
+            }
+        }
+        if (document.getFieldValue("institution") != null) {
+            this.institution = String.valueOf(document.getFieldValue("institution"));
+        }
+
+        Collection<Object> emails = document.getFieldValues("email");
+        if (emails != null) {
+            for (Object email : emails) {
+                addEmail(String.valueOf(email));
+            }
+        }
+    }
+
+
+    @Override
+    public Map<String, String> choiceSelectMap() {
+
+        Map<String, String> map = super.choiceSelectMap();
+
+        if (StringUtils.isNotBlank(getFirstName())) {
+            map.put("first-name", getFirstName());
+        } else {
+            map.put("first-name", "/");
+        }
+
+        if (StringUtils.isNotBlank(getLastName())) {
+            map.put("last-name", getLastName());
+        } else {
+            map.put("last-name", "/");
+        }
+
+        if (!getEmails().isEmpty()) {
+            boolean added = false;
+            for (String email : getEmails()) {
+                if (!added && StringUtils.isNotBlank(email)) {
+                    map.put("email",email);
+                    added = true;
+                }
+            }
+        }
+        if (StringUtils.isNotBlank(getInstitution())) {
+            map.put("institution", getInstitution());
+        }
+
+        return map;
+    }
+
+    @Override
+    public String getAuthorityType() {
+        return "person";
+    }
+
+    @Override
+    public String generateString() {
+        return AuthorityValueGenerator.GENERATE + getAuthorityType() + AuthorityValueGenerator.SPLIT + getName();
+        // the part after "AuthorityValueGenerator.GENERATE + getAuthorityType() + AuthorityValueGenerator.SPLIT" is the value of the "info" parameter in public AuthorityValue newInstance(String info)
+    }
+
+    @Override
+    public AuthorityValue newInstance(String info) {
+        PersonAuthorityValue authorityValue = new PersonAuthorityValue();
+        authorityValue.setValue(info);
+        return authorityValue;
+    }
+
+    @Override
+    public String toString() {
+        return "PersonAuthorityValue{" +
+                "firstName='" + firstName + '\'' +
+                ", lastName='" + lastName + '\'' +
+                ", nameVariants=" + nameVariants +
+                ", institution='" + institution + '\'' +
+                ", emails=" + emails +
+                "} " + super.toString();
+    }
+
+    public boolean hasTheSameInformationAs(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+        if(!super.hasTheSameInformationAs(o)){
+            return false;
+        }
+
+        PersonAuthorityValue that = (PersonAuthorityValue) o;
+
+        if (emails != null ? !emails.equals(that.emails) : that.emails != null) {
+            return false;
+        }
+        if (firstName != null ? !firstName.equals(that.firstName) : that.firstName != null) {
+            return false;
+        }
+        if (institution != null ? !institution.equals(that.institution) : that.institution != null) {
+            return false;
+        }
+        if (lastName != null ? !lastName.equals(that.lastName) : that.lastName != null) {
+            return false;
+        }
+        if (nameVariants != null ? !nameVariants.equals(that.nameVariants) : that.nameVariants != null) {
+            return false;
+        }
+
+        return true;
+    }
+}
diff --git a/dspace/modules/additions/src/main/java/org/dspace/authority/orcid/Orcidv2AuthorityValue.java b/dspace/modules/additions/src/main/java/org/dspace/authority/orcid/Orcidv2AuthorityValue.java
new file mode 100644
index 0000000000000000000000000000000000000000..9b01a17be131b2df9875b30dc6f986f466744afe
--- /dev/null
+++ b/dspace/modules/additions/src/main/java/org/dspace/authority/orcid/Orcidv2AuthorityValue.java
@@ -0,0 +1,355 @@
+/*
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.authority.orcid;
+
+import java.util.*;
+
+import org.apache.commons.codec.digest.DigestUtils;
+import org.apache.commons.lang.ObjectUtils;
+import org.apache.commons.lang.StringUtils;
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.SolrInputDocument;
+import org.dspace.authority.AuthorityValue;
+import org.dspace.authority.AuthorityValueGenerator;
+import org.dspace.authority.PersonAuthorityValue;
+import org.dspace.utils.DSpace;
+import org.orcid.jaxb.model.common_v2.ExternalId;
+import org.orcid.jaxb.model.record_v2.ExternalIdentifiers;
+import org.orcid.jaxb.model.record_v2.KeywordType;
+import org.orcid.jaxb.model.record_v2.NameType;
+import org.orcid.jaxb.model.record_v2.Person;
+import org.orcid.jaxb.model.record_v2.ResearcherUrlType;
+
+/**
+ * @author Jonas Van Goolen (jonas at atmire dot com)
+ */
+public class Orcidv2AuthorityValue extends PersonAuthorityValue {
+
+    /*
+     * The ORCID identifier
+     */
+    private String orcid_id;
+
+    /*
+     * Map containing key-value pairs filled in by "setValues(Person person)".
+     * This represents all dynamic information of the object.
+     */
+    private Map<String, List<String>> otherMetadata = new HashMap<String, List<String>>();
+
+    /**
+     * The syntax that the ORCID id needs to conform to
+     */
+    public static final String ORCID_ID_SYNTAX = "\\d{4}-\\d{4}-\\d{4}-(\\d{3}X|\\d{4})";
+
+    @Override
+    public String getId() {
+        // A PersonValue is considered unique with the first & last name.
+        String nonDigestedIdentifier;
+        if(StringUtils.isNotBlank(getFirstName())) {
+            nonDigestedIdentifier = Orcidv2AuthorityValue.class.toString() + "field: Person " + "lastName: " + getLastName() + ", firstName: " + getFirstName()+ ", OrcidIdentifier: " + getOrcid_id();
+        }
+        else {
+            nonDigestedIdentifier = Orcidv2AuthorityValue.class.toString() + "field: Person " + "lastName: " + getLastName()+", OrcidIdentifier: " + getOrcid_id() ;
+        }
+        // We return an md5 digest of the toString, this will ensure a unique identifier for the same value each time
+        return DigestUtils.md5Hex(nonDigestedIdentifier);
+    }
+
+    /**
+     * Creates an instance of Orcidv2AuthorityValue with only uninitialized fields.
+     * This is meant to be filled in with values from an existing record.
+     * To create a brand new Orcidv2AuthorityValue, use create()
+     */
+    public Orcidv2AuthorityValue() {
+    }
+
+    public Orcidv2AuthorityValue(SolrDocument document) {
+        super(document);
+    }
+
+
+    public String getOrcid_id() {
+        return orcid_id;
+    }
+
+    public void setOrcid_id(String orcid_id) {
+        this.orcid_id = orcid_id;
+    }
+
+    /**
+     * Create an empty authority.
+     * @return OrcidAuthorityValue
+     */
+    public static Orcidv2AuthorityValue create() {
+        Orcidv2AuthorityValue orcidAuthorityValue = new Orcidv2AuthorityValue();
+        orcidAuthorityValue.setId(UUID.randomUUID().toString());
+        orcidAuthorityValue.updateLastModifiedDate();
+        orcidAuthorityValue.setCreationDate(new Date());
+        return orcidAuthorityValue;
+    }
+
+    /**
+     * Create an authority based on a given orcid bio
+     * @return OrcidAuthorityValue
+     */
+    public static Orcidv2AuthorityValue create(Person person) {
+        if (person == null) {
+            return null;
+        }
+        Orcidv2AuthorityValue authority = Orcidv2AuthorityValue.create();
+
+        authority.setValues(person);
+
+        return authority;
+    }
+
+    /**
+     * Initialize this instance based on a Person object
+     * @param person Person
+     */
+    protected void setValues(Person person) {
+        NameType name = person.getName();
+
+        if (!StringUtils.equals(name.getPath(), this.getOrcid_id())) {
+            this.setOrcid_id(name.getPath());
+        }
+
+        if (!StringUtils.equals(name.getFamilyName().getValue(), this.getLastName())) {
+            this.setLastName(name.getFamilyName().getValue());
+        }
+
+        if (!StringUtils.equals(name.getGivenNames().getValue(), this.getFirstName())) {
+            this.setFirstName(name.getGivenNames().getValue());
+        }
+
+        if (name.getCreditName() != null && StringUtils.isNotBlank(name.getCreditName().getValue())) {
+            if (!this.getNameVariants().contains(name.getCreditName())) {
+                this.addNameVariant(name.getCreditName().getValue());
+            }
+        }
+
+        if (person.getKeywords() != null) {
+            for (KeywordType keyword : person.getKeywords().getKeyword()) {
+                if (this.isNewMetadata("keyword", keyword.getContent())) {
+                    this.addOtherMetadata("keyword", keyword.getContent());
+                }
+            }
+        }
+
+        ExternalIdentifiers externalIdentifiers = person.getExternalIdentifiers();
+        if (externalIdentifiers != null) {
+            for (ExternalId externalIdentifier : externalIdentifiers.getExternalIdentifier()) {
+                if (this.isNewMetadata("external_identifier", externalIdentifier.getExternalIdValue())) {
+                    this.addOtherMetadata("external_identifier", externalIdentifier.getExternalIdValue());
+
+                }
+            }
+        }
+        if (person.getResearcherUrls() != null) {
+            for (ResearcherUrlType researcherUrl : person.getResearcherUrls().getResearcherUrl()) {
+                if (this.isNewMetadata("researcher_url", researcherUrl.getUrl().getValue())) {
+                    this.addOtherMetadata("researcher_url", researcherUrl.getUrl().getValue());
+                }
+            }
+
+        }
+        if (person.getBiography() != null) {
+            if (this.isNewMetadata("biography", person.getBiography().getContent())) {
+                this.addOtherMetadata("biography", person.getBiography().getContent());
+            }
+        }
+
+        this.setValue(this.getName());
+
+    }
+
+    /**
+     * Makes an instance of the AuthorityValue with the given information.
+     * @param info string info
+     * @return AuthorityValue
+     */
+    @Override
+    public AuthorityValue newInstance(String info) {
+        AuthorityValue authorityValue = null;
+        if (StringUtils.isNotBlank(info)) {
+            Orcidv2 orcid = new DSpace().getServiceManager().getServiceByName("AuthoritySource", Orcidv2.class);
+            authorityValue = orcid.queryAuthorityID(info);
+        } else {
+            authorityValue = this.create();
+        }
+        return authorityValue;
+    }
+
+    @Override
+    public void setValue(String value) {
+        super.setValue(value);
+    }
+
+    /**
+     * Check to see if the provided label / data pair is already present in the "otherMetadata" or not
+     * */
+    public boolean isNewMetadata(String label, String data) {
+        List<String> strings = getOtherMetadata().get(label);
+        boolean update;
+        if (strings == null) {
+            update = StringUtils.isNotBlank(data);
+        } else {
+            update = !strings.contains(data);
+        }
+        return update;
+    }
+
+    /**
+     * Add additional metadata to the otherMetadata map*/
+    public void addOtherMetadata(String label, String data) {
+        List<String> strings = otherMetadata.get(label);
+        if (strings == null) {
+            strings = new ArrayList<>();
+        }
+        strings.add(data);
+        otherMetadata.put(label, strings);
+    }
+
+    public Map<String, List<String>> getOtherMetadata() {
+        return otherMetadata;
+    }
+
+
+    /**
+     * Generate a solr record from this instance
+     * @return SolrInputDocument
+     */
+    @Override
+    public SolrInputDocument getSolrInputDocument() {
+        SolrInputDocument doc = super.getSolrInputDocument();
+        if (StringUtils.isNotBlank(getOrcid_id())) {
+            doc.addField("orcid_id", getOrcid_id());
+        }
+
+        for (String t : otherMetadata.keySet()) {
+            List<String> data = otherMetadata.get(t);
+            for (String data_entry : data) {
+                doc.addField("label_" + t, data_entry);
+            }
+        }
+        return doc;
+    }
+
+    @Override
+    public void setValues(SolrDocument document) {
+        super.setValues(document);
+        this.setOrcid_id(document.getFieldValue("orcid_id").toString());
+    }
+
+    /**
+     * Information that can be used the choice ui
+     * @return map
+     */
+    @Override
+    public Map<String, String> choiceSelectMap() {
+
+        Map<String, String> map = super.choiceSelectMap();
+
+        String orcid_id = getOrcid_id();
+        if (StringUtils.isNotBlank(orcid_id)) {
+            map.put("orcid", orcid_id);
+        }
+
+        return map;
+    }
+
+    @Override
+    public String getAuthorityType() {
+        return "orcid";
+    }
+
+    /**
+     * Provides a string that will allow this AuthorityType to be recognized and provides information to create a new instance to be created using public Orcidv2AuthorityValue newInstance(String info).
+     * @return see {@link AuthorityValueGenerator#GENERATE AuthorityValueGenerator.GENERATE}
+     */
+    @Override
+    public String generateString() {
+        String generateString = AuthorityValueGenerator.GENERATE + getAuthorityType() + AuthorityValueGenerator.SPLIT;
+        if (StringUtils.isNotBlank(getOrcid_id())) {
+            generateString += getOrcid_id();
+        }
+        return generateString;
+    }
+
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+
+        Orcidv2AuthorityValue that = (Orcidv2AuthorityValue) o;
+
+        if (orcid_id != null ? !orcid_id.equals(that.orcid_id) : that.orcid_id != null) {
+            return false;
+        }
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        return orcid_id != null ? orcid_id.hashCode() : 0;
+    }
+
+    /**
+     * The regular equals() only checks if both AuthorityValues describe the same authority.
+     * This method checks if the AuthorityValues have different information
+     * E.g. it is used to decide when lastModified should be updated.
+     * @param o object
+     * @return true or false
+     */
+    @Override
+    public boolean hasTheSameInformationAs(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+        if (!super.hasTheSameInformationAs(o)) {
+            return false;
+        }
+
+        Orcidv2AuthorityValue that = (Orcidv2AuthorityValue) o;
+
+        if (orcid_id != null ? !orcid_id.equals(that.orcid_id) : that.orcid_id != null) {
+            return false;
+        }
+
+        for (String key : otherMetadata.keySet()) {
+            if (otherMetadata.get(key) != null) {
+                List<String> metadata = otherMetadata.get(key);
+                List<String> otherMetadata = that.otherMetadata.get(key);
+                if (otherMetadata == null) {
+                    return false;
+                } else {
+                    HashSet<String> metadataSet = new HashSet<String>(metadata);
+                    HashSet<String> otherMetadataSet = new HashSet<String>(otherMetadata);
+                    if (!metadataSet.equals(otherMetadataSet)) {
+                        return false;
+                    }
+                }
+            } else {
+                if (that.otherMetadata.get(key) != null) {
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+}
diff --git a/dspace/modules/pom.xml b/dspace/modules/pom.xml
index b19a282a2a487cd72535712b477a5e7eefd4b7e0..9640fab5cfd6fbeb91f2f15e3d87cf4c8356ff4a 100644
--- a/dspace/modules/pom.xml
+++ b/dspace/modules/pom.xml
@@ -10,7 +10,7 @@
 		<groupId>org.dspace</groupId>
 		<artifactId>dspace-parent</artifactId>
 		<version>5.10</version>
-		<relativePath>../../../../../Downloads/dspace-5.10-release/pom.xml</relativePath>
+		<relativePath>..</relativePath>
 	</parent>
 
     <properties>
diff --git a/dspace/modules/rest/src/main/java/org/dspace/rest/AuthoritiesResource.java b/dspace/modules/rest/src/main/java/org/dspace/rest/AuthoritiesResource.java
new file mode 100644
index 0000000000000000000000000000000000000000..c602232bdffb4cdf04dac5dea62f9510b5277340
--- /dev/null
+++ b/dspace/modules/rest/src/main/java/org/dspace/rest/AuthoritiesResource.java
@@ -0,0 +1,124 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ * <p>
+ * http://www.dspace.org/license/
+ */
+package org.dspace.rest;
+
+import org.apache.log4j.Logger;
+import org.apache.solr.client.solrj.SolrServerException;
+import org.dspace.authority.AuthorityUtil;
+import org.dspace.authority.AuthorityValue;
+import org.dspace.authority.AuthorityValueFinder;
+import org.dspace.authority.PersonAuthorityValue;
+import org.dspace.authority.indexer.AuthorityIndexingService;
+import org.dspace.authority.orcid.Orcidv2AuthorityValue;
+import org.dspace.content.Item;
+import org.dspace.content.ItemIterator;
+import org.dspace.discovery.IndexingService;
+import org.dspace.discovery.SearchServiceException;
+import org.dspace.rest.exceptions.ContextException;
+import org.dspace.storage.rdbms.DatabaseManager;
+import org.dspace.utils.DSpace;
+
+import javax.servlet.http.HttpServletRequest;
+import javax.ws.rs.*;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.Response;
+import java.io.IOException;
+import java.sql.SQLException;
+
+import static javax.ws.rs.core.MediaType.TEXT_PLAIN;
+import static javax.ws.rs.core.Response.Status.BAD_REQUEST;
+import static javax.ws.rs.core.Response.Status.OK;
+import static javax.ws.rs.core.Response.Status.UNAUTHORIZED;
+import static javax.ws.rs.core.Response.status;
+import static org.dspace.authority.AuthorityValueGenerator.update;
+import static org.dspace.authorize.AuthorizeManager.isAdmin;
+import static org.dspace.core.ConfigurationManager.getBooleanProperty;
+
+@SuppressWarnings("deprecation")
+@Path("/authorities")
+public class AuthoritiesResource extends Resource {
+
+    private static final Logger log = Logger.getLogger(AuthoritiesResource.class);
+
+    private static final AuthorityIndexingService authorityIndexingService = new DSpace().getSingletonService(AuthorityIndexingService.class);
+    private static final IndexingService indexingService = new DSpace().getSingletonService(IndexingService.class);
+
+    @PUT
+    @Path("/{authority_id}/value")
+    @Consumes(TEXT_PLAIN)
+    public Response updateAuthorityValue(@PathParam("authority_id") String authorityId, String value,
+                                         @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+                                         @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException {
+
+        if (!getBooleanProperty("authority.allow-rest-updates.person", true)) {
+            throw new WebApplicationException(BAD_REQUEST);
+        }
+
+        log.info("Updating value of authority (id: " + authorityId + ") to " + value + ".");
+
+        org.dspace.core.Context context = null;
+        try {
+            context = createContext(getUser(headers));
+
+            if (!isAdmin(context)) {
+                context.abort();
+                throw new WebApplicationException(UNAUTHORIZED);
+            }
+
+            AuthorityValue authorityValue = new AuthorityValueFinder().findByUID(context, authorityId);
+
+            if (!(authorityValue instanceof PersonAuthorityValue)) {
+                context.abort();
+                throw new IllegalArgumentException("Provided authority is not a person. Only person authorities can be updated.");
+            }
+
+            authorityValue.setValue(value);
+
+            if (!(authorityValue instanceof Orcidv2AuthorityValue)) {
+                authorityValue = update(authorityValue);
+            } else if (!getBooleanProperty("authority.allow-rest-updates.orcid", true)) {
+                throw new WebApplicationException(BAD_REQUEST);
+            }
+
+            authorityIndexingService.indexContent(authorityValue, true);
+            new AuthorityUtil().deleteAuthorityValueById(authorityId);
+
+            log.info("Deleted authority with id: " + authorityId + " and added authority with id: " + authorityValue.getId());
+
+            authorityIndexingService.commit();
+
+            DatabaseManager.updateQuery(context, "UPDATE metadatavalue SET text_value = ?, authority = ? WHERE authority = ?", value, authorityValue.getId(), authorityId);
+            context.commit();
+            log.info("Updated authority metadata values.");
+
+            ItemIterator itemIterator = new AuthorityUtil().findItemsByAuthorityValue(context, authorityValue.getId());
+            while (itemIterator.hasNext()) {
+                Item item = itemIterator.next();
+                indexingService.indexContent(context, item, true);
+                item.decache();
+            }
+            indexingService.commit();
+            log.info("Updated discovery index.");
+
+            context.complete();
+
+        } catch (IllegalArgumentException | SQLException | SearchServiceException | IOException | SolrServerException | ContextException e) {
+            processException(
+                    "Could not update value of authority (id: " + authorityId + "). Message: " + e.getMessage(), context
+            );
+        } finally {
+            processFinally(context);
+        }
+
+        log.info("Value of authority (id: " + authorityId + ") was successfully updated.");
+
+        return status(OK).build();
+    }
+}
diff --git a/dspace/modules/rest/src/main/java/org/dspace/rest/CollectionsResource.java b/dspace/modules/rest/src/main/java/org/dspace/rest/CollectionsResource.java
new file mode 100644
index 0000000000000000000000000000000000000000..a4115eba28482c38a8c903d6f9f994a6eecaa7d2
--- /dev/null
+++ b/dspace/modules/rest/src/main/java/org/dspace/rest/CollectionsResource.java
@@ -0,0 +1,770 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.rest;
+
+import org.dspace.authority.AuthorityUtil;
+import org.apache.log4j.Logger;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.authorize.AuthorizeManager;
+import org.dspace.content.WorkspaceItem;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.ConfigurationManager;
+import org.dspace.core.LogManager;
+import org.dspace.rest.common.Collection;
+import org.dspace.rest.common.Item;
+import org.dspace.rest.common.MetadataEntry;
+import org.dspace.rest.exceptions.ContextException;
+import org.dspace.usage.UsageEvent;
+import org.dspace.workflow.WorkflowManager;
+import org.dspace.xmlworkflow.XmlWorkflowManager;
+
+import javax.servlet.http.HttpServletRequest;
+import javax.ws.rs.*;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import java.io.IOException;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * This class provides all CRUD operation over collections.
+ * 
+ * @author Rostislav Novak (Computing and Information Centre, CTU in Prague)
+ * @author Adán Román Ruiz (arvo.es)
+ */
+@Path("/collections")
+public class CollectionsResource extends Resource
+{
+    private static Logger log = Logger.getLogger(CollectionsResource.class);
+
+    /**
+     * Return instance of collection with passed id. You can add more properties
+     * through expand parameter.
+     * 
+     * @param collectionId
+     *            Id of collection in DSpace.
+     * @param expand
+     *            String in which is what you want to add to returned instance
+     *            of collection. Options are: "all", "parentCommunityList",
+     *            "parentCommunity", "items", "license" and "logo". If you want
+     *            to use multiple options, it must be separated by commas.
+     * @param limit
+     *            Limit value for items in list in collection. Default value is
+     *            100.
+     * @param offset
+     *            Offset of start index in list of items of collection. Default
+     *            value is 0.
+     * @param headers
+     *            If you want to access to collection under logged user into
+     *            context. In headers must be set header "rest-dspace-token"
+     *            with passed token from login method.
+     * @return Return instance of collection. It can also return status code
+     *         NOT_FOUND(404) if id of collection is incorrect or status code
+     *         UNATHORIZED(401) if user has no permission to read collection.
+     * @throws WebApplicationException
+     *             It is thrown when was problem with database reading
+     *             (SQLException) or problem with creating
+     *             context(ContextException). It is thrown by NOT_FOUND and
+     *             UNATHORIZED status codes, too.
+     */
+    @GET
+    @Path("/{collection_id}")
+    @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Collection getCollection(@PathParam("collection_id") Integer collectionId,
+            @QueryParam("expand") String expand, @QueryParam("limit") @DefaultValue("100") Integer limit,
+            @QueryParam("offset") @DefaultValue("0") Integer offset, @QueryParam("userIP") String user_ip,
+            @QueryParam("userAgent") String user_agent, @QueryParam("xforwardedfor") String xforwardedfor,
+            @Context HttpHeaders headers, @Context HttpServletRequest request) throws WebApplicationException
+    {
+
+        log.info("Reading collection(id=" + collectionId + ").");
+        org.dspace.core.Context context = null;
+        Collection collection = null;
+
+        try
+        {
+            context = createContext(getUser(headers));
+
+            org.dspace.content.Collection dspaceCollection = findCollection(context, collectionId, org.dspace.core.Constants.READ);
+            writeStats(dspaceCollection, UsageEvent.Action.VIEW, user_ip, user_agent, xforwardedfor,
+                    headers, request, context);
+
+            collection = new Collection(dspaceCollection, expand, context, limit, offset);
+            context.complete();
+
+        }
+        catch (SQLException e)
+        {
+            processException("Could not read collection(id=" + collectionId + "), SQLException. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Could not read collection(id=" + collectionId + "), ContextException. Message: " + e.getMessage(),
+                    context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.trace("Collection(id=" + collectionId + ") has been successfully read.");
+        return collection;
+    }
+
+    /**
+     * Return array of all collections in DSpace. You can add more properties
+     * through expand parameter.
+     *
+     * @param expand
+     *            String in which is what you want to add to returned instance
+     *            of collection. Options are: "all", "parentCommunityList",
+     *            "parentCommunity", "items", "license" and "logo". If you want
+     *            to use multiple options, it must be separated by commas.
+     * @param limit
+     *            Limit value for items in list in collection. Default value is
+     *            100.
+     * @param offset
+     *            Offset of start index in list of items of collection. Default
+     *            value is 0.
+     * @param headers
+     *            If you want to access to collections under logged user into
+     *            context. In headers must be set header "rest-dspace-token"
+     *            with passed token from login method.
+     * @return Return array of collection, on which has logged user permission
+     *         to view.
+     * @throws WebApplicationException
+     *             It is thrown when was problem with database reading
+     *             (SQLException) or problem with creating
+     *             context(ContextException).
+     */
+    @GET
+    @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Collection[] getCollections(@QueryParam("expand") String expand,
+            @QueryParam("limit") @DefaultValue("100") Integer limit, @QueryParam("offset") @DefaultValue("0") Integer offset,
+            @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Reading all collections.(offset=" + offset + ",limit=" + limit + ")");
+        org.dspace.core.Context context = null;
+        List<Collection> collections = new ArrayList<Collection>();
+
+        try
+        {
+            context = createContext(getUser(headers));
+
+            if (!((limit != null) && (limit >= 0) && (offset != null) && (offset >= 0)))
+            {
+                log.warn("Paging was badly set.");
+                limit = 100;
+                offset = 0;
+            }
+
+            org.dspace.content.Collection[] dspaceCollections = org.dspace.content.Collection.findAll(context, limit, offset);
+            for(org.dspace.content.Collection dspaceCollection : dspaceCollections)
+            {
+                if (AuthorizeManager.authorizeActionBoolean(context, dspaceCollection, org.dspace.core.Constants.READ))
+                {
+                    Collection collection = new Collection(dspaceCollection, null, context, limit,
+                            offset);
+                    collections.add(collection);
+                    writeStats(dspaceCollection, UsageEvent.Action.VIEW, user_ip, user_agent,
+                            xforwardedfor, headers, request, context);
+                }
+            }
+            context.complete();
+        }
+        catch (SQLException e)
+        {
+            processException("Something went wrong while reading collections from database. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Something went wrong while reading collections, ContextError. Message: " + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.trace("All collections were successfully read.");
+        return collections.toArray(new Collection[0]);
+    }
+
+    /**
+     * Return array of items in collection. You can add more properties to items
+     * with expand parameter.
+     *
+     * @param collectionId
+     *            Id of collection in DSpace.
+     * @param expand
+     *            String which define, what additional properties will be in
+     *            returned item. Options are separeted by commas and are: "all",
+     *            "metadata", "parentCollection", "parentCollectionList",
+     *            "parentCommunityList" and "bitstreams".
+     * @param limit
+     *            Limit value for items in array. Default value is 100.
+     * @param offset
+     *            Offset of start index in array of items of collection. Default
+     *            value is 0.
+     * @param headers
+     *            If you want to access to collection under logged user into
+     *            context. In headers must be set header "rest-dspace-token"
+     *            with passed token from login method.
+     * @return Return array of items, on which has logged user permission to
+     *         read. It can also return status code NOT_FOUND(404) if id of
+     *         collection is incorrect or status code UNATHORIZED(401) if user
+     *         has no permission to read collection.
+     * @throws WebApplicationException
+     *             It is thrown when was problem with database reading
+     *             (SQLException) or problem with creating
+     *             context(ContextException). It is thrown by NOT_FOUND and
+     *             UNATHORIZED status codes, too.
+     */
+    @GET
+    @Path("/{collection_id}/items")
+    @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Item[] getCollectionItems(@PathParam("collection_id") Integer collectionId,
+            @QueryParam("expand") String expand, @QueryParam("limit") @DefaultValue("100") Integer limit,
+            @QueryParam("offset") @DefaultValue("0") Integer offset, @QueryParam("userIP") String user_ip,
+            @QueryParam("userAgent") String user_agent, @QueryParam("xforwardedfor") String xforwardedfor,
+            @Context HttpHeaders headers, @Context HttpServletRequest request) throws WebApplicationException
+    {
+
+        log.info("Reading collection(id=" + collectionId + ") items.");
+        org.dspace.core.Context context = null;
+        List<Item> items = null;
+
+        try
+        {
+            context = createContext(getUser(headers));
+
+            org.dspace.content.Collection dspaceCollection = findCollection(context, collectionId, org.dspace.core.Constants.READ);
+            writeStats(dspaceCollection, UsageEvent.Action.VIEW, user_ip, user_agent, xforwardedfor,
+                    headers, request, context);
+
+            items = new ArrayList<Item>();
+            org.dspace.content.ItemIterator dspaceItems = dspaceCollection.getItems();
+            for (int i = 0; (dspaceItems.hasNext()) && (i < (limit + offset)); i++)
+            {
+                if (i >= offset)
+                {
+                    org.dspace.content.Item dspaceItem = dspaceItems.next();
+                    if (ItemService.isItemListedForUser(context, dspaceItem))
+                    {
+                        items.add(new Item(dspaceItem, expand, context));
+                        writeStats(dspaceItem, UsageEvent.Action.VIEW, user_ip, user_agent, xforwardedfor,
+                                headers, request, context);
+                    }
+                } else {
+                    //Advance the iterator to offset.
+                    dspaceItems.nextID();
+                }
+            }
+
+            context.complete();
+        }
+        catch (SQLException e)
+        {
+            processException("Could not read collection items, SQLException. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Could not read collection items, ContextException. Message: " + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.trace("All items in collection(id=" + collectionId + ") were successfully read.");
+        return items.toArray(new Item[0]);
+    }
+
+    /**
+     * Create item in collection. Item can be without filled metadata.
+     *
+     * @param collectionId
+     *            Id of collection in which will be item created.
+     * @param item
+     *            Item filled only with metadata, other variables are ignored.
+     * @param headers
+     *            If you want to access to collection under logged user into
+     *            context. In headers must be set header "rest-dspace-token"
+     *            with passed token from login method.
+     * @return Return status code with item. Return status (OK)200 if item was
+     *         created. NOT_FOUND(404) if id of collection does not exists.
+     *         UNAUTHORIZED(401) if user have not permission to write items in
+     *         collection.
+     * @throws WebApplicationException
+     *             It is thrown when was problem with database reading or
+     *             writing (SQLException) or problem with creating
+     *             context(ContextException) or problem with authorization to
+     *             collection or IOException or problem with index item into
+     *             browse index. It is thrown by NOT_FOUND and UNATHORIZED
+     *             status codes, too.
+     *
+     */
+    @POST
+    @Path("/{collection_id}/items")
+    @Consumes({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Item addCollectionItem(@PathParam("collection_id") Integer collectionId, Item item,
+            @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Create item in collection(id=" + collectionId + ").");
+        org.dspace.core.Context context = null;
+        Item returnItem = null;
+
+        try
+        {
+            context = createContext(getUser(headers));
+            org.dspace.content.Collection dspaceCollection = findCollection(context, collectionId,
+                    org.dspace.core.Constants.WRITE);
+
+            writeStats(dspaceCollection, UsageEvent.Action.UPDATE, user_ip, user_agent, xforwardedfor,
+                    headers, request, context);
+
+            log.trace("Creating item in collection(id=" + collectionId + ").");
+            WorkspaceItem workspaceItem = WorkspaceItem.create(context, dspaceCollection,
+                    false);
+            org.dspace.content.Item dspaceItem = workspaceItem.getItem();
+
+            log.trace("Adding metadata to item(id=" + dspaceItem.getID() + ").");
+            if (item.getMetadata() != null)
+            {
+                for (MetadataEntry entry : item.getMetadata())
+                {
+                    String data[] = mySplit(entry.getKey());
+                    new AuthorityUtil().addMetadata(context, dspaceItem, data, entry.getValue(), entry.getLanguage());
+                }
+            }
+            workspaceItem.update();
+
+            // Must insert the item into workflow
+            if(ConfigurationManager.getProperty("workflow","workflow.framework").equals("xmlworkflow")){
+                try{
+                    XmlWorkflowManager.start(context, workspaceItem);
+                }catch (Exception e){
+                    log.error(LogManager.getHeader(context, "Error while starting xml workflow", "Item id: " + dspaceItem.getID()), e);
+                    throw new ContextException("Error while starting xml workflow: Item id: " + dspaceItem.getID(),e);
+                }
+            }else{
+                WorkflowManager.start(context, (WorkspaceItem )workspaceItem);
+            }
+            returnItem=new Item(workspaceItem.getItem(),"",context);
+
+            context.complete();
+
+        }
+        catch (SQLException e)
+        {
+            processException("Could not add item into collection(id=" + collectionId + "), SQLException. Message: " + e, context);
+        }
+        catch (AuthorizeException e)
+        {
+            processException("Could not add item into collection(id=" + collectionId + "), AuthorizeException. Message: " + e,
+                    context);
+        }
+        catch (IOException e)
+        {
+            processException("Could not add item into collection(id=" + collectionId + "), IOException. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException(
+                    "Could not add item into collection(id=" + collectionId + "), ContextException. Message: " + e.getMessage(),
+                    context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.info("Item successfully created in collection(id=" + collectionId + "). Item handle=" + returnItem.getHandle());
+        return returnItem;
+    }
+
+    /**
+     * Update collection. It replace all properties.
+     *
+     * @param collectionId
+     *            Id of collection in DSpace.
+     * @param collection
+     *            Collection which will replace properties of actual collection.
+     * @param headers
+     *            If you want to access to collection under logged user into
+     *            context. In headers must be set header "rest-dspace-token"
+     *            with passed token from login method.
+     * @return Return response 200 if was everything all right. Otherwise 400
+     *         when id of community was incorrect or 401 if was problem with
+     *         permission to write into collection.
+     * @throws WebApplicationException
+     *             It is thrown when was problem with database reading or
+     *             writing. Or problem with authorization to collection. Or
+     *             problem with creating context.
+     */
+    @PUT
+    @Path("/{collection_id}")
+    @Consumes({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Response updateCollection(@PathParam("collection_id") Integer collectionId,
+            Collection collection, @QueryParam("userIP") String user_ip,
+            @QueryParam("userAgent") String user_agent, @QueryParam("xforwardedfor") String xforwardedfor,
+            @Context HttpHeaders headers, @Context HttpServletRequest request) throws WebApplicationException
+    {
+
+        log.info("Updating collection(id=" + collectionId + ").");
+        org.dspace.core.Context context = null;
+
+        try
+        {
+            context = createContext(getUser(headers));
+            org.dspace.content.Collection dspaceCollection = findCollection(context, collectionId,
+                    org.dspace.core.Constants.WRITE);
+
+            writeStats(dspaceCollection, UsageEvent.Action.UPDATE, user_ip, user_agent, xforwardedfor,
+                    headers, request, context);
+
+            dspaceCollection.setMetadata("name", collection.getName());
+            dspaceCollection.setLicense(collection.getLicense());
+            // dspaceCollection.setLogo(collection.getLogo()); // TODO Add this option.
+            dspaceCollection.setMetadata(org.dspace.content.Collection.COPYRIGHT_TEXT, collection.getCopyrightText());
+            dspaceCollection.setMetadata(org.dspace.content.Collection.INTRODUCTORY_TEXT, collection.getIntroductoryText());
+            dspaceCollection.setMetadata(org.dspace.content.Collection.SHORT_DESCRIPTION, collection.getShortDescription());
+            dspaceCollection.setMetadata(org.dspace.content.Collection.SIDEBAR_TEXT, collection.getSidebarText());
+            dspaceCollection.update();
+
+            context.complete();
+
+        }
+        catch (ContextException e)
+        {
+            processException("Could not update collection(id=" + collectionId + "), ContextException. Message: " + e.getMessage(),
+                    context);
+        }
+        catch (SQLException e)
+        {
+            processException("Could not update collection(id=" + collectionId + "), SQLException. Message: " + e, context);
+        }
+        catch (AuthorizeException e)
+        {
+            processException("Could not update collection(id=" + collectionId + "), AuthorizeException. Message: " + e, context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.info("Collection(id=" + collectionId + ") successfully updated.");
+        return Response.ok().build();
+    }
+
+    /**
+     * Delete collection.
+     *
+     * @param collectionId
+     *            Id of collection which will be deleted.
+     * @param headers
+     *            If you want to access to collection under logged user into
+     *            context. In headers must be set header "rest-dspace-token"
+     *            with passed token from login method.
+     * @return Return response code OK(200) if was everything all right.
+     *         Otherwise return NOT_FOUND(404) if was id of community or
+     *         collection incorrect. Or (UNAUTHORIZED)401 if was problem with
+     *         permission to community or collection.
+     * @throws WebApplicationException
+     *             It is throw when was problem with creating context or problem
+     *             with database reading or writing. Or problem with deleting
+     *             collection caused by IOException or authorization.
+     */
+    @DELETE
+    @Path("/{collection_id}")
+    @Consumes({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Response deleteCollection(@PathParam("collection_id") Integer collectionId, @QueryParam("userIP") String user_ip,
+            @QueryParam("userAgent") String user_agent, @QueryParam("xforwardedfor") String xforwardedfor,
+            @Context HttpHeaders headers, @Context HttpServletRequest request) throws WebApplicationException
+    {
+
+        log.info("Delete collection(id=" + collectionId + ").");
+        org.dspace.core.Context context = null;
+
+        try
+        {
+            context = createContext(getUser(headers));
+            org.dspace.content.Collection dspaceCollection = findCollection(context, collectionId,
+                    org.dspace.core.Constants.DELETE);
+
+            writeStats(dspaceCollection, UsageEvent.Action.REMOVE, user_ip, user_agent, xforwardedfor,
+                    headers, request, context);
+
+            org.dspace.content.Community community = (org.dspace.content.Community) dspaceCollection.getParentObject();
+            community.removeCollection(dspaceCollection);
+
+            context.complete();
+
+        }
+        catch (ContextException e)
+        {
+            processException(
+                    "Could not delete collection(id=" + collectionId + "), ContextExcpetion. Message: " + e.getMessage(), context);
+        }
+        catch (SQLException e)
+        {
+            processException("Could not delete collection(id=" + collectionId + "), SQLException. Message: " + e, context);
+        }
+        catch (AuthorizeException e)
+        {
+            processException("Could not delete collection(id=" + collectionId + "), AuthorizeException. Message: " + e, context);
+        }
+        catch (IOException e)
+        {
+            processException("Could not delete collection(id=" + collectionId + "), IOException. Message: " + e, context);
+        }
+        finally {
+            processFinally(context);
+        }
+
+        log.info("Collection(id=" + collectionId + ") was successfully deleted.");
+        return Response.ok().build();
+    }
+
+    /**
+     * Delete item in collection.
+     *
+     * @param collectionId
+     *            Id of collection which will be deleted.
+     *
+     * @param itemId
+     *            Id of item in colletion.
+     * @return It returns status code: OK(200). NOT_FOUND(404) if item or
+     *         collection was not found, UNAUTHORIZED(401) if user is not
+     *         allowed to delete item or permission to write into collection.
+     * @throws WebApplicationException
+     *             It can be thrown by: SQLException, when was problem with
+     *             database reading or writting. AuthorizeException, when was
+     *             problem with authorization to item or collection.
+     *             IOException, when was problem with removing item.
+     *             ContextException, when was problem with creating context of
+     *             DSpace.
+     */
+    @DELETE
+    @Path("/{collection_id}/items/{item_id}")
+    @Consumes({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Response deleteCollectionItem(@PathParam("collection_id") Integer collectionId, @PathParam("item_id") Integer itemId,
+            @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Delete item(id=" + itemId + ") in collection(id=" + collectionId + ").");
+        org.dspace.core.Context context = null;
+
+        try
+        {
+            context = createContext(getUser(headers));
+            org.dspace.content.Collection dspaceCollection = findCollection(context, collectionId,
+                    org.dspace.core.Constants.WRITE);
+
+            org.dspace.content.Item item = null;
+            org.dspace.content.ItemIterator dspaceItems = dspaceCollection.getItems();
+            while (dspaceItems.hasNext())
+            {
+                org.dspace.content.Item dspaceItem = dspaceItems.next();
+                if (dspaceItem.getID() == itemId)
+                {
+                    item = dspaceItem;
+                }
+            }
+
+            if (item == null)
+            {
+                context.abort();
+                log.warn("Item(id=" + itemId + ") was not found!");
+                throw new WebApplicationException(Response.Status.NOT_FOUND);
+            }
+            else if (!AuthorizeManager.authorizeActionBoolean(context, item, org.dspace.core.Constants.REMOVE))
+            {
+                context.abort();
+                if (context.getCurrentUser() != null)
+                {
+                    log.error("User(" + context.getCurrentUser().getEmail() + ") has not permission to delete item!");
+                }
+                else
+                {
+                    log.error("User(anonymous) has not permission to delete item!");
+                }
+                throw new WebApplicationException(Response.Status.UNAUTHORIZED);
+            }
+
+            writeStats(dspaceCollection, UsageEvent.Action.UPDATE, user_ip, user_agent, xforwardedfor,
+                    headers, request, context);
+            writeStats(item, UsageEvent.Action.REMOVE, user_ip, user_agent, xforwardedfor, headers, request, context);
+
+            dspaceCollection.removeItem(item);
+
+            context.complete();
+
+        }
+        catch (ContextException e)
+        {
+            processException("Could not delete item(id=" + itemId + ") in collection(id=" + collectionId
+                    + "), ContextException. Message: " + e.getMessage(), context);
+        }
+        catch (SQLException e)
+        {
+            processException("Could not delete item(id=" + itemId + ") in collection(id=" + collectionId
+                    + "), SQLException. Message: " + e, context);
+        }
+        catch (AuthorizeException e)
+        {
+            processException("Could not delete item(id=" + itemId + ") in collection(id=" + collectionId
+                    + "), AuthorizeException. Message: " + e, context);
+        }
+        catch (IOException e)
+        {
+            processException("Could not delete item(id=" + itemId + ") in collection(id=" + collectionId
+                    + "), IOException. Message: " + e, context);
+        }
+        finally {
+            processFinally(context);
+        }
+
+        log.info("Item(id=" + itemId + ") in collection(id=" + collectionId + ") was successfully deleted.");
+        return Response.ok().build();
+    }
+
+    /**
+     * Search for first collection with passed name.
+     *
+     * @param name
+     *            Name of collection.
+     * @param headers
+     *            If you want to access to collection under logged user into
+     *            context. In headers must be set header "rest-dspace-token"
+     *            with passed token from login method.
+     * @return It returns null if collection was not found. Otherwise returns
+     *         first founded collection.
+     * @throws WebApplicationException
+     */
+    @POST
+    @Path("/find-collection")
+    @Consumes({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Collection findCollectionByName(String name, @Context HttpHeaders headers) throws WebApplicationException
+    {
+        log.info("Searching for first collection with name=" + name + ".");
+        org.dspace.core.Context context = null;
+        Collection collection = null;
+
+        try
+        {
+            context = createContext(getUser(headers));
+            org.dspace.content.Collection[] dspaceCollections;
+
+            dspaceCollections = org.dspace.content.Collection.findAll(context);
+
+            for (org.dspace.content.Collection dspaceCollection : dspaceCollections)
+            {
+                if (AuthorizeManager.authorizeActionBoolean(context, dspaceCollection, org.dspace.core.Constants.READ))
+                {
+                    if (dspaceCollection.getName().equals(name))
+                    {
+                        collection = new Collection(dspaceCollection, "", context, 100, 0);
+                        break;
+                    }
+                }
+            }
+
+            context.complete();
+
+        }
+        catch (SQLException e)
+        {
+            processException("Something went wrong while searching for collection(name=" + name + ") from database. Message: "
+                    + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Something went wrong while searching for collection(name=" + name + "), ContextError. Message: "
+                    + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        if (collection == null)
+        {
+            log.info("Collection was not found.");
+        }
+        else
+        {
+            log.info("Collection was found with id(" + collection.getId() + ").");
+        }
+        return collection;
+    }
+
+    /**
+     * Find collection from DSpace database. It is encapsulation of method
+     * org.dspace.content.Collection.find with checking if item exist and if
+     * user logged into context has permission to do passed action.
+     * 
+     * @param context
+     *            Context of actual logged user.
+     * @param id
+     *            Id of collection in DSpace.
+     * @param action
+     *            Constant from org.dspace.core.Constants.
+     * @return It returns DSpace collection.
+     * @throws WebApplicationException
+     *             Is thrown when item with passed id is not exists and if user
+     *             has no permission to do passed action.
+     */
+    private org.dspace.content.Collection findCollection(org.dspace.core.Context context, int id, int action)
+            throws WebApplicationException
+    {
+        org.dspace.content.Collection collection = null;
+        try
+        {
+            collection = org.dspace.content.Collection.find(context, id);
+
+            if (collection == null)
+            {
+                context.abort();
+                log.warn("Collection(id=" + id + ") was not found!");
+                throw new WebApplicationException(Response.Status.NOT_FOUND);
+            }
+            else if (!AuthorizeManager.authorizeActionBoolean(context, collection, action))
+            {
+                context.abort();
+                if (context.getCurrentUser() != null)
+                {
+                    log.error("User(" + context.getCurrentUser().getEmail() + ") has not permission to "
+                            + getActionString(action) + " collection!");
+                }
+                else
+                {
+                    log.error("User(anonymous) has not permission to " + getActionString(action) + " collection!");
+                }
+                throw new WebApplicationException(Response.Status.UNAUTHORIZED);
+            }
+
+        }
+        catch (SQLException e)
+        {
+            processException("Something get wrong while finding collection(id=" + id + "). SQLException, Message: " + e, context);
+        }
+        return collection;
+    }
+}
diff --git a/dspace/modules/rest/src/main/java/org/dspace/rest/ItemsResource.java b/dspace/modules/rest/src/main/java/org/dspace/rest/ItemsResource.java
new file mode 100644
index 0000000000000000000000000000000000000000..07f248a41524c5f5239a7a67083beb3854dcbca3
--- /dev/null
+++ b/dspace/modules/rest/src/main/java/org/dspace/rest/ItemsResource.java
@@ -0,0 +1,1100 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.rest;
+
+import org.dspace.authority.AuthorityUtil;
+import org.apache.log4j.Logger;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.authorize.AuthorizeManager;
+import org.dspace.content.BitstreamFormat;
+import org.dspace.content.Bundle;
+import org.dspace.content.ItemIterator;
+import org.dspace.content.Metadatum;
+import org.dspace.content.service.ItemService;
+import org.dspace.eperson.Group;
+import org.dspace.rest.common.Bitstream;
+import org.dspace.rest.common.Item;
+import org.dspace.rest.common.MetadataEntry;
+import org.dspace.rest.exceptions.ContextException;
+import org.dspace.storage.rdbms.TableRow;
+import org.dspace.storage.rdbms.TableRowIterator;
+import org.dspace.usage.UsageEvent;
+
+import javax.servlet.http.HttpServletRequest;
+import javax.ws.rs.*;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.core.Response.Status;
+import java.io.IOException;
+import java.io.InputStream;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * Class which provide all CRUD methods over items.
+ * 
+ * @author Rostislav Novak (Computing and Information Centre, CTU in Prague)
+ * 
+ */
+// Every DSpace class used without namespace is from package org.dspace.rest.common.*. Otherwise namespace is defined.
+@SuppressWarnings("deprecation")
+@Path("/items")
+public class ItemsResource extends Resource
+{
+
+    private static final Logger log = Logger.getLogger(ItemsResource.class);
+
+    /**
+     * Return item properties without metadata and bitstreams. You can add
+     * additional properties by parameter expand.
+     * 
+     * @param itemId
+     *            Id of item in DSpace.
+     * @param expand
+     *            String which define, what additional properties will be in
+     *            returned item. Options are separeted by commas and are: "all",
+     *            "metadata", "parentCollection", "parentCollectionList",
+     *            "parentCommunityList" and "bitstreams".
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @return If user is allowed to read item, it returns item. Otherwise is
+     *         thrown WebApplicationException with response status
+     *         UNAUTHORIZED(401) or NOT_FOUND(404) if was id incorrect.
+     * @throws WebApplicationException
+     *             This exception can be throw by NOT_FOUND(bad id of item),
+     *             UNAUTHORIZED, SQLException if wasproblem with reading from
+     *             database and ContextException, if there was problem with
+     *             creating context of DSpace.
+     */
+    @GET
+    @Path("/{item_id}")
+    @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Item getItem(@PathParam("item_id") Integer itemId, @QueryParam("expand") String expand,
+            @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Reading item(id=" + itemId + ").");
+        org.dspace.core.Context context = null;
+        Item item = null;
+
+        try
+        {
+            context = createContext(getUser(headers));
+            org.dspace.content.Item dspaceItem = findItem(context, itemId, org.dspace.core.Constants.READ);
+
+            writeStats(dspaceItem, UsageEvent.Action.VIEW, user_ip, user_agent, xforwardedfor, headers, request, context);
+
+            item = new Item(dspaceItem, expand, context);
+            context.complete();
+            log.trace("Item(id=" + itemId + ") was successfully read.");
+
+        }
+        catch (SQLException e)
+        {
+            processException("Could not read item(id=" + itemId + "), SQLException. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Could not read item(id=" + itemId + "), ContextException. Message: " + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        return item;
+    }
+
+    /**
+     * It returns an array of items in DSpace. You can define how many items in
+     * list will be and from which index will start. Items in list are sorted by
+     * handle, not by id.
+     * 
+     * @param limit
+     *            How many items in array will be. Default value is 100.
+     * @param offset
+     *            On which index will array start. Default value is 0.
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @return Return array of items, on which has logged user into context
+     *         permission.
+     * @throws WebApplicationException
+     *             It can be thrown by SQLException, when was problem with
+     *             reading items from database or ContextException, when was
+     *             problem with creating context of DSpace.
+     */
+    @GET
+    @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Item[] getItems(@QueryParam("expand") String expand, @QueryParam("limit") @DefaultValue("100") Integer limit,
+            @QueryParam("offset") @DefaultValue("0") Integer offset, @QueryParam("userIP") String user_ip,
+            @QueryParam("userAgent") String user_agent, @QueryParam("xforwardedfor") String xforwardedfor,
+            @Context HttpHeaders headers, @Context HttpServletRequest request) throws WebApplicationException
+    {
+
+        log.info("Reading items.(offset=" + offset + ",limit=" + limit + ").");
+        org.dspace.core.Context context = null;
+        List<Item> items = null;
+
+        try
+        {
+            context = createContext(getUser(headers));
+
+            ItemIterator dspaceItems = org.dspace.content.Item.findAllUnfiltered(context);
+            items = new ArrayList<Item>();
+
+            if (!((limit != null) && (limit >= 0) && (offset != null) && (offset >= 0)))
+            {
+                log.warn("Pagging was badly set, using default values.");
+                limit = 100;
+                offset = 0;
+            }
+
+            for (int i = 0; (dspaceItems.hasNext()) && (i < (limit + offset)); i++)
+            {
+                org.dspace.content.Item dspaceItem = dspaceItems.next();
+                if (i >= offset)
+                {
+                    if (ItemService.isItemListedForUser(context, dspaceItem))
+                    {
+                        items.add(new Item(dspaceItem, expand, context));
+                        writeStats(dspaceItem, UsageEvent.Action.VIEW, user_ip, user_agent, xforwardedfor,
+                                headers, request, context);
+                    }
+                }
+            }
+            context.complete();
+        }
+        catch (SQLException e)
+        {
+            processException("Something went wrong while reading items from database. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Something went wrong while reading items, ContextException. Message: " + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.trace("Items were successfully read.");
+        return items.toArray(new Item[0]);
+    }
+
+    /**
+     * Returns item metadata in list.
+     * 
+     * @param itemId
+     *            Id of item in DSpace.
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @return Return list of metadata fields if was everything ok. Otherwise it
+     *         throw WebApplication exception with response code NOT_FOUND(404)
+     *         or UNAUTHORIZED(401).
+     * @throws WebApplicationException
+     *             It can be thrown by two exceptions: SQLException if was
+     *             problem wtih reading item from database and ContextException,
+     *             if was problem with creating context of DSpace. And can be
+     *             thrown by NOT_FOUND and UNAUTHORIZED too.
+     */
+    @GET
+    @Path("/{item_id}/metadata")
+    @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public MetadataEntry[] getItemMetadata(@PathParam("item_id") Integer itemId, @QueryParam("userIP") String user_ip,
+            @QueryParam("userAgent") String user_agent, @QueryParam("xforwardedfor") String xforwardedfor,
+            @Context HttpHeaders headers, @Context HttpServletRequest request) throws WebApplicationException
+    {
+
+        log.info("Reading item(id=" + itemId + ") metadata.");
+        org.dspace.core.Context context = null;
+        List<MetadataEntry> metadata = null;
+
+        try
+        {
+            context = createContext(getUser(headers));
+            org.dspace.content.Item dspaceItem = findItem(context, itemId, org.dspace.core.Constants.READ);
+
+            writeStats(dspaceItem, UsageEvent.Action.VIEW, user_ip, user_agent, xforwardedfor, headers, request, context);
+
+            metadata = new Item(dspaceItem, "metadata", context).getMetadata();
+            context.complete();
+        }
+        catch (SQLException e)
+        {
+            processException("Could not read item(id=" + itemId + "), SQLException. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Could not read item(id=" + itemId + "), ContextException. Message: " + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.trace("Item(id=" + itemId + ") metadata were successfully read.");
+        return metadata.toArray(new MetadataEntry[0]);
+    }
+
+    /**
+     * Return array of bitstreams in item. It can be pagged.
+     *
+     * @param itemId
+     *            Id of item in DSpace.
+     * @param limit
+     *            How many items will be in array.
+     * @param offset
+     *            On which index will start array.
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @return Return pagged array of bitstreams in item.
+     * @throws WebApplicationException
+     *             It can be throw by NOT_FOUND, UNAUTHORIZED, SQLException if
+     *             was problem with reading from database and ContextException
+     *             if was problem with creating context of DSpace.
+     */
+    @GET
+    @Path("/{item_id}/bitstreams")
+    @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Bitstream[] getItemBitstreams(@PathParam("item_id") Integer itemId,
+            @QueryParam("limit") @DefaultValue("20") Integer limit, @QueryParam("offset") @DefaultValue("0") Integer offset,
+            @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Reading item(id=" + itemId + ") bitstreams.(offset=" + offset + ",limit=" + limit + ")");
+        org.dspace.core.Context context = null;
+        List<Bitstream> bitstreams = null;
+        try
+        {
+            context = createContext(getUser(headers));
+            org.dspace.content.Item dspaceItem = findItem(context, itemId, org.dspace.core.Constants.READ);
+
+            writeStats(dspaceItem, UsageEvent.Action.VIEW, user_ip, user_agent, xforwardedfor, headers, request, context);
+
+            List<Bitstream> itemBitstreams = new Item(dspaceItem, "bitstreams", context).getBitstreams();
+
+            if ((offset + limit) > (itemBitstreams.size() - offset))
+            {
+                bitstreams = itemBitstreams.subList(offset, itemBitstreams.size());
+            }
+            else
+            {
+                bitstreams = itemBitstreams.subList(offset, offset + limit);
+            }
+            context.complete();
+        }
+        catch (SQLException e)
+        {
+            processException("Could not read item(id=" + itemId + ") bitstreams, SQLExcpetion. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Could not read item(id=" + itemId + ") bitstreams, ContextException. Message: " + e.getMessage(),
+                    context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.trace("Item(id=" + itemId + ") bitstreams were successfully read.");
+        return bitstreams.toArray(new Bitstream[0]);
+    }
+
+    /**
+     * Adding metadata fields to item. If metadata key is in item, it will be
+     * added, NOT REPLACED!
+     *
+     * @param itemId
+     *            Id of item in DSpace.
+     * @param metadata
+     *            List of metadata fields, which will be added into item.
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @return It returns status code OK(200) if all was ok. UNAUTHORIZED(401)
+     *         if user is not allowed to write to item. NOT_FOUND(404) if id of
+     *         item is incorrect.
+     * @throws WebApplicationException
+     *             It is throw by these exceptions: SQLException, if was problem
+     *             with reading from database or writing to database.
+     *             AuthorizeException, if was problem with authorization to item
+     *             fields. ContextException, if was problem with creating
+     *             context of DSpace.
+     */
+    @POST
+    @Path("/{item_id}/metadata")
+    @Consumes({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Response addItemMetadata(@PathParam("item_id") Integer itemId, List<MetadataEntry> metadata,
+            @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Adding metadata to item(id=" + itemId + ").");
+        org.dspace.core.Context context = null;
+
+        try
+        {
+            context = createContext(getUser(headers));
+            org.dspace.content.Item dspaceItem = findItem(context, itemId, org.dspace.core.Constants.WRITE);
+
+            writeStats(dspaceItem, UsageEvent.Action.UPDATE, user_ip, user_agent, xforwardedfor, headers, request, context);
+
+            for (MetadataEntry entry : metadata)
+            {
+                addMetadataEntry(context, dspaceItem, entry);
+            }
+            dspaceItem.update();
+            context.complete();
+
+        }
+        catch (SQLException e)
+        {
+            processException("Could not write metadata to item(id=" + itemId + "), SQLException. Message: " + e, context);
+        }
+        catch (AuthorizeException e)
+        {
+            processException("Could not write metadata to item(id=" + itemId + "), AuthorizeException. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Could not write metadata to item(id=" + itemId + "), ContextException. Message: " + e.getMessage(),
+                    context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.info("Metadata to item(id=" + itemId + ") were successfully added.");
+        return Response.status(Status.OK).build();
+    }
+
+    /**
+     * Create bitstream in item.
+     *
+     * @param itemId
+     *            Id of item in DSpace.
+     * @param inputStream
+     *            Data of bitstream in inputStream.
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @return Returns bitstream with status code OK(200). If id of item is
+     *         invalid , it returns status code NOT_FOUND(404). If user is not
+     *         allowed to write to item, UNAUTHORIZED(401).
+     * @throws WebApplicationException
+     *             It is thrown by these exceptions: SQLException, when was
+     *             problem with reading/writing from/to database.
+     *             AuthorizeException, when was problem with authorization to
+     *             item and add bitstream to item. IOException, when was problem
+     *             with creating file or reading from inpustream.
+     *             ContextException. When was problem with creating context of
+     *             DSpace.
+     */
+    // TODO Add option to add bitstream by URI.(for very big files)
+    @POST
+    @Path("/{item_id}/bitstreams")
+    public Bitstream addItemBitstream(@PathParam("item_id") Integer itemId, InputStream inputStream,
+            @QueryParam("name") String name, @QueryParam("description") String description,
+            @QueryParam("groupId") Integer groupId, @QueryParam("year") Integer year, @QueryParam("month") Integer month,
+            @QueryParam("day") Integer day, @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Adding bitstream to item(id=" + itemId + ").");
+        org.dspace.core.Context context = null;
+        Bitstream bitstream = null;
+
+        try
+        {
+            context = createContext(getUser(headers));
+            org.dspace.content.Item dspaceItem = findItem(context, itemId, org.dspace.core.Constants.WRITE);
+
+            writeStats(dspaceItem, UsageEvent.Action.UPDATE, user_ip, user_agent, xforwardedfor, headers, request, context);
+
+            // Is better to add bitstream to ORIGINAL bundle or to item own?
+            log.trace("Creating bitstream in item.");
+            Bundle bundle = null;
+            org.dspace.content.Bitstream dspaceBitstream = null;
+            Bundle[] bundles = dspaceItem.getBundles("ORIGINAL");
+			if(bundles != null && bundles.length != 0)
+			{
+				bundle = bundles[0]; // There should be only one bundle ORIGINAL.
+			}
+            if (bundle == null)
+            {
+                log.trace("Creating bundle in item.");
+                dspaceBitstream = dspaceItem.createSingleBitstream(inputStream);
+            }
+            else
+            {
+                log.trace("Getting bundle from item.");
+                dspaceBitstream = bundle.createBitstream(inputStream);
+            }
+
+            dspaceBitstream.setSource("DSpace Rest api");
+
+            // Set bitstream name and description
+            if (name != null)
+            {
+                if (BitstreamResource.getMimeType(name) == null)
+                {
+                    dspaceBitstream.setFormat(BitstreamFormat.findUnknown(context));
+                }
+                else
+                {
+                    dspaceBitstream.setFormat(BitstreamFormat.findByMIMEType(context, BitstreamResource.getMimeType(name)));
+                }
+                dspaceBitstream.setName(name);
+            }
+            if (description != null)
+            {
+                dspaceBitstream.setDescription(description);
+            }
+
+            dspaceBitstream.update();
+
+            // Create policy for bitstream
+            if (groupId != null)
+            {
+                bundles = dspaceBitstream.getBundles();
+                for (Bundle dspaceBundle : bundles)
+                {
+                    List<org.dspace.authorize.ResourcePolicy> bitstreamsPolicies = dspaceBundle.getBitstreamPolicies();
+
+                    // Remove default bitstream policies
+                    List<org.dspace.authorize.ResourcePolicy> policiesToRemove = new ArrayList<org.dspace.authorize.ResourcePolicy>();
+                    for (org.dspace.authorize.ResourcePolicy policy : bitstreamsPolicies)
+                    {
+                        if (policy.getResourceID() == dspaceBitstream.getID())
+                        {
+                            policiesToRemove.add(policy);
+                        }
+                    }
+                    for (org.dspace.authorize.ResourcePolicy policy : policiesToRemove)
+                    {
+                        bitstreamsPolicies.remove(policy);
+                    }
+
+                    org.dspace.authorize.ResourcePolicy dspacePolicy = org.dspace.authorize.ResourcePolicy.create(context);
+                    dspacePolicy.setAction(org.dspace.core.Constants.READ);
+                    dspacePolicy.setGroup(Group.find(context, groupId));
+                    dspacePolicy.setResourceID(dspaceBitstream.getID());
+                    dspacePolicy.setResource(dspaceBitstream);
+                    dspacePolicy.setResourceType(org.dspace.core.Constants.BITSTREAM);
+                    if ((year != null) || (month != null) || (day != null))
+                    {
+                        Date date = new Date();
+                        if (year != null)
+                        {
+                            date.setYear(year - 1900);
+                        }
+                        if (month != null)
+                        {
+                            date.setMonth(month - 1);
+                        }
+                        if (day != null)
+                        {
+                            date.setDate(day);
+                        }
+                        date.setHours(0);
+                        date.setMinutes(0);
+                        date.setSeconds(0);
+                        dspacePolicy.setStartDate(date);
+                    }
+
+                    dspacePolicy.update();
+                    dspaceBitstream.updateLastModified();
+                }
+            }
+
+            dspaceBitstream = org.dspace.content.Bitstream.find(context, dspaceBitstream.getID());
+            bitstream = new Bitstream(dspaceBitstream, "");
+
+            context.complete();
+
+        }
+        catch (SQLException e)
+        {
+            processException("Could not create bitstream in item(id=" + itemId + "), SQLException. Message: " + e, context);
+        }
+        catch (AuthorizeException e)
+        {
+            processException("Could not create bitstream in item(id=" + itemId + "), AuthorizeException. Message: " + e, context);
+        }
+        catch (IOException e)
+        {
+            processException("Could not create bitstream in item(id=" + itemId + "), IOException Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException(
+                    "Could not create bitstream in item(id=" + itemId + "), ContextException Message: " + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.info("Bitstream(id=" + bitstream.getId() + ") was successfully added into item(id=" + itemId + ").");
+        return bitstream;
+    }
+
+    /**
+     * Replace all metadata in item with new passed metadata.
+     *
+     * @param itemId
+     *            Id of item in DSpace.
+     * @param metadata
+     *            List of metadata fields, which will replace old metadata in
+     *            item.
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @return It returns status code: OK(200). NOT_FOUND(404) if item was not
+     *         found, UNAUTHORIZED(401) if user is not allowed to write to item.
+     * @throws WebApplicationException
+     *             It is thrown by: SQLException, when was problem with database
+     *             reading or writting, AuthorizeException when was problem with
+     *             authorization to item and metadata fields. And
+     *             ContextException, when was problem with creating context of
+     *             DSpace.
+     */
+    @PUT
+    @Path("/{item_id}/metadata")
+    @Consumes({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Response updateItemMetadata(@PathParam("item_id") Integer itemId, MetadataEntry[] metadata,
+            @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Updating metadata in item(id=" + itemId + ").");
+        org.dspace.core.Context context = null;
+
+        try
+        {
+            context = createContext(getUser(headers));
+            org.dspace.content.Item dspaceItem = findItem(context, itemId, org.dspace.core.Constants.WRITE);
+
+            writeStats(dspaceItem, UsageEvent.Action.UPDATE, user_ip, user_agent, xforwardedfor, headers, request, context);
+
+            log.trace("Deleting original metadata from item.");
+            for (MetadataEntry entry : metadata)
+            {
+                String data[] = mySplit(entry.getKey());
+                if ((data.length >= 2) && (data.length <= 3))
+                {
+                    dspaceItem.clearMetadata(data[0], data[1], data[2], org.dspace.content.Item.ANY);
+                }
+            }
+
+            log.trace("Adding new metadata to item.");
+            for (MetadataEntry entry : metadata) {
+                addMetadataEntry(context, dspaceItem, entry);
+            }
+
+            dspaceItem.update();
+            context.complete();
+
+        }
+        catch (SQLException e)
+        {
+            processException("Could not update metadata in item(id=" + itemId + "), SQLException. Message: " + e, context);
+        }
+        catch (AuthorizeException e)
+        {
+            processException("Could not update metadata in item(id=" + itemId + "), AuthorizeException. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException(
+                    "Could not update metadata in item(id=" + itemId + "), ContextException. Message: " + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.info("Metadata of item(id=" + itemId + ") were successfully updated.");
+        return Response.status(Status.OK).build();
+    }
+
+    private void addMetadataEntry(org.dspace.core.Context context, org.dspace.content.Item dspaceItem,
+                                  MetadataEntry entry) throws SQLException {
+
+        String data[] = mySplit(entry.getKey());
+        if ((data.length >= 2) && (data.length <= 3)) {
+
+            new AuthorityUtil().addMetadata(context, dspaceItem, data, entry.getValue(), entry.getLanguage());
+        }
+    }
+
+    /**
+     * Delete item from DSpace. It delete bitstreams only from item bundle.
+     *
+     * @param itemId
+     *            Id of item which will be deleted.
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @return It returns status code: OK(200). NOT_FOUND(404) if item was not
+     *         found, UNAUTHORIZED(401) if user is not allowed to delete item
+     *         metadata.
+     * @throws WebApplicationException
+     *             It can be thrown by: SQLException, when was problem with
+     *             database reading. AuthorizeException, when was problem with
+     *             authorization to item.(read and delete) IOException, when was
+     *             problem with deleting bitstream file. ContextException, when
+     *             was problem with creating context of DSpace.
+     */
+    @DELETE
+    @Path("/{item_id}")
+    public Response deleteItem(@PathParam("item_id") Integer itemId, @QueryParam("userIP") String user_ip,
+            @QueryParam("userAgent") String user_agent, @QueryParam("xforwardedfor") String xforwardedfor,
+            @Context HttpHeaders headers, @Context HttpServletRequest request) throws WebApplicationException
+    {
+
+        log.info("Deleting item(id=" + itemId + ").");
+        org.dspace.core.Context context = null;
+
+        try
+        {
+            context = createContext(getUser(headers));
+            org.dspace.content.Item dspaceItem = findItem(context, itemId, org.dspace.core.Constants.DELETE);
+
+            writeStats(dspaceItem, UsageEvent.Action.REMOVE, user_ip, user_agent, xforwardedfor, headers, request, context);
+
+            log.trace("Deleting item.");
+            org.dspace.content.Collection collection = org.dspace.content.Collection.find(context,
+                    dspaceItem.getCollections()[0].getID());
+            collection.removeItem(dspaceItem);
+            context.complete();
+
+        }
+        catch (SQLException e)
+        {
+            processException("Could not delete item(id=" + itemId + "), SQLException. Message: " + e, context);
+        }
+        catch (AuthorizeException e)
+        {
+            processException("Could not delete item(id=" + itemId + "), AuthorizeException. Message: " + e, context);
+            throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR);
+        }
+        catch (IOException e)
+        {
+            processException("Could not delete item(id=" + itemId + "), IOException. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Could not delete item(id=" + itemId + "), ContextException. Message: " + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.info("Item(id=" + itemId + ") was successfully deleted.");
+        return Response.status(Status.OK).build();
+    }
+
+    /**
+     * Delete all item metadata.
+     *
+     * @param itemId
+     *            Id of item in DSpace.
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @return It returns status code: OK(200). NOT_FOUND(404) if item was not
+     *         found, UNAUTHORIZED(401) if user is not allowed to delete item
+     *         metadata.
+     * @throws WebApplicationException
+     *             It is thrown by three exceptions. SQLException, when was
+     *             problem with reading item from database or editting metadata
+     *             fields. AuthorizeException, when was problem with
+     *             authorization to item. And ContextException, when was problem
+     *             with creating context of DSpace.
+     */
+    @DELETE
+    @Path("/{item_id}/metadata")
+    public Response deleteItemMetadata(@PathParam("item_id") Integer itemId, @QueryParam("userIP") String user_ip,
+            @QueryParam("userAgent") String user_agent, @QueryParam("xforwardedfor") String xforwardedfor,
+            @Context HttpHeaders headers, @Context HttpServletRequest request) throws WebApplicationException
+    {
+
+        log.info("Deleting metadata in item(id=" + itemId + ").");
+        org.dspace.core.Context context = null;
+
+        try
+        {
+            context = createContext(getUser(headers));
+            org.dspace.content.Item dspaceItem = findItem(context, itemId, org.dspace.core.Constants.WRITE);
+
+            writeStats(dspaceItem, UsageEvent.Action.UPDATE, user_ip, user_agent, xforwardedfor, headers, request, context);
+
+            log.trace("Deleting metadata.");
+            // TODO Rewrite without deprecated object. Leave there only generated metadata.
+            Metadatum[] value = dspaceItem.getMetadata("dc", "date", "accessioned", org.dspace.content.Item.ANY);
+            Metadatum[] value2 = dspaceItem.getMetadata("dc", "date", "available", org.dspace.content.Item.ANY);
+            Metadatum[] value3 = dspaceItem.getMetadata("dc", "identifier", "uri", org.dspace.content.Item.ANY);
+            Metadatum[] value4 = dspaceItem.getMetadata("dc", "description", "provenance", org.dspace.content.Item.ANY);
+
+            dspaceItem.clearMetadata(org.dspace.content.Item.ANY, org.dspace.content.Item.ANY, org.dspace.content.Item.ANY,
+                    org.dspace.content.Item.ANY);
+            dspaceItem.update();
+
+            // Add there generated metadata
+            dspaceItem.addMetadata(value[0].schema, value[0].element, value[0].qualifier, null, value[0].value);
+            dspaceItem.addMetadata(value2[0].schema, value2[0].element, value2[0].qualifier, null, value2[0].value);
+            dspaceItem.addMetadata(value3[0].schema, value3[0].element, value3[0].qualifier, null, value3[0].value);
+            dspaceItem.addMetadata(value4[0].schema, value4[0].element, value4[0].qualifier, null, value4[0].value);
+
+            dspaceItem.update();
+            context.complete();
+
+        }
+        catch (SQLException e)
+        {
+            processException("Could not delete item(id=" + itemId + "), SQLException. Message: " + e, context);
+        }
+        catch (AuthorizeException e)
+        {
+            processException("Could not delete item(id=" + itemId + "), AuthorizeExcpetion. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Could not delete item(id=" + itemId + "), ContextException. Message:" + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.info("Item(id=" + itemId + ") metadata were successfully deleted.");
+        return Response.status(Status.OK).build();
+    }
+
+    /**
+     * Delete bitstream from item bundle.
+     *
+     * @param itemId
+     *            Id of item in DSpace.
+     * @param headers
+     *            If you want to access to item under logged user into context.
+     *            In headers must be set header "rest-dspace-token" with passed
+     *            token from login method.
+     * @param bitstreamId
+     *            Id of bitstream, which will be deleted from bundle.
+     * @return Return status code OK(200) if is all ok. NOT_FOUND(404) if item
+     *         or bitstream was not found. UNAUTHORIZED(401) if user is not
+     *         allowed to delete bitstream.
+     * @throws WebApplicationException
+     *             It is thrown, when: Was problem with edditting database,
+     *             SQLException. Or problem with authorization to item, bundle
+     *             or bitstream, AuthorizeException. When was problem with
+     *             deleting file IOException. Or problem with creating context
+     *             of DSpace, ContextException.
+     */
+    @DELETE
+    @Path("/{item_id}/bitstreams/{bitstream_id}")
+    public Response deleteItemBitstream(@PathParam("item_id") Integer itemId, @PathParam("bitstream_id") Integer bitstreamId,
+            @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Deleting bitstream in item(id=" + itemId + ").");
+        org.dspace.core.Context context = null;
+
+        try
+        {
+            context = createContext(getUser(headers));
+            org.dspace.content.Item item = findItem(context, itemId, org.dspace.core.Constants.WRITE);
+
+            org.dspace.content.Bitstream bitstream = org.dspace.content.Bitstream.find(context, bitstreamId);
+            if (bitstream == null)
+            {
+                context.abort();
+                log.warn("Bitstream(id=" + bitstreamId + ") was not found.");
+                return Response.status(Status.NOT_FOUND).build();
+            }
+            else if (!AuthorizeManager.authorizeActionBoolean(context, bitstream, org.dspace.core.Constants.DELETE))
+            {
+                context.abort();
+                log.error("User(" + getUser(headers).getEmail() + ") is not allowed to delete bitstream(id=" + bitstreamId + ").");
+                return Response.status(Status.UNAUTHORIZED).build();
+            }
+
+            writeStats(item, UsageEvent.Action.UPDATE, user_ip, user_agent, xforwardedfor, headers, request, context);
+            writeStats(bitstream, UsageEvent.Action.REMOVE, user_ip, user_agent, xforwardedfor, headers,
+                    request, context);
+
+            log.trace("Deleting bitstream...");
+            for (Bundle bundle : item.getBundles())
+            {
+                for (org.dspace.content.Bitstream bit : bundle.getBitstreams())
+                {
+                    if (bit == bitstream)
+                    {
+                        bundle.removeBitstream(bitstream);
+                    }
+                }
+            }
+
+            context.complete();
+
+        }
+        catch (SQLException e)
+        {
+            processException("Could not delete bitstream(id=" + bitstreamId + "), SQLException. Message: " + e, context);
+        }
+        catch (AuthorizeException e)
+        {
+            processException("Could not delete bitstream(id=" + bitstreamId + "), AuthorizeException. Message: " + e, context);
+        }
+        catch (IOException e)
+        {
+            processException("Could not delete bitstream(id=" + bitstreamId + "), IOException. Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Could not delete bitstream(id=" + bitstreamId + "), ContextException. Message:" + e.getMessage(),
+                    context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        log.info("Bitstream(id=" + bitstreamId + ") from item(id=" + itemId + ") was successfuly deleted .");
+        return Response.status(Status.OK).build();
+    }
+
+    /**
+     * Find items by one metadada field.
+     *
+     * @param metadataEntry
+     *            Metadata field to search by.
+     * @param scheme
+     *            Scheme of metadata(key).
+     * @param value
+     *            Value of metadata field.
+     * @param headers
+     *            If you want to access the item as the user logged into context,
+     *            header "rest-dspace-token" must be set to token value retrieved
+     *            from the login method.
+     * @return Return array of found items.
+     * @throws WebApplicationException
+     *             Can be thrown: SQLException - problem with
+     *             database reading. AuthorizeException - problem with
+     *             authorization to item. IOException - problem with
+     *             reading from metadata field. ContextException -
+     *             problem with creating DSpace context.
+     */
+    @POST
+    @Path("/find-by-metadata-field")
+    @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Item[] findItemsByMetadataField(MetadataEntry metadataEntry, @QueryParam("expand") String expand,
+            @QueryParam("userIP") String user_ip, @QueryParam("userAgent") String user_agent,
+            @QueryParam("xforwardedfor") String xforwardedfor, @Context HttpHeaders headers, @Context HttpServletRequest request)
+            throws WebApplicationException
+    {
+
+        log.info("Looking for item with metadata(key=" + metadataEntry.getKey() + ",value=" + metadataEntry.getValue()
+                + ", language=" + metadataEntry.getLanguage() + ").");
+        org.dspace.core.Context context = null;
+
+        List<Item> items = new ArrayList<Item>();
+        String[] metadata = mySplit(metadataEntry.getKey());
+
+        try
+        {
+            context = createContext(getUser(headers));
+
+            // TODO Repair, it ends by error:
+            // "java.sql.SQLSyntaxErrorException: ORA-00932: inconsistent datatypes: expected - got CLOB"
+            /*
+             * if (metadata.length == 3){
+             *     itemIterator =  org.dspace.content.Item.findByMetadataField(context, metadata[0],
+             *     metadata[1], metadata[2], value);
+             * } else if (metadata.length == 2){
+             *     itemIterator = org.dspace.content.Item.findByMetadataField(context, metadata[0],
+             *     metadata[1], null, value);
+             * } else {
+             *     context.abort();
+             *     log.error("Finding failed, bad metadata key.");
+             *     throw new WebApplicationException(Response.Status.NOT_FOUND);
+             * }
+             *
+             * if (itemIterator.hasNext()) {
+             * item = new Item(itemIterator.next(), "", context);
+             * }
+             */
+
+            // Must used own style.
+            if ((metadata.length < 2) || (metadata.length > 3))
+            {
+                context.abort();
+                log.error("Finding failed, bad metadata key.");
+                throw new WebApplicationException(Status.NOT_FOUND);
+            }
+
+            List<Object> parameterList = new LinkedList<>();
+            String sql = "SELECT RESOURCE_ID, TEXT_VALUE, TEXT_LANG, SHORT_ID, ELEMENT, QUALIFIER " +
+                    "FROM METADATAVALUE " +
+                    "JOIN METADATAFIELDREGISTRY ON METADATAVALUE.METADATA_FIELD_ID = METADATAFIELDREGISTRY.METADATA_FIELD_ID " +
+                    "JOIN METADATASCHEMAREGISTRY ON METADATAFIELDREGISTRY.METADATA_SCHEMA_ID = METADATASCHEMAREGISTRY.METADATA_SCHEMA_ID " +
+                    "WHERE " +
+                    "SHORT_ID= ?  AND " +
+                    "ELEMENT= ? AND ";
+                    parameterList.add(metadata[0]);
+                    parameterList.add(metadata[1]);
+            if (metadata.length > 3)
+            {
+                sql += "QUALIFIER= ? AND ";
+                parameterList.add(metadata[2]);
+            }
+            if (org.dspace.storage.rdbms.DatabaseManager.isOracle())
+            {
+                sql += "dbms_lob.compare(TEXT_VALUE, ?) = 0 AND ";
+                parameterList.add(metadataEntry.getValue());
+            }
+            else
+            {
+                sql += "TEXT_VALUE=? AND ";
+                parameterList.add(metadataEntry.getValue());
+            }
+            if (metadataEntry.getLanguage() != null)
+            {
+                sql += "TEXT_LANG=?";
+                parameterList.add(metadataEntry.getLanguage());
+            }
+            else
+            {
+                sql += "TEXT_LANG is null";
+            }
+
+            Object[] parameters = parameterList.toArray();
+            TableRowIterator iterator = org.dspace.storage.rdbms.DatabaseManager.query(context, sql, parameters);
+            while (iterator.hasNext())
+            {
+                TableRow row = iterator.next();
+                org.dspace.content.Item dspaceItem = this.findItem(context, row.getIntColumn("RESOURCE_ID"),
+                        org.dspace.core.Constants.READ);
+                Item item = new Item(dspaceItem, expand, context);
+                writeStats(dspaceItem, UsageEvent.Action.VIEW, user_ip, user_agent, xforwardedfor, headers,
+                        request, context);
+                items.add(item);
+            }
+
+            context.complete();
+
+        }
+        catch (SQLException e)
+        {
+            processException("Something went wrong while finding item. SQLException, Message: " + e, context);
+        }
+        catch (ContextException e)
+        {
+            processException("Context error:" + e.getMessage(), context);
+        }
+        finally
+        {
+            processFinally(context);
+        }
+
+        if (items.size() == 0)
+        {
+            log.info("Items not found.");
+        }
+        else
+        {
+            log.info("Items were found.");
+        }
+
+        return items.toArray(new Item[0]);
+    }
+
+    /**
+     * Find item from DSpace database. It is encapsulation of method
+     * org.dspace.content.Item.find with checking if item exist and if user
+     * logged into context has permission to do passed action.
+     *
+     * @param context
+     *            Context of actual logged user.
+     * @param id
+     *            Id of item in DSpace.
+     * @param action
+     *            Constant from org.dspace.core.Constants.
+     * @return It returns DSpace item.
+     * @throws WebApplicationException
+     *             Is thrown when item with passed id is not exists and if user
+     *             has no permission to do passed action.
+     */
+    private org.dspace.content.Item findItem(org.dspace.core.Context context, int id, int action) throws WebApplicationException
+    {
+        org.dspace.content.Item item = null;
+        try
+        {
+            item = org.dspace.content.Item.find(context, id);
+
+            if (item == null)
+            {
+                context.abort();
+                log.warn("Item(id=" + id + ") was not found!");
+                throw new WebApplicationException(Status.NOT_FOUND);
+            }
+            else if (!AuthorizeManager.authorizeActionBoolean(context, item, action))
+            {
+                context.abort();
+                if (context.getCurrentUser() != null)
+                {
+                    log.error("User(" + context.getCurrentUser().getEmail() + ") has not permission to "
+                            + getActionString(action) + " item!");
+                }
+                else
+                {
+                    log.error("User(anonymous) has not permission to " + getActionString(action) + " item!");
+                }
+                throw new WebApplicationException(Status.UNAUTHORIZED);
+            }
+
+        }
+        catch (SQLException e)
+        {
+            processException("Something get wrong while finding item(id=" + id + "). SQLException, Message: " + e, context);
+        }
+        return item;
+    }
+}
diff --git a/dspace/modules/rest/src/main/java/org/dspace/rest/Resource.java b/dspace/modules/rest/src/main/java/org/dspace/rest/Resource.java
new file mode 100644
index 0000000000000000000000000000000000000000..ef783ce435bd9b4ee5b7e6e27ee9e0393f0926ac
--- /dev/null
+++ b/dspace/modules/rest/src/main/java/org/dspace/rest/Resource.java
@@ -0,0 +1,281 @@
+/*
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.rest;
+
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.List;
+import javax.servlet.ServletContext;
+import javax.servlet.http.HttpServletRequest;
+import javax.ws.rs.WebApplicationException;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.Response;
+
+import org.apache.log4j.Logger;
+import org.dspace.content.DSpaceObject;
+import org.dspace.core.ConfigurationManager;
+import org.dspace.core.Context;
+import org.dspace.eperson.EPerson;
+import org.dspace.rest.exceptions.ContextException;
+import org.dspace.usage.UsageEvent;
+import org.dspace.utils.DSpace;
+
+/**
+ * Superclass of all resource classes in REST API. It has methods for creating
+ * context, write statistics, processsing exceptions, splitting a key of
+ * metadata, string representation of action and method for getting the logged
+ * in user from the token in request header.
+ * 
+ * @author Rostislav Novak (Computing and Information Centre, CTU in Prague)
+ * 
+ */
+public class Resource
+{
+
+    @javax.ws.rs.core.Context public static ServletContext servletContext;
+
+    private static Logger log = Logger.getLogger(Resource.class);
+
+    private static final boolean writeStatistics;
+    static
+    {
+        writeStatistics = ConfigurationManager.getBooleanProperty("rest", "stats", false);
+    }
+
+    static public String getServletContextPath() {
+        return servletContext.getContextPath();
+    }
+    /**
+     * Create context to work with DSpace database. It can create context
+     * with or without a logged in user (parameter user is null). Throws
+     * WebApplicationException caused by: SQLException if there was a problem
+     * with reading from database. Throws AuthorizeException if there was
+     * a problem with authorization to read from the database. Throws Exception
+     * if there was a problem creating context.
+     * 
+     * @param person
+     *            User which will be logged in context.
+     * @return Newly created context with the logged in user unless the specified user was null.
+     *         If user is null, create the context without a logged in user.
+     * @throws ContextException
+     *             Thrown in case of a problem creating context. Can be caused by
+     *             SQLException error in creating context or finding the user to
+     *             log in. Can be caused by AuthorizeException if there was a
+     *             problem authorizing the found user.
+     */
+    protected static Context createContext(EPerson person) throws ContextException
+    {
+
+        Context context = null;
+
+        try
+        {
+            context = new Context();
+            context.getDBConnection().setAutoCommit(false); // Disable autocommit.
+
+            if (person != null)
+            {
+                context.setCurrentUser(person);
+            }
+
+            return context;
+        }
+        catch (SQLException e)
+        {
+            if ((context != null) && (context.isValid()))
+            {
+                context.abort();
+            }
+            throw new ContextException("Could not create context, SQLException. Message: " + e, e);
+        }
+    }
+
+    /**
+     * Records a statistics event about an object used via REST API.
+     * @param dspaceObject
+     *            DSpace object on which a request was performed.
+     * @param action
+     *            Action that was performed.
+     * @param user_ip
+     * @param user_agent
+     * @param xforwardedfor
+     * @param headers
+     * @param request
+     * @param context
+     */
+    protected void writeStats(DSpaceObject dspaceObject, UsageEvent.Action action,
+                              String user_ip, String user_agent, String xforwardedfor, HttpHeaders headers, HttpServletRequest request, Context context)
+    {
+        if (!writeStatistics)
+        {
+            return;
+        }
+
+        if ((user_ip == null) || (user_ip.length() == 0))
+        {
+            new DSpace().getEventService().fireEvent(new UsageEvent(action, request, context, dspaceObject));
+        }
+        else
+        {
+            new DSpace().getEventService().fireEvent(
+                    new UsageEvent(action, user_ip, user_agent, xforwardedfor, context, dspaceObject));
+        }
+
+        log.debug("fired event");
+    }
+
+    /**
+     * Process exception, print message to logger error stream and abort DSpace
+     * context.
+     *
+     * @param message
+     *            Message, which will be printed to error stream.
+     * @param context
+     *            Context which must be aborted.
+     * @throws WebApplicationException
+     *             This exception is throw for user of REST api.
+     */
+    protected static void processException(String message, Context context) throws WebApplicationException
+    {
+        if ((context != null) && (context.isValid()))
+        {
+            context.abort();
+        }
+        log.error(message);
+        throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);
+    }
+
+    /**
+     * Process finally statement. It will print message to logger error stream
+     * and abort DSpace context, if was not properly ended.
+     *
+     * @param context
+     *            Context which must be aborted.
+     * @throws WebApplicationException
+     *             This exception is throw for user of REST api.
+     */
+    protected void processFinally(Context context) throws WebApplicationException
+    {
+        if ((context != null) && (context.isValid()))
+        {
+            context.abort();
+            log.error("Something get wrong. Aborting context in finally statement.");
+            throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);
+        }
+    }
+
+    /**
+     * Split string with regex ".".
+     * 
+     * @param key
+     *            String which will be splitted.
+     * @return String array filed with separated string.
+     */
+    protected String[] mySplit(String key)
+    {
+        ArrayList<String> list = new ArrayList<String>();
+        int prev = 0;
+        for (int i = 0; i < key.length(); i++)
+        {
+            if (key.charAt(i) == '.')
+            {
+                list.add(key.substring(prev, i));
+                prev = i + 1;
+            }
+            else if (i + 1 == key.length())
+            {
+                list.add(key.substring(prev, i + 1));
+            }
+        }
+
+        if (list.size() == 2)
+        {
+            list.add(null);
+        }
+
+        return list.toArray(new String[0]);
+    }
+
+    /**
+     * Return string representation of values
+     * org.dspace.core.Constants.{READ,WRITE,DELETE}.
+     * 
+     * @param action
+     *            Constant from org.dspace.core.Constants.*
+     * @return String representation. read or write or delete.
+     */
+    protected String getActionString(int action)
+    {
+        String actionStr;
+        switch (action)
+        {
+        case org.dspace.core.Constants.READ:
+            actionStr = "read";
+            break;
+        case org.dspace.core.Constants.WRITE:
+            actionStr = "write";
+            break;
+        case org.dspace.core.Constants.DELETE:
+            actionStr = "delete";
+            break;
+        case org.dspace.core.Constants.REMOVE:
+            actionStr = "remove";
+            break;
+        case org.dspace.core.Constants.ADD:
+            actionStr = "add";
+            break;
+        default:
+            actionStr = "(?action?)";
+            break;
+        }
+        return actionStr;
+    }
+
+    /**
+     * Return EPerson based on stored token in headers under
+     * "rest-dspace-token".
+     * 
+     * @param headers
+     *            Only must have "rest-api-token" for successfull return of
+     *            user.
+     * @return Return EPerson logged under token in headers. If token was wrong
+     *         or header rest-dspace-token was missing, returns null.
+     */
+    protected static EPerson getUser(HttpHeaders headers)
+    {
+        Context context = null;
+        try {
+            context = new Context();
+
+            List<String> list = headers.getRequestHeader(TokenHolder.TOKEN_HEADER);
+            String token = null;
+            if ((list != null) && (list.size() > 0))
+            {
+                token = list.get(0);
+                Integer ePersonId = TokenHolder.getEPersonId(token);
+                if (ePersonId != null) {
+                    return EPerson.find(context, ePersonId);
+                }
+            }
+        } catch (SQLException e) {
+            Resource.processException("Status eperson db lookup error: " + e.getMessage(), context);
+        }
+        return null;
+    }
+
+    protected static String getToken(HttpHeaders headers) {
+        List<String> list = headers.getRequestHeader(TokenHolder.TOKEN_HEADER);
+        String token = null;
+        if ((list != null) && (list.size() > 0))
+        {
+            token = list.get(0);
+            return token;
+        }
+        return null;
+    }
+}
diff --git a/dspace/modules/rest/src/main/java/org/dspace/rest/RestIndex.java b/dspace/modules/rest/src/main/java/org/dspace/rest/RestIndex.java
new file mode 100644
index 0000000000000000000000000000000000000000..29d97de41c9b8e6793f37ee968981e76af974e1a
--- /dev/null
+++ b/dspace/modules/rest/src/main/java/org/dspace/rest/RestIndex.java
@@ -0,0 +1,252 @@
+/*
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.rest;
+
+import java.io.UnsupportedEncodingException;
+import java.sql.SQLException;
+import java.util.List;
+import javax.servlet.ServletContext;
+import javax.ws.rs.Consumes;
+import javax.ws.rs.GET;
+import javax.ws.rs.POST;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+
+import org.apache.log4j.Logger;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.eperson.EPerson;
+import org.dspace.rest.common.Status;
+import org.dspace.rest.common.User;
+import org.dspace.rest.exceptions.ContextException;
+
+/**
+ * Root of RESTful api. It provides login and logout. Also have method for
+ * printing every method which is provides by RESTful api.
+ * 
+ * @author Rostislav Novak (Computing and Information Centre, CTU in Prague)
+ * 
+ */
+@Path("/")
+public class RestIndex {
+    private static Logger log = Logger.getLogger(RestIndex.class);
+
+    @Context public static ServletContext servletContext;
+
+    /**
+     * Return html page with information about REST api. It contains methods all
+     * methods provide by REST api.
+     * 
+     * @return HTML page which has information about all methods of REST api.
+     */
+    @GET
+    @Produces(MediaType.TEXT_HTML)
+    public String sayHtmlHello() { 
+    	// TODO Better graphics, add arguments to all methods. (limit, offset, item and so on)
+        return "<html><title>DSpace REST - index</title>" +
+                "<body>"
+                	+ "<h1>DSpace REST API</h1>" +
+                	"Server path: " + servletContext.getContextPath() +
+                	"<h2>Index</h2>" +
+                		"<ul>" +
+                			"<li>GET / - Return this page.</li>" +
+                			"<li>GET /test - Return the string \"REST api is running\" for testing purposes.</li>" +
+                			"<li>POST /login - Method for logging into the DSpace RESTful API. You must post User class. Example: {\"email\":\"test@dspace\",\"password\":\"pass\"}. Returns a token which must be included in future requests in the \"rest-dspace-token\" header.</li>" +
+                			"<li>POST /logout - Method for logging out of the DSpace RESTful API. The request must include the \"rest-dspace-token\" token</li> header." +
+                		"</ul>" +
+                	"<h2>Communities</h2>" +
+                		"<ul>" +
+                			"<li>GET /communities - Return an array of all communities in DSpace.</li>" +
+                			"<li>GET /communities/top-communities - Returns an array of all top-leve communities in DSpace.</li>" +
+                			"<li>GET /communities/{communityId} - Returns a community with the specified ID.</li>" +
+                			"<li>GET /communities/{communityId}/collections - Returns an array of collections of the specified community.</li>" +
+                			"<li>GET /communities/{communityId}/communities - Returns an array of subcommunities of the specified community.</li>" +
+                			"<li>POST /communities - Create a new top-level community. You must post a community.</li>" +
+                			"<li>POST /communities/{communityId}/collections - Create a new collection in the specified community. You must post a collection.</li>" +
+                			"<li>POST /communities/{communityId}/communities - Create a new subcommunity in the specified community. You must post a community.</li>" +
+                			"<li>PUT /communities/{communityId} - Update the specified community.</li>" +
+                			"<li>DELETE /communities/{communityId} - Delete the specified community.</li>" +
+                			"<li>DELETE /communities/{communityId}/collections/{collectionId} - Delete the specified collection in the specified community.</li>" +
+                			"<li>DELETE /communities/{communityId}/communities/{communityId2} - Delete the specified subcommunity (communityId2) in the specified community (communityId).</li>" +
+                		"</ul>" +
+                	"<h2>Collections</h2>" +
+                	"<ul>" +
+                  		"<li>GET /collections - Return all DSpace collections in array.</li>" +
+                  		"<li>GET /collections/{collectionId} - Return a collection with the specified ID.</li>" +
+                  		"<li>GET /collections/{collectionId}/items - Return all items of the specified collection.</li>" +
+                  		"<li>POST /collections/{collectionId}/items - Create an item in the specified collection. You must post an item.</li>" +
+                  		"<li>POST /collections/find-collection - Find a collection by name.</li>" +
+                  		"<li>PUT /collections/{collectionId} </li> - Update the specified collection. You must post a collection." +
+                  		"<li>DELETE /collections/{collectionId} - Delete the specified collection from DSpace.</li>" +
+                  		"<li>DELETE /collections/{collectionId}/items/{itemId} - Delete the specified item (itemId) in the specified collection (collectionId). </li>" +
+                  	"</ul>" +
+                  	"<h2>Items</h2>" +
+                  	"<ul>" +
+                  		"<li>GET /items - Return a list of items.</li>" +
+                  		"<li>GET /items/{item id} - Return the specified item.</li>" +
+                  		"<li>GET /items/{item id}/metadata - Return metadata of the specified item.</li>" +
+                  		"<li>GET /items/{item id}/bitstreams - Return bitstreams of the specified item.</li>" +
+                  		"<li>POST /items/find-by-metadata-field - Find items by the specified metadata value.</li>" +
+                  		"<li>POST /items/{item id}/metadata - Add metadata to the specified item.</li>" +
+                  		"<li>POST /items/{item id}/bitstreams - Add a bitstream to the specified item.</li>" +
+                  		"<li>PUT /items/{item id}/metadata - Update metadata in the specified item.</li>" +
+                  		"<li>DELETE /items/{item id} - Delete the specified item.</li>" +
+                  		"<li>DELETE /items/{item id}/metadata - Clear metadata of the specified item.</li>" +
+                  		"<li>DELETE /items/{item id}/bitstreams/{bitstream id} - Delete the specified bitstream of the specified item.</li>" +
+                  	"</ul>" +
+                  	"<h2>Bitstreams</h2>" +
+                  	"<ul>" +
+                  		"<li>GET /bitstreams - Return all bitstreams in DSpace.</li>" +
+                  		"<li>GET /bitstreams/{bitstream id} - Return the specified bitstream.</li>" +
+                  		"<li>GET /bitstreams/{bitstream id}/policy - Return policies of the specified bitstream.</li>" +
+                  		"<li>GET /bitstreams/{bitstream id}/retrieve - Return the contents of the specified bitstream.</li>" +
+                  		"<li>POST /bitstreams/{bitstream id}/policy - Add a policy to the specified bitstream.</li>" +
+                  		"<li>PUT /bitstreams/{bitstream id}/data - Update the contents of the specified bitstream.</li>" +
+                  		"<li>PUT /bitstreams/{bitstream id} - Update metadata of the specified bitstream.</li>" +
+                  		"<li>DELETE /bitstreams/{bitstream id} - Delete the specified bitstream from DSpace.</li>" +
+                  		"<li>DELETE /bitstreams/{bitstream id}/policy/{policy_id} - Delete the specified bitstream policy.</li>" +
+                  	"</ul>" +
+                    "<h2>Authorities</h2>" +
+                    "<ul>" +
+                        "<li>PUT /authorities/{authority key}/value - Update the name on an authority. </li>" +
+                    "</ul>" +
+                "</body></html> ";
+    }
+    
+    /**
+     * Method only for testing whether the REST API is running.
+     * 
+     * @return String "REST api is running."
+     */
+    @GET
+    @Path("/test")
+    public String test()
+    {
+        return "REST api is running.";
+    }
+
+    /**
+     * Method to login a user into REST API.
+     * 
+     * @param user
+     *            User which will be logged in to REST API.
+     * @return Returns response code OK and a token. Otherwise returns response
+     *         code FORBIDDEN(403).
+     */
+    @POST
+    @Path("/login")
+    @Consumes({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Response login(User user)
+    {
+        String token = TokenHolder.login(user);
+        if (token == null)
+        {
+            log.info("REST Login Attempt failed for user: " + user.getEmail());
+            return Response.status(Response.Status.FORBIDDEN).build();
+        } else {
+            log.info("REST Login Success for user: " + user.getEmail());
+            return Response.ok(token, "text/plain").build();
+        }
+    }
+
+    /**
+     * Method to logout a user from DSpace REST API. Removes the token and user from
+     * TokenHolder.
+     * 
+     * @param headers
+     *            Request header which contains the header named
+     *            "rest-dspace-token" containing the token as value.
+     * @return Return response OK, otherwise BAD_REQUEST, if there was a problem with
+     *         logout or the token is incorrect.
+     */
+    @POST
+    @Path("/logout")
+    @Consumes({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
+    public Response logout(@Context HttpHeaders headers)
+    {
+        org.dspace.core.Context context = null;
+        List<String> list = headers.getRequestHeader(TokenHolder.TOKEN_HEADER);
+        String token = null;
+        boolean logout = false;
+        EPerson ePerson = null;
+        try {
+            if (list != null)
+            {
+                    context = new org.dspace.core.Context();
+                token = list.get(0);
+                    Integer ePersonId = TokenHolder.getEPersonId(token);
+
+                    if (ePersonId != null) {
+                        ePerson = EPerson.find(context, ePersonId);
+                        logout = TokenHolder.logout(context, token);
+                    }
+            }
+        } catch (SQLException e) {
+            Resource.processException("Status eperson db lookup error: " + e.getMessage(), context);
+        }
+
+
+        if ((token == null) || (!logout))
+        {
+            return Response.status(Response.Status.BAD_REQUEST).build();
+        }
+
+        if(ePerson != null) {
+            log.info("REST Logout: " + ePerson.getEmail());
+        }
+        return Response.ok().build();
+    }
+
+    /**
+     * Method to check current status of the service and logged in user.
+     * 
+     * okay: true | false
+     * authenticated: true | false
+     * epersonEMAIL: user@example.com
+     * epersonNAME: John Doe
+     * @param headers
+     * @return
+     */
+    @GET
+    @Path("/status")
+    @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
+    public Status status(@Context HttpHeaders headers) throws UnsupportedEncodingException {
+        org.dspace.core.Context context = null;
+        try {
+            EPerson user = Resource.getUser(headers);
+            context = Resource.createContext(user);
+            EPerson ePerson = context.getCurrentUser();
+
+            if (ePerson != null) {
+                //DB EPerson needed since token won't have full info, need context
+                EPerson dbEPerson = EPerson.findByEmail(context, ePerson.getEmail());
+                String token = Resource.getToken(headers);
+                return new Status(dbEPerson.getEmail(), dbEPerson.getFullName(), token);
+            }
+
+        } catch (ContextException e) {
+            Resource.processException("Status context error: " + e.getMessage(), context);
+        } catch (SQLException e) {
+            Resource.processException("Status eperson db lookup error: " + e.getMessage(), context);
+        } catch (AuthorizeException e) {
+            Resource.processException("Status eperson authorize exception: " + e.getMessage(), context);
+        } finally {
+            if (context != null) {
+                context.abort();
+            }
+        }
+
+        //fallback status, unauth
+        return new Status();
+    }
+
+
+}
diff --git a/dspace/modules/rest/src/main/java/org/dspace/rest/TokenHolder.java b/dspace/modules/rest/src/main/java/org/dspace/rest/TokenHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..d32187e4f54bed331028454a1340479f1a2e7c98
--- /dev/null
+++ b/dspace/modules/rest/src/main/java/org/dspace/rest/TokenHolder.java
@@ -0,0 +1,161 @@
+/*
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.rest;
+
+import java.sql.SQLException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+import javax.ws.rs.WebApplicationException;
+import javax.ws.rs.core.Response;
+
+import org.apache.log4j.Logger;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.core.Context;
+import org.dspace.eperson.EPerson;
+import org.dspace.rest.common.User;
+
+/**
+ * This class provide token generation, token holding and logging user into rest
+ * api. For login use method login with class org.dspace.rest.common.User. If
+ * you want to be deleted from holder, use method for logout.
+ * 
+ * @author Rostislav Novak (Computing and Information Centre, CTU in Prague)
+ */
+public class TokenHolder
+{
+
+    private static final Logger log = Logger.getLogger(TokenHolder.class);
+
+    public static String TOKEN_HEADER = "rest-dspace-token";
+
+    private static Map<String, String> tokens = new HashMap<String, String>(); // Map with pair Email,token
+
+    private static Map<String, Integer> persons = new HashMap<String, Integer>(); // Map with pair token,Eperson id
+
+    /**
+     * Login user into rest api. It check user credentials if they are okay.
+     * 
+     * @param user
+     *            User which will be logged into rest api.
+     * @return Returns generated token, which must be used in request header
+     *         under rest-api-token. If password is bad or user does not exist,
+     *         it returns NULL.
+     * @throws WebApplicationException
+     *             It is thrown by SQLException if user could not be read from
+     *             database. And by Authorization exception if context has not
+     *             permission to read eperson.
+     */
+    public static String login(User user) throws WebApplicationException
+    {
+        org.dspace.core.Context context = null;
+        String token = null;
+
+        try
+        {
+            context = new org.dspace.core.Context();
+            EPerson dspaceUser = EPerson.findByEmail(context, user.getEmail());
+
+            synchronized (TokenHolder.class) {
+                if ((dspaceUser == null) || (!dspaceUser.checkPassword(user.getPassword())))
+                {
+                    token = null;
+                }
+                else if (tokens.containsKey(user.getEmail()))
+                {
+                    token = tokens.get(user.getEmail());
+                }
+                else
+                {
+                    token = generateToken();
+                    persons.put(token, dspaceUser.getID());
+                    tokens.put(user.getEmail(), token);
+                }
+            }
+
+            log.trace("User(" + user.getEmail() + ") has been logged.");
+            context.complete();
+
+        }
+        catch (SQLException e)
+        {
+            context.abort();
+            log.error("Could not read user from database. Message:" + e);
+            throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);
+        }
+        catch (AuthorizeException e)
+        {
+            context.abort();
+            log.error("Could not find user, AuthorizeException. Message:" + e);
+            throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);
+        }
+        finally
+        {
+            if ((context != null) && (context.isValid()))
+            {
+                context.abort();
+                log.error("Something get wrong. Aborting context in finally statement.");
+                throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);
+            }
+        }
+
+        return token;
+    }
+
+    /**
+     * Return EPerson for log into context.
+     * 
+     * @param token
+     *            Token under which is stored eperson.
+     * @return Return EPerson id if token is right, otherwise it
+     *         returns NULL.
+     */
+    public static synchronized Integer getEPersonId(String token)
+    {
+        return persons.get(token);
+    }
+
+    /**
+     * Logout user from rest api. It delete token and EPerson from TokenHolder.
+     * 
+     * @param token
+     *            Token under which is stored eperson.
+     * @return Return true if was all okay, otherwise return false.
+     */
+    public static synchronized boolean logout(Context context, String token) throws SQLException
+    {
+        if ((token == null) || (persons.get(token) == null))
+        {
+            return false;
+        }
+        Integer personId = persons.get(token);
+        EPerson person = EPerson.find(context, personId);
+
+        personId = persons.remove(token);
+        if (personId == null)
+        {
+            return false;
+        }
+        if (person != null) {
+            String email = person.getEmail();
+        tokens.remove(email);
+        }
+        return true;
+    }
+
+    /**
+     * It generates unique token.
+     * 
+     * @return String filled with unique token.
+     */
+    private static String generateToken()
+    {
+        return UUID.randomUUID().toString();
+    }
+
+}
diff --git a/dspace/modules/rest/src/main/java/org/dspace/rest/common/Item.java b/dspace/modules/rest/src/main/java/org/dspace/rest/common/Item.java
new file mode 100644
index 0000000000000000000000000000000000000000..bee608fd62257f6ff996d6f13fc532bff3e5489d
--- /dev/null
+++ b/dspace/modules/rest/src/main/java/org/dspace/rest/common/Item.java
@@ -0,0 +1,210 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.rest.common;
+
+import org.apache.commons.lang3.StringUtils;
+import org.apache.log4j.Logger;
+import org.dspace.app.util.MetadataExposure;
+import org.dspace.authority.AuthorityValue;
+import org.dspace.authority.AuthorityValueFinder;
+import org.dspace.authority.orcid.Orcidv2AuthorityValue;
+import org.dspace.authorize.AuthorizeManager;
+import org.dspace.content.Bundle;
+import org.dspace.content.Metadatum;
+import org.dspace.core.Context;
+
+import javax.ws.rs.WebApplicationException;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlRootElement;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: peterdietz
+ * Date: 9/19/13
+ * Time: 4:50 PM
+ * To change this template use File | Settings | File Templates.
+ */
+@SuppressWarnings("deprecation")
+@XmlRootElement(name = "item")
+public class Item extends DSpaceObject {
+    Logger log = Logger.getLogger(Item.class);
+
+    String isArchived;
+    String isWithdrawn;
+    String lastModified;
+
+    Collection parentCollection;
+    List<Collection> parentCollectionList;
+    List<Community> parentCommunityList;
+    List<MetadataEntry> metadata;
+    List<Bitstream> bitstreams;
+
+    public Item(){}
+
+    public Item(org.dspace.content.Item item, String expand, Context context) throws SQLException, WebApplicationException{
+        super(item);
+        setup(item, expand, context);
+    }
+
+    private void setup(org.dspace.content.Item item, String expand, Context context) throws SQLException{
+        List<String> expandFields = new ArrayList<String>();
+        if(expand != null) {
+            expandFields = Arrays.asList(expand.split(","));
+        }
+
+        if(expandFields.contains("metadata") || expandFields.contains("all")) {
+            metadata = new ArrayList<MetadataEntry>();
+            Metadatum[] dcvs = item.getMetadata(org.dspace.content.Item.ANY, org.dspace.content.Item.ANY, org.dspace.content.Item.ANY, org.dspace.content.Item.ANY);
+            for (Metadatum dcv : dcvs) {
+                if (!MetadataExposure.isHidden(context, dcv.schema, dcv.element, dcv.qualifier)) {
+                    metadata.add(new MetadataEntry(dcv.getField(), assembleValue(context, dcv), dcv.language));
+                }
+            }
+        } else {
+            this.addExpand("metadata");
+        }
+
+        this.setArchived(Boolean.toString(item.isArchived()));
+        this.setWithdrawn(Boolean.toString(item.isWithdrawn()));
+        this.setLastModified(item.getLastModified().toString());
+
+        if(expandFields.contains("parentCollection") || expandFields.contains("all")) {
+            this.parentCollection = new Collection(item.getOwningCollection(), null, context, null, null);
+        } else {
+            this.addExpand("parentCollection");
+        }
+
+        if(expandFields.contains("parentCollectionList") || expandFields.contains("all")) {
+            this.parentCollectionList = new ArrayList<Collection>();
+            org.dspace.content.Collection[] collections = item.getCollections();
+            for(org.dspace.content.Collection collection : collections) {
+                this.parentCollectionList.add(new Collection(collection, null, context, null, null));
+            }
+        } else {
+            this.addExpand("parentCollectionList");
+        }
+
+        if(expandFields.contains("parentCommunityList") || expandFields.contains("all")) {
+            this.parentCommunityList = new ArrayList<Community>();
+            org.dspace.content.Community[] communities = item.getCommunities();
+            for(org.dspace.content.Community community : communities) {
+                this.parentCommunityList.add(new Community(community, null, context));
+            }
+        } else {
+            this.addExpand("parentCommunityList");
+        }
+
+        //TODO: paging - offset, limit
+        if(expandFields.contains("bitstreams") || expandFields.contains("all")) {
+            bitstreams = new ArrayList<Bitstream>();
+            Bundle[] bundles = item.getBundles();
+            for(Bundle bundle : bundles) {
+                org.dspace.content.Bitstream[] itemBitstreams = bundle.getBitstreams();
+                for(org.dspace.content.Bitstream itemBitstream : itemBitstreams) {
+                    if(AuthorizeManager.authorizeActionBoolean(context, itemBitstream, org.dspace.core.Constants.READ)) {
+                        bitstreams.add(new Bitstream(itemBitstream, null));
+                    }
+                }
+            }
+        } else {
+            this.addExpand("bitstreams");
+        }
+
+        if(!expandFields.contains("all")) {
+            this.addExpand("all");
+        }
+    }
+
+    private String assembleValue(final Context context, final Metadatum dcv) {
+        StringBuilder sb = new StringBuilder(dcv.value);
+
+        if (StringUtils.isNotBlank(dcv.authority)){
+
+            AuthorityValue authority = new AuthorityValueFinder().findByUID(context, dcv.authority);
+
+            sb.append("::");
+            sb.append(authority.getId());
+
+            if (authority instanceof Orcidv2AuthorityValue) {
+                sb.append("::");
+                sb.append(((Orcidv2AuthorityValue) authority).getOrcid_id());
+            }
+        }
+
+        return sb.toString();
+    }
+
+    public String getArchived() {
+        return isArchived;
+    }
+
+    public void setArchived(String archived) {
+        isArchived = archived;
+    }
+
+    public String getWithdrawn() {
+        return isWithdrawn;
+    }
+
+    public void setWithdrawn(String withdrawn) {
+        isWithdrawn = withdrawn;
+    }
+
+    public String getLastModified() {
+        return lastModified;
+    }
+
+    public void setLastModified(String lastModified) {
+        this.lastModified = lastModified;
+    }
+
+    public Collection getParentCollection() {
+        return parentCollection;
+    }
+
+    public List<Collection> getParentCollectionList() {
+        return parentCollectionList;
+    }
+
+    public List<MetadataEntry> getMetadata() {
+        return metadata;
+    }
+
+    public List<Bitstream> getBitstreams() {
+        return bitstreams;
+    }
+
+    public List<Community> getParentCommunityList() {
+        return parentCommunityList;
+    }
+
+	public void setParentCollection(Collection parentCollection) {
+		this.parentCollection = parentCollection;
+	}
+
+	public void setParentCollectionList(List<Collection> parentCollectionList) {
+		this.parentCollectionList = parentCollectionList;
+	}
+
+	public void setParentCommunityList(List<Community> parentCommunityList) {
+		this.parentCommunityList = parentCommunityList;
+	}
+
+	@XmlElement(required = true)
+	public void setMetadata(List<MetadataEntry> metadata) {
+		this.metadata = metadata;
+	}
+
+	public void setBitstreams(List<Bitstream> bitstreams) {
+		this.bitstreams = bitstreams;
+	}
+}
diff --git a/dspace/modules/rest/src/main/webapp/WEB-INF/web.xml b/dspace/modules/rest/src/main/webapp/WEB-INF/web.xml
new file mode 100644
index 0000000000000000000000000000000000000000..e006121667e2c1890911c77ad7f7171c344ea45f
--- /dev/null
+++ b/dspace/modules/rest/src/main/webapp/WEB-INF/web.xml
@@ -0,0 +1,101 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+
+    The contents of this file are subject to the license and copyright
+    detailed in the LICENSE and NOTICE files at the root of the source
+    tree and available online at
+
+    http://www.dspace.org/license/
+
+-->
+<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://java.sun.com/xml/ns/javaee"
+         xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
+         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
+         id="WebApp_ID" version="2.5">
+    <servlet>
+        <servlet-name>DSpace REST API</servlet-name>
+        <servlet-class>com.sun.jersey.spi.spring.container.servlet.SpringServlet</servlet-class>
+        <init-param>
+            <!--
+             The jersey ServletContainer will look for our Root Resource Class
+             (i.e. our HelloWorld class) in the foo.bar package
+             There are other ways to register this; see the jersey documentation for
+             more details
+            -->
+            <param-name>com.sun.jersey.config.property.packages</param-name>
+            <param-value>org.dspace.rest</param-value>
+        </init-param>
+        <init-param>
+            <param-name>com.sun.jersey.api.json.POJOMappingFeature</param-name>
+            <param-value>true</param-value>
+        </init-param>
+        <!--
+        Load the ServletContainer at startup.  A value of 1 indicates the ServletContainer
+        is a high priority servlet to load
+         -->
+        <load-on-startup>1</load-on-startup>
+    </servlet>
+
+    <servlet-mapping>
+        <servlet-name>DSpace REST API</servlet-name>
+        <url-pattern>/*</url-pattern>
+    </servlet-mapping>
+    
+    <!-- Security settings and mapping -->
+    <security-constraint>
+        <web-resource-collection>
+            <web-resource-name>DSpace REST API</web-resource-name>
+            <url-pattern>/*</url-pattern>
+        </web-resource-collection>
+        <user-data-constraint>
+            <transport-guarantee>NONE</transport-guarantee>
+        </user-data-constraint>
+    </security-constraint>
+    
+    <!-- DSpace Configuration Information -->
+    <context-param>
+        <param-name>dspace-config</param-name>
+        <param-value>${dspace.dir}/config/dspace.cfg</param-value>
+    </context-param>
+
+    <!-- new ConfigurationService initialization for dspace.dir -->
+    <context-param>
+        <description>
+            The location of the main DSpace configuration file
+        </description>
+        <param-name>dspace.dir</param-name>
+        <param-value>${dspace.dir}</param-value>
+    </context-param>
+
+    <context-param>
+        <param-name>contextConfigLocation</param-name>
+        <param-value>
+            /WEB-INF/applicationContext.xml
+        </param-value>
+        <!--
+            Add this context if using Spring Security
+            /WEB-INF/applicationContext-security.xml
+        -->
+    </context-param>
+
+    <!-- 
+       DSpace Kernel startup listener. This listener is in charge of initializing/starting the
+       DSpace Kernel. It MUST be listed BEFORE any other DSpace listeners, as DSpace services
+       will not function until the Kernel is initialized.
+    -->
+    <listener>
+        <listener-class>org.dspace.servicemanager.servlet.DSpaceKernelServletContextListener</listener-class>
+    </listener>
+
+    <listener>
+        <listener-class>org.dspace.app.util.DSpaceContextListener</listener-class>
+    </listener>
+    
+    <listener>
+        <listener-class>
+            org.springframework.web.context.ContextLoaderListener
+        </listener-class>
+    </listener>
+
+</web-app>
diff --git a/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/images/orcid_icon.png b/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/images/orcid_icon.png
new file mode 100644
index 0000000000000000000000000000000000000000..ef109145bc74c3f884d712ae2782ccedd29d096d
GIT binary patch
literal 1261
zcmbVMTWs4@7<LKtvaPIxQ4tX0;39;yB|f&}*f9x9V#hRN>8dnhK|*4#ebRWX?aX!;
zw;<GRg8@QQ1ur0ws02u`ham<+NC;MTsVGBz7#d<oyj7hTNU#<O#%&z8N#UW|1D5P_
z{&W8C`|p0Pzwe>W4R>rH2%<CJD;M$F6};`O_<Q&AH5D&mFIV;k?21=c9Ykbwdk}%V
zsScqcQuVR@b0|p=p^8x|d*#9|QM1jc8t6oQvxd<Gk=)_eRBae}U=R%%R*L-T<C7#X
z^c1;=E5JfcLRF)8+(855eI;#tSWD>Sjt4=~7cqf}JQeunh~<iYid^9p@jf`FNU);f
z4X4Oer^<zXAlVKATogt$7>6KEM`<?3^Za(eKpIkzp=c&T^CHWL5Q4@-Vr!0G5sR|Y
zu!W@*S@pb{NKy5AJz8g@wlhT0i9{mcV3-Kjh`3{xr}`1g?P)T|$kiO9<{7pH0!DSv
z9`#Zr_H;D_vsNgq5nFB}Q8;Ckuhu9!3MtbJ;#$#my(0S8jdiu%(pU{qMdaF}j)v<|
z>1l#-?yherP{iJdyBz};MIDiCZPY}TmzPr{zKQCFE^@piGf;pG$H2Hi<M3lrg5_vd
ziOU&*<C`4oVOds^gsc)%6pp9q94+t}A(s_|xWZ>8877+8yybeTrJ<%>1KVw2+3R9O
z$w8`TJ0;s5X?8$=)%I++YS(}?z=49Q8CD<%<ynnZMvid+>55~UU?snzv5tL3;uV_a
zV~}se%_%vVPta1F&cT>0lMSr?e{x1)XQ-e#{?jbYBiw<(cCGcXur@r%!V}}*(O5oI
z{e&P|?#j!VlK<_Xo(`RxfAl`$9UmM>za$c8Hooz~Q7YZ7%je%F-uycBUQ6hyTFbMc
z$<`FH|K+LJ>utu-SaNoH+bduGy!chyW33b0h0Pa2G_mh}B6KB996K_(<?^MgFs#3t
z`>m^Tf?kGy{{F{J-%ZQi)rrqC$N%D<*+wlgKc2jJj##>x@t3Z2ot`@q`MmWkt9F=M
z;nnHx(@V>bY<j}J1lyfs%<Xeq!NU*0EkAs}=ka;^HUFD0rte>Pnw*!jGn1W}wtK^1
zRy%xQB6Mcohg0uXKDuVzx%2XkXHR9HZ0UIZwuQ3rtA4|YU$RPdXL7fE%WUuYnT3(|
zjfc|U@ASdN&HbsV^x?`Tsj8@eWW%SJTYKKR7zQ)MJumM4)bIFUSMUSM=lbO1*}Vt<
E0ecprk^lez

literal 0
HcmV?d00001

diff --git a/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/styles/_style.scss b/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/styles/_style.scss
index 91425db26c6dc5e147820b94f8878ee2019c8283..be14b536fc14b847c30e70f9b0f30106050aac85 100644
--- a/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/styles/_style.scss
+++ b/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/styles/_style.scss
@@ -20,4 +20,13 @@
 @include selection {
     color: white;
     background: hotpink;
+}
+
+.orcid_icon {
+
+    margin-top: -2px;
+
+    &:hover {
+        text-decoration: none;
+    }
 }
\ No newline at end of file
diff --git a/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/xsl/additions.xsl b/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/xsl/additions.xsl
new file mode 100644
index 0000000000000000000000000000000000000000..1d61487e2cec1d051a1f136870f47796058039b6
--- /dev/null
+++ b/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/xsl/additions.xsl
@@ -0,0 +1,76 @@
+<xsl:stylesheet
+        xmlns:i18n="http://apache.org/cocoon/i18n/2.1"
+        xmlns:dri="http://di.tamu.edu/DRI/1.0/"
+        xmlns:mets="http://www.loc.gov/METS/"
+        xmlns:dim="http://www.dspace.org/xmlns/dspace/dim"
+        xmlns:xlink="http://www.w3.org/TR/xlink/"
+        xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"
+        xmlns="http://www.w3.org/1999/xhtml"
+        xmlns:xalan="http://xml.apache.org/xalan"
+        xmlns:encoder="xalan://java.net.URLEncoder"
+        xmlns:confman="org.dspace.core.ConfigurationManager"
+        exclude-result-prefixes="i18n dri mets dim xlink xsl xalan encoder confman">
+
+    <xsl:output indent="yes"/>
+
+    <xsl:template name="itemSummaryView-DIM-authors-entry">
+        <div>
+            <xsl:if test="@authority">
+                <xsl:attribute name="class"><xsl:text>ds-dc_contributor_author-authority</xsl:text></xsl:attribute>
+            </xsl:if>
+            <xsl:choose>
+                <xsl:when test="@orcidID">
+                    <xsl:call-template name="renderDiscovery">
+                        <xsl:with-param name="value" select="node()"/>
+                        <xsl:with-param name="orcidID" select="@orcidID"/>
+                    </xsl:call-template>
+                    <xsl:call-template name="renderORCID"/>
+                </xsl:when>
+                <xsl:otherwise>
+                    <xsl:copy-of select="node()"/>
+                </xsl:otherwise>
+            </xsl:choose>
+        </div>
+    </xsl:template>
+
+    <xsl:template name="renderDiscovery">
+        <xsl:param name="value"/>
+        <xsl:param name="orcidID"/>
+        <a>
+            <xsl:attribute name="href">
+                <xsl:value-of select="$context-path"/>
+                <xsl:text>/discover?filtertype_1=orcidid</xsl:text>
+                <xsl:text>&amp;filter_relational_operator_1=equals&amp;filter_1=</xsl:text>
+                <xsl:value-of select="substring-after($orcidID, confman:getProperty('orcid.connector.url'))"/>
+            </xsl:attribute>
+            <xsl:value-of select="$value"/>
+        </a>
+    </xsl:template>
+
+    <xsl:template name="renderORCID">
+        <a class="orcid_icon" target="_blank" href="{@orcidID}">
+            <xsl:text> </xsl:text>
+            <img src="{$theme-path}images/orcid_icon.png" alt="cc"/>
+        </a>
+    </xsl:template>
+
+    <xsl:template match="dri:referenceSet[@id='aspect.artifactbrowser.ItemViewer.referenceSet.collection-viewer']/dri:reference" mode="summaryView">
+        <!-- simplified check to verify whether access rights are available in METS -->
+        <xsl:variable name='METSRIGHTS-enabled' select="contains(confman:getProperty('plugin.named.org.dspace.content.crosswalk.DisseminationCrosswalk'), 'METSRIGHTS')" />
+        <xsl:variable name="externalMetadataURL">
+            <xsl:text>cocoon:/</xsl:text>
+            <xsl:value-of select="@url"/>
+            <!-- If this is an Item, display the METSRIGHTS section, so we
+                 know which files have access restrictions.
+                 This requires the METSRightsCrosswalk to be enabled! -->
+            <xsl:if test="@type='DSpace Item' and $METSRIGHTS-enabled">
+                <xsl:text>?rightsMDTypes=METSRIGHTS&amp;requireORCIDCall=true</xsl:text>
+            </xsl:if>
+        </xsl:variable>
+        <!-- This comment just displays the full URL in an HTML comment, for easy reference. -->
+        <xsl:comment> External Metadata URL: <xsl:value-of select="$externalMetadataURL"/> </xsl:comment>
+        <xsl:apply-templates select="document($externalMetadataURL)" mode="summaryView"/>
+        <!--<xsl:apply-templates /> prevents the collections section from being rendered in the default way-->
+    </xsl:template>
+
+</xsl:stylesheet>
\ No newline at end of file
diff --git a/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/xsl/theme.xsl b/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/xsl/theme.xsl
new file mode 100644
index 0000000000000000000000000000000000000000..401da1880d49a8aaf1b80cfb3702b90d65625cbd
--- /dev/null
+++ b/dspace/modules/xmlui-mirage2/src/main/webapp/themes/Mirage2/xsl/theme.xsl
@@ -0,0 +1,55 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+
+    The contents of this file are subject to the license and copyright
+    detailed in the LICENSE and NOTICE files at the root of the source
+    tree and available online at
+
+    http://www.dspace.org/license/
+
+-->
+
+<!--
+    TODO: Describe this XSL file
+    Author: Alexey Maslov
+
+-->
+
+<xsl:stylesheet xmlns:i18n="http://apache.org/cocoon/i18n/2.1"
+	xmlns:dri="http://di.tamu.edu/DRI/1.0/"
+	xmlns:mets="http://www.loc.gov/METS/"
+	xmlns:xlink="http://www.w3.org/TR/xlink/"
+	xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"
+	xmlns:dim="http://www.dspace.org/xmlns/dspace/dim"
+	xmlns:xhtml="http://www.w3.org/1999/xhtml"
+	xmlns:mods="http://www.loc.gov/mods/v3"
+	xmlns:dc="http://purl.org/dc/elements/1.1/"
+	xmlns="http://www.w3.org/1999/xhtml"
+	exclude-result-prefixes="i18n dri mets xlink xsl dim xhtml mods dc">
+
+    <!--<xsl:import href="../dri2xhtml-alt/dri2xhtml.xsl"/>-->
+    <xsl:import href="aspect/artifactbrowser/artifactbrowser.xsl"/>
+    <xsl:import href="core/global-variables.xsl"/>
+    <xsl:import href="core/elements.xsl"/>
+    <xsl:import href="core/forms.xsl"/>
+    <xsl:import href="core/page-structure.xsl"/>
+    <xsl:import href="core/navigation.xsl"/>
+    <xsl:import href="core/attribute-handlers.xsl"/>
+    <xsl:import href="core/utils.xsl"/>
+    <xsl:import href="aspect/general/choice-authority-control.xsl"/>
+    <xsl:import href="aspect/general/vocabulary-support.xsl"/>
+    <!--<xsl:import href="xsl/aspect/administrative/administrative.xsl"/>-->
+    <xsl:import href="aspect/artifactbrowser/common.xsl"/>
+    <xsl:import href="aspect/artifactbrowser/item-list.xsl"/>
+    <xsl:import href="aspect/artifactbrowser/item-view.xsl"/>
+    <xsl:import href="aspect/artifactbrowser/community-list.xsl"/>
+    <xsl:import href="aspect/artifactbrowser/collection-list.xsl"/>
+    <xsl:import href="aspect/artifactbrowser/browse.xsl"/>
+    <xsl:import href="aspect/discovery/discovery.xsl"/>
+    <xsl:import href="aspect/artifactbrowser/one-offs.xsl"/>
+    <xsl:import href="aspect/submission/submission.xsl"/>
+    <xsl:import href="additions.xsl"/>
+    <xsl:output indent="yes"/>
+
+
+</xsl:stylesheet>
diff --git a/dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/cocoon/DSpaceMETSGenerator.java b/dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/cocoon/DSpaceMETSGenerator.java
new file mode 100644
index 0000000000000000000000000000000000000000..1261a0211dd972070ef3672918040d3b9b5f55bd
--- /dev/null
+++ b/dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/cocoon/DSpaceMETSGenerator.java
@@ -0,0 +1,233 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.xmlui.cocoon;
+
+import org.apache.cocoon.ProcessingException;
+import org.apache.cocoon.ResourceNotFoundException;
+import org.apache.cocoon.environment.ObjectModelHelper;
+import org.apache.cocoon.environment.Request;
+import org.apache.cocoon.generation.AbstractGenerator;
+import org.apache.commons.lang.StringUtils;
+import org.dspace.app.xmlui.objectmanager.AbstractAdapter;
+import org.dspace.app.xmlui.objectmanager.ContainerAdapter;
+import org.dspace.app.xmlui.objectmanager.ItemAdapter;
+import org.dspace.app.xmlui.objectmanager.RepositoryAdapter;
+import org.dspace.app.xmlui.utils.ContextUtil;
+import org.dspace.app.xmlui.wing.WingException;
+import org.dspace.content.Collection;
+import org.dspace.content.Community;
+import org.dspace.content.DSpaceObject;
+import org.dspace.content.Item;
+import org.dspace.content.crosswalk.CrosswalkException;
+import org.dspace.core.Context;
+import org.dspace.handle.HandleManager;
+import org.xml.sax.SAXException;
+
+import java.io.IOException;
+import java.sql.SQLException;
+
+/**
+ * Generate a METS document for the identified item, community or collection. The object to be rendered should be
+ * identified by passing in one of the two parameters: handle or internal. If an internal ID is given then it must
+ * be of the form "type:id" i.g. item:255 or community:4 or repository:123456789. In the case of a repository the
+ * id must be the handle prefix.
+ * 
+ * In addition to rendering a METS document there are several options which can be specified for how the mets
+ * document should be rendered. All parameters are a comma-separated list of values, here is a list:
+ * 
+ * 
+ * sections:
+ * 
+ * A comma-separated list of METS sections to included. The possible values are: "metsHdr", "dmdSec", 
+ * "amdSec", "fileSec", "structMap", "structLink", "behaviorSec", and "extraSec". If no list is provided then *ALL*
+ * sections are rendered.
+ * 
+ * 
+ * dmdTypes:
+ * 
+ * A comma-separated list of metadata formats to provide as descriptive metadata. The list of available metadata
+ * types is defined in the dspace.cfg, dissemination crosswalks. If no formats are provided them DIM - DSpace 
+ * Intermediate Format - is used.
+ * 
+ * 
+ * amdTypes:
+ * 
+ * A comma-separated list of metadata formats to provide administrative metadata. DSpace does not currently
+ * support this type of metadata.
+ * 
+ * 
+ * fileGrpTypes:
+ * 
+ * A comma-separated list of file groups to render. For DSpace a bundle is translated into a METS fileGrp, so
+ * possible values are "THUMBNAIL","CONTENT", "METADATA", etc... If no list is provided then all groups are
+ * rendered.
+ * 
+ * 
+ * structTypes:
+ * 
+ * A comma-separated list of structure types to render. For DSpace there is only one structType: LOGICAL. If this
+ * is provided then the logical structType will be rendered, otherwise none will. The default operation is to
+ * render all structure types.
+ * 
+ * @author Scott Phillips
+ */
+public class DSpaceMETSGenerator extends AbstractGenerator
+{
+	/**
+	 * Generate the METS Document.
+	 */
+	public void generate() throws IOException, SAXException,
+			ProcessingException {
+		try {
+			// Open a new context.
+			Context context = ContextUtil.obtainContext(objectModel);
+			
+			// Determine which adapter to use
+			AbstractAdapter adapter = resolveAdapter(context);
+            if (adapter == null)
+            {
+                throw new ResourceNotFoundException("Unable to locate object.");
+            }
+            
+            // Configure the adapter for this request.
+            configureAdapter(adapter);
+            
+			// Generate the METS document
+			contentHandler.startDocument();
+			adapter.renderMETS(contentHandler,lexicalHandler);
+			contentHandler.endDocument();
+			
+		} catch (WingException we) {
+			throw new ProcessingException(we);
+		} catch (CrosswalkException ce) {
+			throw new ProcessingException(ce);
+		} catch (SQLException sqle) {
+			throw new ProcessingException(sqle);
+		}
+	}
+   
+	
+	
+	/**
+	 * Determine which type of adapter to use for this object, either a community, collection, item, or
+	 * repository adapter. The decision is based upon the two supplied identifiers: a handle or an
+	 * internal id. If the handle is supplied then this is resolved and the appropriate adapter is
+	 * picked. Otherwise the internal identifier is used to resolve the correct type of adapter.
+	 * 
+	 * The internal identifier must be of the form "type:id" i.g. item:255 or collection:99. In the
+	 * case of a repository the handle prefix must be used.
+	 * 
+	 * @return Return the correct adaptor or null if none found.
+	 */
+	private AbstractAdapter resolveAdapter(Context context) throws SQLException 
+	{			
+		Request request = ObjectModelHelper.getRequest(objectModel);
+        String contextPath = request.getContextPath();
+
+        // Determine the correct adapter to use for this item
+        String handle = parameters.getParameter("handle",null);
+        String internal = parameters.getParameter("internal",null);
+		
+        AbstractAdapter adapter = null;
+		 if (handle != null)
+         {
+            // Specified using a regular handle.
+            DSpaceObject dso = HandleManager.resolveToObject(context, handle);
+
+            // Handles can be either items or containers.
+            if (dso instanceof Item)
+            {
+                adapter = new ItemAdapter(context, (Item) dso, contextPath);
+            }
+         	else if (dso instanceof Collection || dso instanceof Community)
+            {
+                adapter = new ContainerAdapter(context, dso, contextPath);
+            }
+         }
+         else if (internal != null)
+         {
+        	// Internal identifier, format: "type:id".
+         	String[] parts = internal.split(":");
+         	
+         	if (parts.length == 2)
+         	{
+         		String type = parts[0];
+                       String strid = parts[1];
+         		int id = 0;
+
+                        // Handle prefixes must be treated as strings
+                        // all non-repository types need integer IDs
+                        if ("repository".equals(type))
+                        {
+                                if (HandleManager.getPrefix().equals(strid))
+                                {
+                                    adapter = new RepositoryAdapter(context, contextPath);
+                                }
+                        }
+                        else
+                        {
+                               id = Integer.valueOf(parts[1]); 
+         			if ("item".equals(type))
+         			{
+         				Item item = Item.find(context,id);
+         				if (item != null)
+                         {
+                             adapter = new ItemAdapter(context, item, contextPath);
+                         }
+         			}
+         			else if ("collection".equals(type))
+         			{
+         				Collection collection = Collection.find(context,id);
+         				if (collection != null)
+                         {
+                             adapter = new ContainerAdapter(context, collection, contextPath);
+                         }
+         			}
+         			else if ("community".equals(type))
+         			{
+         				Community community = Community.find(context,id);
+         				if (community != null)
+                         {
+                             adapter = new ContainerAdapter(context, community, contextPath);
+                         }
+         			}
+			}
+         	}
+         }
+		 return adapter;
+	}
+	
+	/**
+	 * Configure the adapter according to the supplied parameters.
+	 */
+	public void configureAdapter(AbstractAdapter adapter)
+	{
+        // Configure the adapter based upon the passed parameters
+        Request request = ObjectModelHelper.getRequest(objectModel);
+        String sections = request.getParameter("sections");
+        String dmdTypes = request.getParameter("dmdTypes");
+        String techMDTypes = request.getParameter("techMDTypes");
+        String rightsMDTypes = request.getParameter("rightsMDTypes");
+        String sourceMDTypes = request.getParameter("sourceMDTypes");
+        String digiprovMDTypes = request.getParameter("digiprovMDTypes");
+        String fileGrpTypes = request.getParameter("fileGrpTypes");
+        String structTypes = request.getParameter("structTypes");
+		String requireORCIDCall = request.getParameter("requireORCIDCall");
+        
+        adapter.setSections(sections);
+        adapter.setDmdTypes(dmdTypes);
+        adapter.setTechMDTypes(techMDTypes);
+        adapter.setRightsMDTypes(rightsMDTypes);
+        adapter.setSourceMDTypes(sourceMDTypes);
+        adapter.setDigiProvMDTypes(digiprovMDTypes);
+        adapter.setFileGrpTypes(fileGrpTypes);
+        adapter.setStructTypes(structTypes);
+        adapter.setRequireORCIDCall(StringUtils.equals(requireORCIDCall,"true"));
+	}
+
+}
diff --git a/dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/objectmanager/AbstractAdapter.java b/dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/objectmanager/AbstractAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..b962e75b960e1f70ed7feeabeb7617c6623d9397
--- /dev/null
+++ b/dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/objectmanager/AbstractAdapter.java
@@ -0,0 +1,741 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.xmlui.objectmanager;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.dspace.app.util.Util;
+import org.dspace.app.xmlui.wing.AttributeMap;
+import org.dspace.app.xmlui.wing.Namespace;
+import org.dspace.app.xmlui.wing.WingException;
+import org.dspace.content.Bitstream;
+import org.dspace.content.BitstreamFormat;
+import org.dspace.content.Item;
+import org.dspace.content.crosswalk.CrosswalkException;
+import org.dspace.content.crosswalk.DisseminationCrosswalk;
+import org.dspace.core.PluginManager;
+import org.xml.sax.ContentHandler;
+import org.xml.sax.SAXException;
+import org.xml.sax.ext.LexicalHandler;
+import org.xml.sax.helpers.AttributesImpl;
+import org.xml.sax.helpers.NamespaceSupport;
+
+
+/**
+ * This is the abstract adapter containing all the common elements between
+ * the three types of adapters: item, container, and repository. Each adapter
+ * translate a given type of DSpace object into a METS document for rendering
+ * into the DRI document.
+ * 
+ * This class provides the chassis for those unique parts of the document to be
+ * built upon. There are seven rendering methods that may be overridden for each
+ * section of the METS document.
+ * 
+ * Header
+ * Descriptive Section
+ * Administrative Section
+ * File Section
+ * Structure Map
+ * Structural Link
+ * Behavioral Section
+ * 
+ * @author Scott Phillips
+ */
+
+public abstract class AbstractAdapter
+{
+    /** Namespace declaration for METS & XLINK */
+    public static final String METS_URI = "http://www.loc.gov/METS/";
+    public static final Namespace METS = new Namespace(METS_URI);
+    public static final String XLINK_URI = "http://www.w3.org/TR/xlink/";
+    public static final Namespace XLINK = new Namespace(XLINK_URI);
+    public static final String XSI_URI = "http://www.w3.org/2001/XMLSchema-instance";
+    public static final Namespace XSI = new Namespace(XSI_URI);
+    public static final String DIM_URI = "http://www.dspace.org/xmlns/dspace/dim";
+    public static final Namespace DIM = new Namespace(DIM_URI);    
+    
+    /**
+     * A sequence used to generate unique mets ids.
+     */
+    private int idSequence = 0;
+    
+    /**
+     * The contextPath of this web application, used for generating URLs.
+     */
+    protected String contextPath;
+    
+    /**
+     * The SAX handlers for content and lexical events. Also the support 
+     * element for namespaces which knows the prefixes for each declared 
+     * namespace.
+     */
+    protected ContentHandler contentHandler;
+    protected LexicalHandler lexicalHandler;
+    protected NamespaceSupport namespaces;
+    
+    /**
+     * Construct a new adapter, implementers must call this method so
+     * the appropriate internal values are ensured to be set correctly.
+     * 
+     * @param contextPath
+     *            The contextPath of this web application.
+     */
+    public AbstractAdapter(String contextPath)
+    {
+        this.contextPath = contextPath;
+    }
+
+    /** The variables that dictate what part of the METS document to render */
+    List<String> sections = new ArrayList<String>();
+    List<String> dmdTypes = new ArrayList<String>();
+    Map<String,List> amdTypes = new HashMap<String,List>();
+    List<String> fileGrpTypes = new ArrayList<String>();
+    List<String> structTypes = new ArrayList<String>();
+    boolean requireORCIDCall = false;
+
+    public void setRequireORCIDCall(boolean requireORCIDCall){
+        this.requireORCIDCall = requireORCIDCall;
+    }
+
+    /**
+     * A comma-separated list of METS sections to render. If no value 
+     * is provided then all METS sections are rendered.
+     * 
+     * @param sections Comma separated list of METS sections.
+     */
+    public final void setSections(String sections)
+    {
+    	if (sections == null)
+        {
+            return;
+        }
+
+    	for (String section : sections.split(","))
+    	{
+    		this.sections.add(section);
+    	}
+    }
+    
+    /**
+     * A comma-separated list of METS descriptive metadata formats to 
+     * render. If no value is provided then only the DIM format is used.
+     * 
+     * @param dmdTypes Comma separated list of METS metadata types.
+     */
+    public final void setDmdTypes(String dmdTypes)
+    {
+    	if (dmdTypes == null)
+        {
+            return;
+        }
+
+    	for (String dmdType : dmdTypes.split(","))
+    	{
+    		this.dmdTypes.add(dmdType);
+    	}
+    }
+    
+    /**
+     * Store information about what will be rendered in the METS administrative
+     * metadata section.  HashMap format: keys = amdSec, value = List of mdTypes
+     *
+     * @param amdSec Section of <amdSec> where this administrative metadata
+     *                will be rendered
+     * @param mdTypes Comma-separated list of METS metadata types.
+     */
+    public final void setAmdTypes(String amdSec, String mdTypes)
+    {
+    	if (mdTypes == null)
+        {
+            return;
+        }
+
+        List<String> mdTypeList = new ArrayList<String>();
+    	for (String mdType : mdTypes.split(","))
+    	{
+    		mdTypeList.add(mdType);
+    	}
+        
+        this.amdTypes.put(amdSec, mdTypeList);
+    }
+
+    /**
+     * A comma-separated list of METS technical metadata formats to
+     * render.
+     *
+     * @param techMDTypes Comma-separated list of METS metadata types.
+     */
+    public final void setTechMDTypes(String techMDTypes)
+    {
+    	setAmdTypes("techMD", techMDTypes);
+    }
+
+    /**
+     * A comma-separated list of METS intellectual property rights metadata
+     * formats to render.
+     *
+     * @param rightsMDTypes Comma-separated list of METS metadata types.
+     */
+    public final void setRightsMDTypes(String rightsMDTypes)
+    {
+    	setAmdTypes("rightsMD", rightsMDTypes);
+    }
+
+    /**
+     * A comma-separated list of METS source metadata
+     * formats to render.
+     *
+     * @param sourceMDTypes Comma-separated list of METS metadata types.
+     */
+    public final void setSourceMDTypes(String sourceMDTypes)
+    {
+    	setAmdTypes("sourceMD", sourceMDTypes);
+    }
+
+    /**
+     * A comma-separated list of METS digital provenance metadata
+     * formats to render.
+     *
+     * @param digiprovMDTypes Comma-separated list of METS metadata types.
+     */
+    public final void setDigiProvMDTypes(String digiprovMDTypes)
+    {
+    	setAmdTypes("digiprovMD", digiprovMDTypes);
+    }
+    
+    /**
+     * A comma-separated list of METS fileGrps to render. If no value
+     * is provided then all groups are rendered.
+     * 
+     * @param fileGrpTypes Comma-separated list of METS file groups.
+     */
+    public final void setFileGrpTypes(String fileGrpTypes)
+    {
+    	if (fileGrpTypes == null)
+        {
+            return;
+        }
+
+    	for (String fileGrpType : fileGrpTypes.split(","))
+    	{
+    		this.fileGrpTypes.add(fileGrpType);
+    	}
+    }
+    
+    /**
+     * A comma-separated list of METS structural types to render. If no 
+     * value is provided then only the DIM format is used.
+     * 
+     * @param structTypes Comma-separated list of METS structure types.
+     */
+    public final void setStructTypes(String structTypes)
+    {
+    	if (structTypes == null)
+        {
+            return;
+        }
+
+    	for (String structType : structTypes.split(","))
+    	{
+    		this.structTypes.add(structType);
+    	}
+    }
+	
+    
+    /**
+     * 
+     * 
+     * 
+     * 
+     * 
+     * METS methods
+     * 
+     * 
+     * 
+     * 
+     * 
+     * 
+     */
+    
+    
+    /**
+     * @return the URL for this item in the interface
+     */
+    protected abstract String getMETSOBJID() throws WingException;
+
+    /**
+     * @return the URL for editing this item
+     */
+    protected abstract String getMETSOBJEDIT();
+
+    /**
+     * @return the METS ID of the mets document.
+     */
+    protected abstract String getMETSID() throws WingException;
+
+    /**
+     * @return The Profile this METS document conforms to.
+     */
+    protected abstract String getMETSProfile() throws WingException;
+
+    /**
+     * @return The label of this METS document.
+     */
+    protected abstract String getMETSLabel() throws WingException;
+
+    
+	/**
+	 * Render the complete METS document.
+	 */
+    public final void renderMETS(ContentHandler contentHandler, LexicalHandler lexicalHandler) throws WingException, SAXException, CrosswalkException, IOException, SQLException 
+    {
+    		this.contentHandler = contentHandler;
+    		this.lexicalHandler = lexicalHandler;
+    		this.namespaces = new NamespaceSupport();
+    	
+    	
+    		// Declare our namespaces
+    		namespaces.pushContext();
+    		namespaces.declarePrefix("mets", METS.URI);
+    		namespaces.declarePrefix("xlink", XLINK.URI);
+    		namespaces.declarePrefix("xsi", XSI.URI);
+    		namespaces.declarePrefix("dim", DIM.URI);
+    		contentHandler.startPrefixMapping("mets", METS.URI);
+    		contentHandler.startPrefixMapping("xlink", XLINK.URI);
+    		contentHandler.startPrefixMapping("xsi", XSI.URI);
+    		contentHandler.startPrefixMapping("dim", DIM.URI);
+    		
+    		// Send the METS element
+    		AttributeMap attributes = new AttributeMap();
+    		attributes.put("ID", getMETSID());
+    		attributes.put("PROFILE", getMETSProfile());
+    		attributes.put("LABEL", getMETSLabel());
+    		String objid = getMETSOBJID();
+    		if (objid != null)
+            {
+                attributes.put("OBJID", objid);
+            }
+
+            // Include the link for editing the item
+            objid = getMETSOBJEDIT();
+            if (objid != null)
+            {
+                attributes.put("OBJEDIT", objid);
+            }
+
+    		startElement(METS,"METS",attributes);
+
+    		// If the user requested no specific sections then render them all.
+    		boolean all = (sections.size() == 0);
+    		
+    		if (all || sections.contains("metsHdr"))
+            {
+                renderHeader();
+            }
+    		if (all || sections.contains("dmdSec"))
+            {
+                renderDescriptiveSection();
+            }
+    		if (all || sections.contains("amdSec"))
+            {
+                renderAdministrativeSection();
+            }
+    		if (all || sections.contains("fileSec"))
+            {
+                renderFileSection();
+            }
+    		if (all || sections.contains("structMap"))
+            {
+                renderStructureMap();
+            }
+    		if (all || sections.contains("structLink"))
+            {
+                renderStructuralLink();
+            }
+    		if (all || sections.contains("behaviorSec"))
+            {
+                renderBehavioralSection();
+            }
+    		
+    		// FIXME: this is not a met's section, it should be removed
+    		if (all || sections.contains("extraSec"))
+            {
+                renderExtraSections();
+            }
+    		
+    		endElement(METS,"METS");
+    		contentHandler.endPrefixMapping("mets");
+    		contentHandler.endPrefixMapping("xlink");
+    		contentHandler.endPrefixMapping("dim");
+    		namespaces.popContext();
+
+    }
+	
+    /**
+     * Each of the METS sections
+     */
+	protected void renderHeader() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}
+	protected void renderDescriptiveSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}
+	protected void renderAdministrativeSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}
+	protected void renderFileSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}
+	protected void renderStructureMap() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}
+	protected void renderStructuralLink() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}
+	protected void renderBehavioralSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}
+	protected void renderExtraSections() throws WingException, SAXException, CrosswalkException, SQLException, IOException {}
+    
+
+
+    /**
+     * Generate a METS file element for a given bitstream.
+     *
+     * @param item
+     *            If the bitstream is associated with an item provide the item
+     *            otherwise leave null.
+     * @param bitstream
+     *            The bitstream to build a file element for.
+     * @param fileID
+     *            The unique file id for this file.
+     * @param groupID
+     *            The group id for this file, if it is derived from another file
+     *            then they should share the same groupID.
+     */
+	protected final void renderFile(Item item, Bitstream bitstream, String fileID, String groupID) throws SAXException
+	{
+       renderFile(item, bitstream, fileID, groupID, null);
+    }
+
+	/**
+     * Generate a METS file element for a given bitstream.
+     * 
+     * @param item
+     *            If the bitstream is associated with an item, provide the item,
+     *            otherwise leave null.
+     * @param bitstream
+     *            The bitstream to build a file element for.
+     * @param fileID
+     *            The unique file id for this file.
+     * @param groupID
+     *            The group id for this file, if it is derived from another file
+     *            then they should share the same groupID.
+     * @param admID
+     *            The IDs of the administrative metadata sections which pertain
+     *            to this file
+     */
+	protected final void renderFile(Item item, Bitstream bitstream, String fileID, String groupID, String admID) throws SAXException
+	{
+		AttributeMap attributes;
+		
+		// //////////////////////////////
+    	// Determine the file attributes
+        BitstreamFormat format = bitstream.getFormat();
+        String mimeType = null;
+        if (format != null)
+        {
+            mimeType = format.getMIMEType();
+        }
+        String checksumType = bitstream.getChecksumAlgorithm();
+        String checksum = bitstream.getChecksum();
+        long size = bitstream.getSize();
+    	
+        // ////////////////////////////////
+        // Start the actual file
+        attributes = new AttributeMap();
+        attributes.put("ID", fileID);
+        attributes.put("GROUPID",groupID);
+        if (admID != null && admID.length()>0)
+        {
+            attributes.put("ADMID", admID);
+        }
+        if (mimeType != null && mimeType.length()>0)
+        {
+            attributes.put("MIMETYPE", mimeType);
+        }
+        if (checksumType != null && checksum != null)
+        {
+        	attributes.put("CHECKSUM", checksum);
+        	attributes.put("CHECKSUMTYPE", checksumType);
+        }
+        attributes.put("SIZE", String.valueOf(size));
+        startElement(METS,"file",attributes);
+        
+        
+        // ////////////////////////////////////
+        // Determine the file location attributes
+        String name = bitstream.getName();
+        String description = bitstream.getDescription();
+
+        
+        // If possible, reference this bitstream via a handle, however this may
+        // be null if a handle has not yet been assigned. In this case reference the
+        // item its internal id. In the last case where the bitstream is not associated
+        // with an item (such as a community logo) then reference the bitstreamID directly.
+        String identifier = null;
+        if (item != null && item.getHandle() != null)
+        {
+            identifier = "handle/" + item.getHandle();
+        }
+        else if (item != null)
+        {
+            identifier = "item/" + item.getID();
+        }
+        else
+        {
+            identifier = "id/" + bitstream.getID();
+        }
+        
+        
+        String url = contextPath + "/bitstream/"+identifier+"/";
+        
+        // If we can, append the pretty name of the bitstream to the URL
+        try
+        {
+        	if (bitstream.getName() != null)
+            {
+                url += Util.encodeBitstreamName(bitstream.getName(), "UTF-8");
+            }
+        }
+        catch (UnsupportedEncodingException uee)
+        {
+            // just ignore it, we don't have to have a pretty
+            // name at the end of the URL because the sequence id will 
+        	// locate it. However it means that links in this file might
+        	// not work....
+        }
+        
+        url += "?sequence="+bitstream.getSequenceID();
+        
+        
+        // //////////////////////
+        // Start the file location
+        attributes = new AttributeMap();
+        AttributeMap attributesXLINK = new AttributeMap();
+        attributesXLINK.setNamespace(XLINK);
+        attributes.put("LOCTYPE", "URL");
+        attributesXLINK.put("type","locator");
+        attributesXLINK.put("title", name);
+        if (description != null)
+        {
+            attributesXLINK.put("label", description);
+        }
+        attributesXLINK.put("href", url);
+        startElement(METS,"FLocat",attributes,attributesXLINK);
+        
+
+        // ///////////////////////
+        // End file location
+        endElement(METS,"FLocate");
+        
+        // ////////////////////////////////
+        // End the file
+        endElement(METS,"file");
+	}
+	
+	
+	/**
+     * 
+     * Generate a unique METS id. For consistency, all prefixes should probably
+     * end in an underscore, "_".
+     * 
+     * @param prefix
+     *            Prefix to prepend to the id for readability.
+     * 
+     * @return A unique METS id.
+     */
+    protected final String getGenericID(String prefix)
+    {
+        return prefix + (idSequence++);
+    }
+    
+    /**
+     * Return a dissemination crosswalk for the given name.
+     * 
+     * @param crosswalkName
+     * @return The crosswalk or throw an exception if not found.
+     */
+    public final DisseminationCrosswalk getDisseminationCrosswalk(String crosswalkName) throws WingException 
+    {
+    	// FIXME add some caching here
+    	DisseminationCrosswalk crosswalk = (DisseminationCrosswalk) PluginManager.getNamedPlugin(DisseminationCrosswalk.class, crosswalkName);
+
+	    if (crosswalk == null)
+        {
+            throw new WingException("Unable to find named DisseminationCrosswalk: " + crosswalkName);
+        }
+	    
+	    return crosswalk;
+    }
+    
+    /** 
+     * The METS defined types of Metadata, if a format is not listed here 
+     * then it should use the string "OTHER" and provide additional 
+     * attributes describing the metadata type 
+     */
+    public static final String[] METS_DEFINED_TYPES = 
+    	{"MARC","MODS","EAD","DC","NISOIMG","LC-AV","VRA","TEIHDR","DDI","FGDC","PREMIS"/*,"OTHER"*/};
+    
+    /**
+     * Determine if the provided metadata type is a standard METS
+     * defined type. If it is not, use the other string.
+     * 
+     * @param metadataType type name
+     * @return True if METS defined
+     */
+    public final boolean isDefinedMETStype(String metadataType)
+    {
+       for (String definedType : METS_DEFINED_TYPES)
+       {
+           if (definedType.equals(metadataType))
+           {
+               return true;
+           }
+       }
+       return false;
+    }
+    
+    
+    
+    
+    
+    /**
+	 * 
+	 * 
+	 * SAX Helper methods
+	 * 
+	 * 
+	 *
+	 */
+	
+	/**
+     * Send the SAX events to start this element.
+     * 
+     * @param namespace
+     *            (Required) The namespace of this element.
+     * @param name
+     *            (Required) The local name of this element.
+     * @param attributes
+     *            (May be null) Attributes for this element
+     */
+    protected final void startElement(Namespace namespace, String name,
+            AttributeMap... attributes) throws SAXException
+    {
+        contentHandler.startElement(namespace.URI, name, qName(namespace, name),
+                map2sax(namespace,attributes));
+    }
+
+    /**
+     * Send the SAX event for these plain characters, not wrapped in any
+     * elements.
+     * 
+     * @param characters
+     *            (May be null) Characters to send.
+     */
+    protected final void sendCharacters(String characters) throws SAXException
+    {
+        if (characters != null)
+        {
+            char[] contentArray = characters.toCharArray();
+            contentHandler.characters(contentArray, 0, contentArray.length);
+        }
+    }
+    
+    /**
+     * Send the SAX events to end this element.
+     * 
+     * @param namespace
+     *            (Required) The namespace of this element.
+     * @param name
+     *            (Required) The local name of this element.
+     */
+    protected final void endElement(Namespace namespace, String name)
+            throws SAXException
+    {
+        contentHandler.endElement(namespace.URI, name, qName(namespace, name));
+    }
+
+    /**
+     * Build the SAX attributes object based upon Java's String map. This
+     * convenience method will build, or add to an existing attributes object,
+     * the attributes detailed in the AttributeMap.
+     * 
+     * @param elementNamespace
+     *            SAX Helper class to keep track of namespaces able to determine
+     *            the correct prefix for a given namespace URI.
+     * @param attributes
+     *            An existing SAX AttributesImpl object to add attributes to.
+     *            If the value is null then a new attributes object will be
+     *            created to house the attributes.
+     * @param attributeMap
+     *            A map of attributes and values.
+     * @return
+     */
+    private AttributesImpl map2sax(Namespace elementNamespace, AttributeMap ... attributeMaps)
+    {
+
+        AttributesImpl attributes = new AttributesImpl();
+        for (AttributeMap attributeMap : attributeMaps)
+        {
+            boolean differentNamespaces = false;
+            Namespace attributeNamespace = attributeMap.getNamespace();
+            if (attributeNamespace != null && !(attributeNamespace.URI.equals(elementNamespace.URI)))
+            {
+                differentNamespaces = true;
+            }
+
+            // copy each one over.
+            for (Map.Entry<String, String> attr : attributeMap.entrySet())
+            {
+                if (attr.getValue() == null)
+                {
+                    continue;
+                }
+
+                if (differentNamespaces)
+                {
+                    attributes.addAttribute(attributeNamespace.URI, attr.getKey(),
+                            qName(attributeNamespace, attr.getKey()), "CDATA", attr.getValue());
+
+                }
+                else
+                {
+                    attributes.addAttribute("", attr.getKey(), attr.getKey(), "CDATA", attr.getValue());
+                }
+            }
+        }
+        return attributes;
+    }
+    
+    /**
+     * Create the qName for the element with the given localName and namespace
+     * prefix.
+     * 
+     * @param namespace
+     *            (May be null) The namespace prefix.
+     * @param localName
+     *            (Required) The element's local name.
+     * @return
+     */
+    private String qName(Namespace namespace, String localName)
+    {
+    	String prefix = namespaces.getPrefix(namespace.URI);
+        if (prefix == null || prefix.equals(""))
+        {
+            return localName;
+        }
+        else
+        {
+            return prefix + ":" + localName;
+        }
+    }
+    
+}
diff --git a/dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/objectmanager/ItemAdapter.java b/dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/objectmanager/ItemAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..91655db9a667b8451a5a3c75dd5bbc9e26981faf
--- /dev/null
+++ b/dspace/modules/xmlui/src/main/java/org/dspace/app/xmlui/objectmanager/ItemAdapter.java
@@ -0,0 +1,1178 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.xmlui.objectmanager;
+
+import org.dspace.authority.AuthorityUtil;
+import org.dspace.app.util.MetadataExposure;
+import org.dspace.app.util.Util;
+import org.dspace.app.xmlui.wing.AttributeMap;
+import org.dspace.app.xmlui.wing.WingException;
+import org.dspace.authority.AuthorityValue;
+import org.dspace.authority.AuthorityValueFinder;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.authorize.AuthorizeManager;
+import org.dspace.content.*;
+import org.dspace.content.authority.Choices;
+import org.dspace.content.crosswalk.ContextAwareDisseminationCrosswalk;
+import org.dspace.content.crosswalk.CrosswalkException;
+import org.dspace.content.crosswalk.DisseminationCrosswalk;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.ConfigurationManager;
+import org.dspace.core.Constants;
+import org.dspace.core.Context;
+import org.jdom.Element;
+import org.jdom.JDOMException;
+import org.jdom.output.SAXOutputter;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+import org.xml.sax.XMLReader;
+import org.xml.sax.helpers.XMLReaderFactory;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.sql.SQLException;
+import java.util.*;
+
+import static org.apache.commons.lang.StringUtils.isNotBlank;
+
+
+/**
+ * This is an adapter which translates a DSpace item into a METS document
+ * following the DSpace METS profile, err well mostly. At least if you use
+ * the proper configuration it will be fully compliant with the profile,
+ * however this adapter will allow you to configure it to be incorrect.
+ *
+ * When we are configured to be non-compliant with the profile, the MET's
+ * profile is changed to reflect the deviation. The DSpace profile states
+ * that metadata should be given in MODS format. However, you can configure
+ * this adapter to use any metadata crosswalk. When that case is detected we
+ * change the profile to say that we are deviating from the standard profile
+ * and it lists what metadata has been added.
+ *
+ * There are four parts to an item's METS document: descriptive metadata,
+ * file section, structural map, and extra sections.
+ * 
+ * Request item-support
+ * Original Concept, JSPUI version:    Universidade do Minho   at www.uminho.pt
+ * Sponsorship of XMLUI version:    Instituto Oceanográfico de España at www.ieo.es
+ * 
+ * @author Scott Phillips
+ * @author Adán Román Ruiz at arvo.es (for request item support) 
+ */
+
+public class ItemAdapter extends AbstractAdapter
+{
+    /** The item this METS adapter represents */
+    private Item item;
+
+    /** List of bitstreams which should be publicly viewable */
+    private List<Bitstream> contentBitstreams = new ArrayList<Bitstream>();
+
+    /** The primary bitstream, or null if none specified */
+    private Bitstream primaryBitstream;
+
+    /** A space-separated list of descriptive metadata sections */
+    private StringBuffer dmdSecIDS;
+
+    /** A space-separated list of administrative metadata sections (for item)*/
+    private StringBuffer amdSecIDS;
+    
+    /** A hashmap of all Files and their corresponding space separated list of
+        administrative metadata sections */
+    private Map<String,StringBuffer> fileAmdSecIDs = new HashMap<String,StringBuffer>();
+
+    // DSpace DB context
+    private Context context;
+
+    /**
+     * Construct a new ItemAdapter
+     *
+     * @param item
+     *            The DSpace item to adapt.
+     * @param contextPath
+     *            The contextpath for this webapplication.
+     */
+    public ItemAdapter(Context context, Item item, String contextPath)
+    {
+        super(contextPath);
+        this.item = item;
+        this.context = context;
+    }
+
+    /** Return the item */
+    public Item getItem()
+    {
+        return this.item;
+    }
+    
+    
+    
+    /**
+     *
+     *
+     *
+     * Required abstract methods
+     *
+     *
+     *
+     */
+
+    /**
+     * Return the URL of this item in the interface
+     */
+    protected String getMETSOBJID()
+    {
+        if (item.getHandle() != null)
+        {
+            return contextPath + "/handle/" + item.getHandle();
+        }
+        return null;
+    }
+
+    /**
+     * @return Return the URL for editing this item
+     */
+    protected String getMETSOBJEDIT()
+    {
+        return contextPath+"/admin/item?itemID=" + item.getID();
+    }
+
+    /**
+     * Return the item's handle as the METS ID
+     */
+    protected String getMETSID()
+    {
+        if (item.getHandle() == null)
+        {
+            return "item:" + item.getID();
+        }
+        else
+        {
+            return "hdl:" + item.getHandle();
+        }
+    }
+
+    /**
+     * Return the official METS SIP Profile.
+     */
+    protected String getMETSProfile() throws WingException
+    {
+        return "DSPACE METS SIP Profile 1.0";
+    }
+
+    /**
+     * Return a helpful label that this is a DSpace Item.
+     */
+    protected String getMETSLabel()
+    {
+        return "DSpace Item";
+    }
+    
+    /**
+     * Return a unique id for a bitstream.
+     */
+    protected String getFileID(Bitstream bitstream)
+    {
+        return "file_" + bitstream.getID();
+    }
+
+    /**
+     * Return a group id for a bitstream.
+     */
+    protected String getGroupFileID(Bitstream bitstream)
+    {
+        return "group_file_" + bitstream.getID();
+    }
+
+    /**
+     * Return a techMD id for a bitstream.
+     */
+    protected String getAmdSecID(String admSecName, String mdType, DSpaceObject dso)
+    {
+        if (dso.getType() == Constants.BITSTREAM)
+        {
+            return admSecName + "_" + getFileID((Bitstream) dso) + "_" + mdType;
+        }
+        else
+        {
+            return admSecName + "_" + dso.getID() + "_" + mdType;
+        }
+    }
+
+    /**
+     * Render the METS descriptive section. This will create a new metadata
+     * section for each crosswalk configured. Furthermore, a special check
+     * has been added that will add MODS descriptive metadata if it is
+     * available in DSpace.
+     *
+     * Example:
+     * <dmdSec>
+     *  <mdWrap MDTYPE="MODS">
+     *    <xmlData>
+     *      ... content from the crosswalk ...
+     *    </xmlDate>
+     *  </mdWrap>
+     * </dmdSec
+     */
+    protected void renderDescriptiveSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException
+    {
+        AttributeMap attributes;
+        String groupID = getGenericID("group_dmd_");
+        dmdSecIDS = new StringBuffer();
+
+        // Add DIM descriptive metadata if it was requested or if no metadata types
+        // were specified. Furthermore, since this is the default type we also use a
+        // faster rendering method that the crosswalk API.
+        if(dmdTypes.size() == 0 || dmdTypes.contains("DIM"))
+        {
+                // Metadata element's ID
+                String dmdID = getGenericID("dmd_");
+                // Keep track of all descriptive sections
+                dmdSecIDS.append(dmdID);
+                
+                        ////////////////////////////////
+                        // Start a metadata wrapper
+                        attributes = new AttributeMap();
+                        attributes.put("ID", dmdID);
+                        attributes.put("GROUPID", groupID);
+                        startElement(METS, "dmdSec", attributes);
+        
+                         ////////////////////////////////
+                        // Start a metadata wrapper
+                        attributes = new AttributeMap();
+                        attributes.put("MDTYPE","OTHER");
+                        attributes.put("OTHERMDTYPE", "DIM");
+                        startElement(METS,"mdWrap",attributes);
+                        
+                        // ////////////////////////////////
+                        // Start the xml data
+                        startElement(METS,"xmlData");
+        
+                        
+                        // ///////////////////////////////
+                        // Start the DIM element
+                        attributes = new AttributeMap();
+                        attributes.put("dspaceType", Constants.typeText[item.getType()]);
+            if (item.isWithdrawn())
+            {
+                attributes.put("withdrawn", "y");
+            }
+            startElement(DIM,"dim",attributes);
+
+            String orcidURL = ConfigurationManager.getProperty("orcid.connector.url");
+            if (isNotBlank(orcidURL)) {
+                orcidURL=orcidURL+(orcidURL.endsWith("/")?"":"/");
+            }
+                Metadatum[] dcvs = item.getMetadata(Item.ANY, Item.ANY, Item.ANY, Item.ANY);
+                for (Metadatum dcv : dcvs)
+                {
+                        if (!MetadataExposure.isHidden(context, dcv.schema, dcv.element, dcv.qualifier))
+                        {
+                        // ///////////////////////////////
+                        // Field element for each metadata field.
+                        attributes = new AttributeMap();
+                        attributes.put("mdschema",dcv.schema);
+                        attributes.put("element", dcv.element);
+                        if (dcv.qualifier != null)
+                        {
+                            attributes.put("qualifier", dcv.qualifier);
+                        }
+                        if (dcv.language != null)
+                        {
+                            attributes.put("language", dcv.language);
+                        }
+                        if (dcv.authority != null || dcv.confidence != Choices.CF_UNSET)
+                        {
+                            attributes.put("authority", dcv.authority);
+                            if (requireORCIDCall) {
+                                addORCIDIdIfPresent(attributes, orcidURL, dcv);
+                            }
+                            attributes.put("confidence", Choices.getConfidenceText(dcv.confidence));
+                        }
+                        startElement(DIM,"field",attributes);
+                        sendCharacters(dcv.value);
+                        endElement(DIM,"field");
+                }
+                }
+                        
+                // ///////////////////////////////
+                        // End the DIM element
+                        endElement(DIM,"dim");
+                        
+                // ////////////////////////////////
+                // End elements
+                endElement(METS,"xmlData");
+                endElement(METS,"mdWrap");
+                endElement(METS,"dmdSec");
+
+        }
+                
+        
+        // Add any extra crosswalks that may configured.
+        for (String dmdType : dmdTypes)
+        {
+                // If DIM was requested then it was generated above without using
+                // the crosswalk API. So we can skip this one.
+                if ("DIM".equals(dmdType))
+                {
+                    continue;
+                }
+                
+                DisseminationCrosswalk crosswalk = getDisseminationCrosswalk(dmdType);
+                
+                if (crosswalk == null)
+                {
+                    continue;
+                }
+                
+                String dmdID = getGenericID("dmd_");
+                // Add our id to the list.
+                dmdSecIDS.append(" ").append(dmdID);
+                
+                ////////////////////////////////
+                // Start a metadata wrapper
+                attributes = new AttributeMap();
+                attributes.put("ID", dmdID);
+                attributes.put("GROUPID", groupID);
+                startElement(METS, "dmdSec", attributes);
+
+                ////////////////////////////////
+                // Start a metadata wrapper
+                attributes = new AttributeMap();
+                if (isDefinedMETStype(dmdType))
+                {
+                        attributes.put("MDTYPE", dmdType);
+                }
+                else
+                {
+                        attributes.put("MDTYPE","OTHER");
+                        attributes.put("OTHERMDTYPE", dmdType);
+                }
+                startElement(METS,"mdWrap",attributes);
+                
+                // ////////////////////////////////
+                // Start the xml data
+                startElement(METS,"xmlData");
+
+                
+                // ///////////////////////////////
+                // Send the actual XML content
+                try {
+                Element dissemination = disseminateElement(crosswalk, item);
+        
+                        SAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);
+                        // Allow the basics for XML
+                        filter.allowElements().allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();
+                        
+                    SAXOutputter outputter = new SAXOutputter();
+                    outputter.setContentHandler(filter);
+                    outputter.setLexicalHandler(filter);
+                                outputter.output(dissemination);
+                        }
+            catch (JDOMException jdome)
+                        {
+                                throw new WingException(jdome);
+                        }
+                        catch (AuthorizeException ae)
+                        {
+                                // just ignore the authorize exception and continue on
+                                // without parsing the xml document.
+                        }
+                
+            
+            // ////////////////////////////////
+            // End elements
+            endElement(METS,"xmlData");
+            endElement(METS,"mdWrap");
+            endElement(METS,"dmdSec");
+        }
+
+
+        // Check to see if there is an in-line MODS document
+        // stored as a bitstream. If there is then we should also
+        // include these metadata in our METS document. However,
+        // we don't really know what the document describes, so we
+        // but it in its own dmd group.
+
+        Boolean include = ConfigurationManager.getBooleanProperty("xmlui.bitstream.mods");
+        if (include && dmdTypes.contains("MODS"))
+        {
+                // Generate a second group id for any extra metadata added.
+                String groupID2 = getGenericID("group_dmd_");
+                
+                Bundle[] bundles = item.getBundles("METADATA");
+                for (Bundle bundle : bundles)
+                {
+                        Bitstream bitstream = bundle.getBitstreamByName("MODS.xml");
+        
+                        if (bitstream == null)
+                        {
+                            continue;
+                        }
+                        
+                        
+                        String dmdID = getGenericID("dmd_");
+                        
+                        
+                        ////////////////////////////////
+                        // Start a metadata wrapper
+                        attributes = new AttributeMap();
+                        attributes.put("ID", dmdID);
+                        attributes.put("GROUPID", groupID2);
+                        startElement(METS, "dmdSec", attributes);
+        
+                         ////////////////////////////////
+                        // Start a metadata wrapper
+                        attributes = new AttributeMap();
+                        attributes.put("MDTYPE", "MODS");
+                        startElement(METS,"mdWrap",attributes);
+                        
+                        // ////////////////////////////////
+                        // Start the xml data
+                        startElement(METS,"xmlData");
+                        
+                        
+                        // ///////////////////////////////
+                        // Send the actual XML content
+                        
+                        SAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);
+                        // Allow the basics for XML
+                        filter.allowElements().allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();
+                        
+                        XMLReader reader = XMLReaderFactory.createXMLReader();
+                        reader.setContentHandler(filter);
+                        reader.setProperty("http://xml.org/sax/properties/lexical-handler", filter);
+                        try {
+                                InputStream is = bitstream.retrieve();
+                                reader.parse(new InputSource(is));
+                        }
+                        catch (AuthorizeException ae)
+                        {
+                                // just ignore the authorize exception and continue on
+                                // without parsing the xml document.
+                        }
+                        
+                        // ////////////////////////////////
+                    // End elements
+                    endElement(METS,"xmlData");
+                    endElement(METS,"mdWrap");
+                    endElement(METS, "dmdSec");
+                }
+        }
+    
+    }
+
+    private void addORCIDIdIfPresent(AttributeMap attributes, String orcidURL, Metadatum dcv) {
+
+        if (new AuthorityUtil().isPersonAuthority(dcv.getField())) {
+
+            AuthorityValue authorityValue = new AuthorityValueFinder().findByUID(context, dcv.authority);
+            if (authorityValue != null) {
+                String orcidId = (String) authorityValue.getSolrInputDocument().getFieldValue("orcid_id");
+                if (isNotBlank(orcidId)) {
+                    attributes.put("orcidID", orcidURL + orcidId);
+                }
+            }
+        }
+    }
+
+    /**
+     * Render the METS administrative section.
+     *
+     * Example:
+     * <amdSec>
+     *  <mdWrap MDTYPE="OTHER" OTHERMDTYPE="METSRights">
+     *    <xmlData>
+     *      ... content from the crosswalk ...
+     *    </xmlDate>
+     *  </mdWrap>
+     * </amdSec>
+     */
+    protected void renderAdministrativeSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException
+    {
+        AttributeMap attributes;
+        String groupID;
+
+        // Only create an <amdSec>, if we have amdTypes (or sub-sections) specified...
+        // (this keeps our METS file small, by default, and hides all our admin metadata)
+        if(amdTypes.size() > 0)
+        {
+          ////////////////////////////////
+          // Start an administrative wrapper
+
+          // Administrative element's ID
+          String amdID = getGenericID("amd_");
+          attributes = new AttributeMap();
+          attributes.put("ID", amdID);
+          startElement(METS, "amdSec", attributes);
+
+          groupID = getGenericID("group_amd_");
+          attributes.put("GROUPID", groupID);
+        }
+
+        // For each administrative metadata section specified
+        for (String amdSecName : amdTypes.keySet())
+        {
+          // get a list of metadata crosswalks which will be used to build
+          // this administrative metadata section
+          List<String> mdTypes = amdTypes.get(amdSecName);
+
+          // For each crosswalk
+          for (String mdType : mdTypes)
+          {
+            // get our dissemination crosswalk
+            DisseminationCrosswalk crosswalk = getDisseminationCrosswalk(mdType);
+
+            // skip, if we cannot find this crosswalk in config file
+            if (crosswalk == null)
+            {
+                continue;
+            }
+
+            // First, check if this crosswalk can handle disseminating Item-level Administrative metadata
+            if(crosswalk.canDisseminate(item))
+            {
+              // Since this crosswalk works with items, first render a section for entire item
+              renderAmdSubSection(amdSecName, mdType, crosswalk, item);
+            }
+
+            // Next, we'll try and render Bitstream-level administrative metadata
+            // (Although, we're only rendering this metadata for the bundles specified)
+            List<Bundle> bundles = findEnabledBundles();
+            for (Bundle bundle : bundles)
+            {
+              Bitstream[] bitstreams = bundle.getBitstreams();
+
+              // Create a sub-section of <amdSec> for each bitstream in bundle
+              for(Bitstream bitstream : bitstreams)
+              {
+                 // Only render the section if crosswalk works with bitstreams
+                 if(crosswalk.canDisseminate(bitstream))
+                 {
+                    renderAmdSubSection(amdSecName, mdType, crosswalk, bitstream);
+                 }
+              } // end for each bitstream
+            } // end for each bundle
+          } // end for each crosswalk
+        } // end for each amdSec
+        
+        if(amdTypes.size() > 0)
+        {
+          //////////////////////////////////
+          // End administrative section
+          endElement(METS,"amdSec");
+        }
+    }
+
+    /**
+     * Render a sub-section of the administrative metadata section.
+     * Valid sub-sections include: techMD, rightsMD, sourceMD, digiprovMD
+     *
+     * Example:
+     * <techMD>
+     *   <mdWrap MDTYPE="PREMIS">
+     *     <xmlData>
+     *       [PREMIS content ... ]
+     *     </xmlData>
+     *   </mdWrap>
+     * </techMD>
+     *
+     * @param amdSecName Name of administrative metadata section
+     * @param mdType Type of metadata section (e.g. PREMIS)
+     * @param crosswalk The DisseminationCrosswalk to use to generate this section
+     * @param dso The current DSpace object to use the crosswalk on
+     */
+    protected void renderAmdSubSection(String amdSecName, String mdType, DisseminationCrosswalk crosswalk, DSpaceObject dso)
+            throws WingException, SAXException, CrosswalkException, IOException, SQLException
+    {
+        /////////////////////////////////
+        // Start administrative metadata section wrapper
+        String amdSecID = getAmdSecID(amdSecName, mdType, dso);
+        AttributeMap attributes = new AttributeMap();
+        attributes.put("ID", amdSecID);
+        startElement(METS, amdSecName, attributes);
+
+        // If this is a bitstream
+        if (dso.getType() == Constants.BITSTREAM)
+        {
+          // Add this to our list of each file's administrative section IDs
+          String fileID = getFileID((Bitstream) dso);
+          if(fileAmdSecIDs.containsKey(fileID))
+          {
+              fileAmdSecIDs.get(fileID).append(" " + amdSecID);
+          }
+          else
+          {
+              fileAmdSecIDs.put(fileID, new StringBuffer(amdSecID));
+          }
+        } // else if an Item
+        else if (dso.getType() == Constants.ITEM)
+        {
+           // Add this to our list of item's administrative section IDs
+           if(amdSecIDS==null)
+           {
+               amdSecIDS = new StringBuffer(amdSecID);
+           }
+           else
+           {
+               amdSecIDS.append(" ").append(amdSecID);
+           }
+        }
+
+        ////////////////////////////////
+        // Start a metadata wrapper
+        attributes = new AttributeMap();
+        if (isDefinedMETStype(mdType))
+        {
+            attributes.put("MDTYPE", mdType);
+        }
+        else
+        {
+            attributes.put("MDTYPE","OTHER");
+            attributes.put("OTHERMDTYPE", mdType);
+        }
+        startElement(METS,"mdWrap",attributes);
+
+        //////////////////////////////////
+        // Start the xml data
+        startElement(METS,"xmlData");
+
+        /////////////////////////////////
+        // Send the actual XML content,
+        // using the PREMIS crosswalk for each bitstream
+        try {
+            Element dissemination = disseminateElement(crosswalk, dso);
+
+            SAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);
+            // Allow the basics for XML
+            filter.allowElements().allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();
+
+            SAXOutputter outputter = new SAXOutputter();
+            outputter.setContentHandler(filter);
+            outputter.setLexicalHandler(filter);
+            outputter.output(dissemination);
+        }
+        catch (JDOMException jdome)
+        {
+            throw new WingException(jdome);
+        }
+        catch (AuthorizeException ae)
+        {
+            // just ignore the authorize exception and continue on
+            // without parsing the xml document.
+        }
+
+        // ////////////////////////////////
+        // End elements
+        endElement(METS,"xmlData");
+        endElement(METS,"mdWrap");
+        endElement(METS,amdSecName);
+    }
+
+    private Element disseminateElement(DisseminationCrosswalk crosswalk, DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
+        Element dissemination;
+        if(crosswalk instanceof ContextAwareDisseminationCrosswalk)
+        {
+            ((ContextAwareDisseminationCrosswalk)crosswalk).setContext(context);
+        }
+        dissemination = crosswalk.disseminateElement(dso);
+
+        return dissemination;
+    }
+
+    /**
+     * Render the METS file section. This will contain a list of all bitstreams in the
+     * item. Each bundle, even those that are not typically displayed will be listed.
+     *
+     * Example:
+     * <fileSec>
+     *   <fileGrp USE="CONTENT">
+     *     <file ... >
+     *       <fLocate ... >
+     *     </file>
+     *   </fileGrp>
+     *   <fileGrp USE="TEXT">
+     *     <file ... >
+     *       <fLocate ... >
+     *     </file>
+     *   </fileGrp>
+     * </fileSec>
+     */
+    protected void renderFileSection() throws SQLException, SAXException
+    {
+        AttributeMap attributes;
+        
+        // //////////////////////
+        // Start a new file section
+        startElement(METS,"fileSec");
+        
+        // Check if the user is requested a specific bundle or
+        // the all bundles.
+        List<Bundle> bundles = findEnabledBundles();
+
+        // Suppress license?
+        Boolean showLicense = ConfigurationManager.getBooleanProperty("webui.licence_bundle.show");
+
+        // Check if ORIGINAL bundle included (either explicitly or via include all fileGrp types)
+        boolean includeContentBundle = this.fileGrpTypes.isEmpty() ? true : this.fileGrpTypes.contains("ORIGINAL");
+
+        // Loop over all requested bundles
+        for (Bundle bundle : bundles)
+        {
+
+            // Use the bitstream's name as the use parameter unless we
+            // are the original bundle. In this case rename it to
+            // content.
+            String use = bundle.getName();
+            boolean isContentBundle = false; // remember the content bundle.
+            boolean isDerivedBundle = false;
+            if ("ORIGINAL".equals(use))
+            {
+                use = "CONTENT";
+                isContentBundle = true;
+            }
+            if ("TEXT".equals(bundle.getName()) || "THUMBNAIL".equals(bundle.getName()))
+            {
+                isDerivedBundle = true;
+            }
+            if ("LICENSE".equals(bundle.getName()) && ! showLicense)
+            {
+                continue;
+            }
+
+            // /////////////////////////////////////
+            // Determine which bitstreams to include in bundle
+            Bitstream[] bitstreams = new Bitstream[0];
+
+            // If this is the THUMBNAIL bundle, and we are NOT including content bundle,
+            // Then assume this is an item summary page, and we can just include the main thumbnail.
+            if ("THUMBNAIL".equals(bundle.getName()) && !includeContentBundle)
+            {
+                Thumbnail thumbnail = ItemService.getThumbnail(context, item.getID(), false);
+                if(thumbnail != null) {
+                    bitstreams = new Bitstream[] { thumbnail.getThumb() };
+                }
+            }
+            else
+            {   // Default to including all bitstreams
+                bitstreams = bundle.getBitstreams();
+            }
+
+
+            // ///////////////////
+            // Start bundle's file group
+            attributes = new AttributeMap();
+            attributes.put("USE", use);
+            startElement(METS,"fileGrp",attributes);
+
+            for (Bitstream bitstream : bitstreams)
+            {
+                // //////////////////////////////
+                // Determine the file's IDs
+                String fileID = getFileID(bitstream);
+                
+                Bitstream originalBitstream = null;
+                // If we are looping through a derived bundle and content bundle is included,
+                // ensure each derived bitstream and original bitstream share the same groupID
+                if (isDerivedBundle && includeContentBundle)
+                {
+                    originalBitstream = findOriginalBitstream(item, bitstream);
+                }
+                String groupID = getGroupFileID((originalBitstream == null) ? bitstream : originalBitstream );
+
+                // Check if there were administrative metadata sections corresponding to this file
+                String admIDs = null;
+                if(fileAmdSecIDs.containsKey(fileID))
+                {
+                    admIDs = fileAmdSecIDs.get(fileID).toString();
+                }
+  
+                // Render the actual file & flocate elements.
+                renderFileWithAllowed(item, bitstream, fileID, groupID, admIDs);
+
+                // Remember all the viewable content bitstreams for later in the
+                // structMap.
+                if (isContentBundle)
+                {
+                    contentBitstreams.add(bitstream);
+                    if (bundle.getPrimaryBitstreamID() == bitstream.getID())
+                    {
+                        primaryBitstream = bitstream;
+                    }
+                }
+            }
+            
+            // ///////////////////
+            // End the bundle's file group
+            endElement(METS,"fileGrp");
+        }
+        
+        // //////////////////////
+        // End the file section
+        endElement(METS,"fileSec");
+    }
+
+    
+    /**
+     * Render the item's structural map. This includes a list of
+     * content bitstreams, those are bitstreams that are typically
+     * viewable by the end user.
+     *
+     * Example:
+     * <structMap TYPE="LOGICAL" LABEL="DSpace">
+     *   <div TYPE="DSpace Item" DMDID="space-separated list of ids">
+     *     <fptr FILEID="primary bitstream"/>
+     *     ... a div for each content bitstream.
+     *   </div>
+     * </structMap>
+     */
+    protected void renderStructureMap() throws SQLException, SAXException
+    {
+        AttributeMap attributes;
+        
+        // ///////////////////////
+        // Start a new structure map
+        attributes = new AttributeMap();
+        attributes.put("TYPE", "LOGICAL");
+        attributes.put("LABEL", "DSpace");
+        startElement(METS,"structMap",attributes);
+
+        // ////////////////////////////////
+        // Start the special first division
+        attributes = new AttributeMap();
+        attributes.put("TYPE", "DSpace Item");
+        // add references to the Descriptive metadata
+        if (dmdSecIDS != null)
+        {
+            attributes.put("DMDID", dmdSecIDS.toString());
+        }
+        // add references to the Administrative metadata
+        if (amdSecIDS != null)
+        {
+            attributes.put("AMDID", amdSecIDS.toString());
+        }
+        startElement(METS,"div",attributes);
+        
+        // add a fptr pointer to the primary bitstream.
+        if (primaryBitstream != null)
+        {
+                // ////////////////////////////////
+                // Start & end a reference to the primary bitstream.
+                attributes = new AttributeMap();
+                String fileID = getFileID(primaryBitstream);
+                attributes.put("FILEID", fileID);
+                
+                startElement(METS,"fptr",attributes);
+                endElement(METS,"fptr");
+        }
+
+        for (Bitstream bitstream : contentBitstreams)
+        {
+                // ////////////////////////////////////
+                // Start a div for each publicly viewable bitstream
+                attributes = new AttributeMap();
+                attributes.put("ID", getGenericID("div_"));
+                attributes.put("TYPE", "DSpace Content Bitstream");
+                startElement(METS,"div",attributes);
+
+                // ////////////////////////////////
+                // Start a the actualy pointer to the bitstream FIXME: what?
+                attributes = new AttributeMap();
+                String fileID = getFileID(bitstream);
+                attributes.put("FILEID", fileID);
+                
+                startElement(METS,"fptr",attributes);
+                endElement(METS,"fptr");
+                
+                // ///////////////////////////////
+                // End the div
+                endElement(METS,"div");
+        }
+
+        // ////////////////////////////////
+        // End the special first division
+        endElement(METS,"div");
+        
+        // ///////////////////////
+        // End the structure map
+        endElement(METS,"structMap");
+    }
+    
+
+
+    /**
+     * Render any extra METS section. If the item contains a METS.xml document
+     * then all of that document's sections are included in this document's
+     * METS document.
+     */
+    protected void renderExtraSections() throws SAXException, SQLException, IOException
+    {
+        Boolean include = ConfigurationManager.getBooleanProperty("xmlui.bitstream.mets");
+        if (!include)
+        {
+            return;
+        }
+                
+                
+        Bundle[] bundles = item.getBundles("METADATA");
+
+        for (Bundle bundle : bundles)
+        {
+                Bitstream bitstream = bundle.getBitstreamByName("METS.xml");
+
+                if (bitstream == null)
+                {
+                    continue;
+                }
+
+                // ///////////////////////////////
+                // Send the actual XML content
+                try {
+                        SAXFilter filter = new SAXFilter(contentHandler, lexicalHandler, namespaces);
+                        // Allow the basics for XML
+                        filter.allowIgnorableWhitespace().allowCharacters().allowCDATA().allowPrefixMappings();
+                        // Sp@ecial option, only allow elements below the second level to pass through. This
+                        // will trim out the METS declaration and only leave the actual METS parts to be
+                        // included.
+                        filter.allowElements(1);
+                        
+                        
+                        XMLReader reader = XMLReaderFactory.createXMLReader();
+                        reader.setContentHandler(filter);
+                        reader.setProperty("http://xml.org/sax/properties/lexical-handler", filter);
+                        reader.parse(new InputSource(bitstream.retrieve()));
+                }
+                        catch (AuthorizeException ae)
+                        {
+                                // just ignore the authorize exception and continue on
+                                // without parsing the xml document.
+                        }
+        }
+    }
+
+    
+    /**
+     * Checks which Bundles of current item a user has requested.
+     * If none specifically requested, then all Bundles are returned.
+     *
+     * @return List of enabled bundles
+     */
+    protected List<Bundle> findEnabledBundles() throws SQLException
+    {
+        // Check if the user is requested a specific bundle or
+        // the all bundles.
+        List<Bundle> bundles;
+        if (fileGrpTypes.size() == 0)
+        {
+            bundles = Arrays.asList(item.getBundles());
+        }
+        else
+        {
+                bundles = new ArrayList<Bundle>();
+                for (String fileGrpType : fileGrpTypes)
+                {
+                        for (Bundle newBundle : item.getBundles(fileGrpType))
+                        {
+                                bundles.add(newBundle);
+                        }
+                }
+        }
+    
+        return bundles;
+    }
+    
+
+    /**
+     * For a bitstream that's a thumbnail or extracted text, find the
+     * corresponding bitstream it was derived from, in the ORIGINAL bundle.
+     *
+     * @param item
+     *            the item we're dealing with
+     * @param derived
+     *            the derived bitstream
+     *
+     * @return the corresponding original bitstream (or null)
+     */
+    protected static Bitstream findOriginalBitstream(Item item,Bitstream derived) throws SQLException
+    {
+        // FIXME: this method is a copy of the one found below. However, the
+        // original method is protected so we can't use it here. I think that
+        // perhaps this should be folded into the DSpace bitstream API. Until
+        // when a good final solution can be determined I am just going to copy
+        // the method here.
+        //
+        // return org.dspace.content.packager.AbstractMetsDissemination
+        // .findOriginalBitstream(item, derived);
+
+        Bundle[] bundles = item.getBundles();
+
+        // Filename of original will be filename of the derived bitstream
+        // minus the extension (ie everything from and including the last "." character)
+        String originalFilename = derived.getName().substring(0, derived.getName().lastIndexOf("."));
+
+        // First find "original" bundle
+        for (int i = 0; i < bundles.length; i++)
+        {
+            if ((bundles[i].getName() != null)
+                    && bundles[i].getName().equals("ORIGINAL"))
+            {
+                // Now find the corresponding bitstream
+                Bitstream[] bitstreams = bundles[i].getBitstreams();
+
+                for (int bsnum = 0; bsnum < bitstreams.length; bsnum++)
+                {
+                    if (bitstreams[bsnum].getName().equals(originalFilename))
+                    {
+                        return bitstreams[bsnum];
+                    }
+                }
+            }
+        }
+
+        // Didn't find it
+        return null;
+    }
+    /**
+     * Generate a METS file element for a given bitstream.
+     * 
+     * @param item
+     *            If the bitstream is associated with an item provide the item
+     *            otherwise leave null.
+     * @param bitstream
+     *            The bitstream to build a file element for.
+     * @param fileID
+     *            The unique file id for this file.
+     * @param groupID
+     *            The group id for this file, if it is derived from another file
+     *            then they should share the same groupID.
+     * @param admID
+     *            The IDs of the administrative metadata sections which pertain
+     *            to this file
+     */
+    
+    // FIXME: this method is a copy of the one inherited. However the
+    // original method is final so we must rename it.
+	protected void renderFileWithAllowed(Item item, Bitstream bitstream, String fileID, String groupID, String admID) throws SAXException
+	{
+		AttributeMap attributes;
+		
+		// //////////////////////////////
+    	// Determine the file attributes
+        BitstreamFormat format = bitstream.getFormat();
+        String mimeType = null;
+        if (format != null)
+        {
+            mimeType = format.getMIMEType();
+        }
+        String checksumType = bitstream.getChecksumAlgorithm();
+        String checksum = bitstream.getChecksum();
+        long size = bitstream.getSize();
+    	
+        // ////////////////////////////////
+        // Start the actual file
+        attributes = new AttributeMap();
+        attributes.put("ID", fileID);
+        attributes.put("GROUPID",groupID);
+        if (admID != null && admID.length()>0)
+        {
+            attributes.put("ADMID", admID);
+        }
+        if (mimeType != null && mimeType.length()>0)
+        {
+            attributes.put("MIMETYPE", mimeType);
+        }
+        if (checksumType != null && checksum != null)
+        {
+        	attributes.put("CHECKSUM", checksum);
+        	attributes.put("CHECKSUMTYPE", checksumType);
+        }
+        attributes.put("SIZE", String.valueOf(size));
+        startElement(METS,"file",attributes);
+        
+        
+        // ////////////////////////////////////
+        // Determine the file location attributes
+        String name = bitstream.getName();
+        String description = bitstream.getDescription();
+
+        
+        // If possible reference this bitstream via a handle, however this may
+        // be null if a handle has not yet been assigned. In this case reference the
+        // item its internal id. In the last case where the bitstream is not associated
+        // with an item (such as a community logo) then reference the bitstreamID directly.
+        String identifier = null;
+        if (item != null && item.getHandle() != null)
+        {
+            identifier = "handle/" + item.getHandle();
+        }
+        else if (item != null)
+        {
+            identifier = "item/" + item.getID();
+        }
+        else
+        {
+            identifier = "id/" + bitstream.getID();
+        }
+        
+        
+        String url = contextPath + "/bitstream/"+identifier+"/";
+        
+        // If we can put the pretty name of the bitstream on the end of the URL
+        try
+        {
+        	if (bitstream.getName() != null)
+            {
+                url += Util.encodeBitstreamName(bitstream.getName(), "UTF-8");
+            }
+        }
+        catch (UnsupportedEncodingException uee)
+        {
+            // just ignore it, we don't have to have a pretty
+            // name on the end of the URL because the sequence id will 
+        	// locate it. However it means that links in this file might
+        	// not work....
+        }
+        
+        url += "?sequence="+bitstream.getSequenceID();
+
+	// Test if we are allowed to see this item
+	String isAllowed = "n";
+	try {
+	    if (AuthorizeManager.authorizeActionBoolean(context, bitstream, Constants.READ)) {
+		isAllowed = "y";
+	    }
+	} catch (SQLException e) {/* Do nothing */}
+	
+	url += "&isAllowed=" + isAllowed;
+
+        // //////////////////////
+        // Start the file location
+        attributes = new AttributeMap();
+        AttributeMap attributesXLINK = new AttributeMap();
+        attributesXLINK.setNamespace(XLINK);
+        attributes.put("LOCTYPE", "URL");
+        attributesXLINK.put("type","locator");
+        attributesXLINK.put("title", name);
+        if (description != null)
+        {
+            attributesXLINK.put("label", description);
+        }
+        attributesXLINK.put("href", url);
+        startElement(METS,"FLocat",attributes,attributesXLINK);
+        
+
+        // ///////////////////////
+        // End file location
+        endElement(METS,"FLocate");
+        
+        // ////////////////////////////////
+        // End the file
+        endElement(METS,"file");
+	}
+}
diff --git a/dspace/modules/xmlui/src/main/resources/aspects/Discovery/i18n/messages.xml b/dspace/modules/xmlui/src/main/resources/aspects/Discovery/i18n/messages.xml
new file mode 100644
index 0000000000000000000000000000000000000000..9d1b6d5f88157ee0a7ade0fe670aa8b2db657a15
--- /dev/null
+++ b/dspace/modules/xmlui/src/main/resources/aspects/Discovery/i18n/messages.xml
@@ -0,0 +1,158 @@
+<?xml version="1.0"?>
+<!--
+
+    The contents of this file are subject to the license and copyright
+    detailed in the LICENSE and NOTICE files at the root of the source
+    tree and available online at
+
+    http://www.dspace.org/license/
+
+-->
+<catalogue xml:lang="en" xmlns:i18n="http://apache.org/cocoon/i18n/2.1" xmlns="http://apache.org/cocoon/i18n/2.1">
+
+    <!--
+		The format used by all keys is as follows
+
+		xmlui.<Aspect>.<Java Class>.<name>
+
+		There are a few exceptions to this naming format,
+		1) Some general keys are in the xmlui.general namespace
+		   because they are used very frequently.
+		2) Some general keys which are specific to a particular aspect
+		   may be found at xmlui.<Aspect> without specifiying a
+		   particular java class.
+		-->
+
+
+    <!-- org.dspace.app.xmlui.artifactbrowser.AbstractSearch.java -->
+
+
+
+
+    <!-- org.dspace.app.xmlui.artifactbrowser.AdvancedSearch.java -->
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_dc.contributor.author_filter">Author</message>
+
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_dc.subject_filter">Subject</message>
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_dc.type_filter">Content Type</message>
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_dc.date.issued">Date Issued</message>
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_dateIssued">Date Issued</message>
+
+
+    <!-- Site Leve Recently Added Content -->
+    <message key="xmlui.ArtifactBrowser.SiteViewer.head_recent_submissions">Recently Added</message>
+
+    <message key="xmlui.ArtifactBrowser.AbstractRecentSubmissionTransformer.recent_submissions_more">View more</message>
+    <message key="xmlui.Discovery.RecentSubmissions.RecentSubmissionTransformer.head">{0}: Recent submissions</message>
+    <message key="xmlui.Discovery.RecentSubmissions.RecentSubmissionTransformer.trail">Recent submissions</message>
+    <message key="xmlui.Discovery.RecentSubmissions.RecentSubmissionTransformer.recent.head">Recently added</message>
+
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_type_filter">Kind</message>
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_publisher_filter">Publisher</message>
+
+
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.sort_by.ispartof">Parent</message>
+
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.group_by">Group Results By</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.group_by.none">None</message>
+
+
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.group_by.publication_grp">Publication</message>
+
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_location.comm">Community</message>
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_location.coll">Collection</message>
+
+
+    <message key="xmlui.ArtifactBrowser.AdvancedSearch.type_dc.relation.ispartofseries_filter">Series</message>
+
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_dc.contributor.author_browse">Browsing by: Author</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_dc.title_browse">Browsing by: Title</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_dc.subject_browse">Browsing by: Subject</message>
+        
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_dc.description.abstract_browse">Browsing by: Abstract</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_series_browse">Browsing by: Series</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_sponsor_browse">Browsing by: Sponsor</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_identifier_browse">Browsing by: Identifier</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_language_browse">Browsing by: Language (ISO)</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_keyword_browse">Browsing by: Keyword</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_taxon_browse">Browsing by: Scientific Name</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_contributor_browse">Browsing by: Contributor</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_creator_browse">Browsing by: Creator</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_subject_browse">Browsing by: Subject</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_description_browse">Browsing by: Description</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_relation_browse">Browsing by: Relation</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_mime_browse">Browsing by: Mime-Type</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_other_browse">Browsing by: Other Contributor</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_advisor_browse">Browsing by: Advisor</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_department_browse">Browsing by: Department</message>
+    <message key="xmlui.ArtifactBrowser.AbstractSearch.type_dateissued_dt_browse">Browsing by: Issue date</message>
+
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.author">Author</message>
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.title">Title</message>
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.subject">Subject</message>
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.dateIssued">Date issued</message>
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.orcidid">ORCID iD</message>
+
+
+    <message key="xmlui.dri2xhtml.structural.pagination-info.nototal">Now showing items {0}-{1}</message>
+
+    <message key="xmlui.Discovery.AbstractSearch.type_author">Filter by: Author</message>
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.author">Author</message>
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.author_filter">Author</message>
+    <message key="xmlui.Discovery.AbstractSearch.type_subject">Filter by: Subject</message>
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.subject">Subject</message>
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.subject_filter">Subject</message>
+    <message key="xmlui.ArtifactBrowser.SimpleSearch.filter.dateIssued.year">Date Issued</message>
+
+
+    <message key="xmlui.Discovery.AbstractSearch.startswith">Starts with</message>
+    <message key="xmlui.Discovery.AbstractSearch.startswith.help">Or enter first few letters:</message>
+
+    <message key="xmlui.Discovery.AbstractSearch.sort_by.head">Sort Options:</message>
+    <message key="xmlui.Discovery.AbstractSearch.sort_by.relevance">Relevance</message>
+    <message key="xmlui.Discovery.AbstractSearch.sort_by.dc.title_sort_desc">Title Desc</message>
+    <message key="xmlui.Discovery.AbstractSearch.sort_by.dc.date.issued_dt_desc">Issue Date Desc</message>
+
+    <message key="xmlui.Discovery.AbstractSearch.sort_by.dc.title_sort_asc">Title Asc</message>
+    <message key="xmlui.Discovery.AbstractSearch.sort_by.dc.date.issued_dt_asc">Issue Date Asc</message>
+
+    <message key="xmlui.Discovery.AbstractSearch.rpp">Results Per Page:</message>
+
+
+    <message key="xmlui.Discovery.AbstractSearch.filters.controls.add-filter">Add Filter</message>
+    <message key="xmlui.Discovery.AbstractSearch.filters.controls.apply-filters">Apply</message>
+    <message key="xmlui.Discovery.AbstractSearch.filters.controls.remove-filter">Remove</message>
+    <message key="xmlui.Discovery.AbstractSearch.filters.controls.new-filters.head">New Filters:</message>
+    <message key="xmlui.Discovery.AbstractSearch.filters.controls.current-filters.head">Current Filters:</message>
+    <message key="xmlui.Discovery.AbstractSearch.filters.display">Add filters</message>
+
+    <message key="xmlui.discovery.SearchFacetFilter.no-results">No filter values found</message>
+
+    <message key="xmlui.discovery.AbstractFiltersTransformer.filters.head">Discover</message>
+    <message key="xmlui.discovery.AbstractFiltersTransformer.filters.view-more">... View More</message>
+
+
+    <message key="xmlui.Discovery.SimpleSearch.search_scope">Search</message>
+    <message key="xmlui.discovery.SimpleSearch.search_label">Search</message>
+    <message key="xmlui.Discovery.SimpleSearch.filter_head">Filters</message>
+    <message key="xmlui.Discovery.SimpleSearch.filter_help">Use filters to refine the search results.</message>
+
+    <message key="xmlui.Discovery.SimpleSearch.filter.contains">Contains</message>
+    <message key="xmlui.Discovery.SimpleSearch.filter.equals">Equals</message>
+    <message key="xmlui.Discovery.SimpleSearch.filter.authority">ID</message>
+	<message key="xmlui.Discovery.SimpleSearch.filter.notcontains">Not Contains</message>
+    <message key="xmlui.Discovery.SimpleSearch.filter.notequals">Not Equals</message>
+    <message key="xmlui.Discovery.SimpleSearch.filter.notauthority">Not ID</message>
+    
+    <message key="xmlui.Discovery.RelatedItems.head">Related items</message>
+    <message key="xmlui.Discovery.RelatedItems.help">Showing items related by title, author, creator and subject.</message>
+
+    <message key="xmlui.Discovery.AbstractSearch.head1_community">Showing {0} out of a total of {1} results for community: {2}. <span class="searchTime">({3} seconds)</span></message>
+   	<message key="xmlui.Discovery.AbstractSearch.head1_collection">Showing {0} out of a total of {1} results for collection: {2}. <span class="searchTime">({3} seconds)</span></message>
+   	<message key="xmlui.Discovery.AbstractSearch.head1_none">Showing {0} out of a total of {1} results. <span class="searchTime">({2} seconds)</span></message>
+
+    <message key="xmlui.Discovery.AbstractSearch.head2">Communities or Collections matching your query</message>
+   	<message key="xmlui.Discovery.AbstractSearch.head3">Items matching your query</message>
+
+   	<message key="xmlui.Discovery.SimpleSearch.did_you_mean">Did you mean: </message>
+
+</catalogue>
diff --git a/dspace/modules/xmlui/src/main/webapp/themes/Mirage/Mirage.xsl b/dspace/modules/xmlui/src/main/webapp/themes/Mirage/Mirage.xsl
new file mode 100644
index 0000000000000000000000000000000000000000..4fb4b101216f098332c79042125bb2aea8a26b19
--- /dev/null
+++ b/dspace/modules/xmlui/src/main/webapp/themes/Mirage/Mirage.xsl
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+
+    The contents of this file are subject to the license and copyright
+    detailed in the LICENSE and NOTICE files at the root of the source
+    tree and available online at
+
+    http://www.dspace.org/license/
+
+-->
+<!--
+    TODO: Describe this XSL file
+    Author: Alexey Maslov
+
+-->
+
+<xsl:stylesheet xmlns:i18n="http://apache.org/cocoon/i18n/2.1"
+	xmlns:dri="http://di.tamu.edu/DRI/1.0/"
+	xmlns:mets="http://www.loc.gov/METS/"
+	xmlns:xlink="http://www.w3.org/TR/xlink/"
+	xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"
+	xmlns:dim="http://www.dspace.org/xmlns/dspace/dim"
+	xmlns:xhtml="http://www.w3.org/1999/xhtml"
+	xmlns:mods="http://www.loc.gov/mods/v3"
+	xmlns:dc="http://purl.org/dc/elements/1.1/"
+	xmlns="http://www.w3.org/1999/xhtml"
+	exclude-result-prefixes="i18n dri mets xlink xsl dim xhtml mods dc">
+
+    <xsl:import href="../dri2xhtml-alt/dri2xhtml.xsl"/>
+    <xsl:import href="lib/xsl/core/global-variables.xsl"/>
+    <xsl:import href="lib/xsl/core/page-structure.xsl"/>
+    <xsl:import href="lib/xsl/core/navigation.xsl"/>
+    <xsl:import href="lib/xsl/core/elements.xsl"/>
+    <xsl:import href="lib/xsl/core/forms.xsl"/>
+    <xsl:import href="lib/xsl/core/attribute-handlers.xsl"/>
+    <xsl:import href="lib/xsl/core/utils.xsl"/>
+    <xsl:import href="lib/xsl/aspect/general/choice-authority-control.xsl"/>
+    <xsl:import href="lib/xsl/aspect/administrative/administrative.xsl"/>
+    <xsl:import href="lib/xsl/aspect/artifactbrowser/item-list.xsl"/>
+    <xsl:import href="lib/xsl/aspect/artifactbrowser/item-view.xsl"/>
+    <xsl:import href="lib/xsl/aspect/artifactbrowser/community-list.xsl"/>
+    <xsl:import href="lib/xsl/aspect/artifactbrowser/collection-list.xsl"/>
+    <xsl:import href="lib/xsl/additions.xsl"/>
+    <xsl:output indent="yes"/>
+    
+
+</xsl:stylesheet>
diff --git a/dspace/modules/xmlui/src/main/webapp/themes/Mirage/images/orcid_icon.png b/dspace/modules/xmlui/src/main/webapp/themes/Mirage/images/orcid_icon.png
new file mode 100644
index 0000000000000000000000000000000000000000..ef109145bc74c3f884d712ae2782ccedd29d096d
GIT binary patch
literal 1261
zcmbVMTWs4@7<LKtvaPIxQ4tX0;39;yB|f&}*f9x9V#hRN>8dnhK|*4#ebRWX?aX!;
zw;<GRg8@QQ1ur0ws02u`ham<+NC;MTsVGBz7#d<oyj7hTNU#<O#%&z8N#UW|1D5P_
z{&W8C`|p0Pzwe>W4R>rH2%<CJD;M$F6};`O_<Q&AH5D&mFIV;k?21=c9Ykbwdk}%V
zsScqcQuVR@b0|p=p^8x|d*#9|QM1jc8t6oQvxd<Gk=)_eRBae}U=R%%R*L-T<C7#X
z^c1;=E5JfcLRF)8+(855eI;#tSWD>Sjt4=~7cqf}JQeunh~<iYid^9p@jf`FNU);f
z4X4Oer^<zXAlVKATogt$7>6KEM`<?3^Za(eKpIkzp=c&T^CHWL5Q4@-Vr!0G5sR|Y
zu!W@*S@pb{NKy5AJz8g@wlhT0i9{mcV3-Kjh`3{xr}`1g?P)T|$kiO9<{7pH0!DSv
z9`#Zr_H;D_vsNgq5nFB}Q8;Ckuhu9!3MtbJ;#$#my(0S8jdiu%(pU{qMdaF}j)v<|
z>1l#-?yherP{iJdyBz};MIDiCZPY}TmzPr{zKQCFE^@piGf;pG$H2Hi<M3lrg5_vd
ziOU&*<C`4oVOds^gsc)%6pp9q94+t}A(s_|xWZ>8877+8yybeTrJ<%>1KVw2+3R9O
z$w8`TJ0;s5X?8$=)%I++YS(}?z=49Q8CD<%<ynnZMvid+>55~UU?snzv5tL3;uV_a
zV~}se%_%vVPta1F&cT>0lMSr?e{x1)XQ-e#{?jbYBiw<(cCGcXur@r%!V}}*(O5oI
z{e&P|?#j!VlK<_Xo(`RxfAl`$9UmM>za$c8Hooz~Q7YZ7%je%F-uycBUQ6hyTFbMc
z$<`FH|K+LJ>utu-SaNoH+bduGy!chyW33b0h0Pa2G_mh}B6KB996K_(<?^MgFs#3t
z`>m^Tf?kGy{{F{J-%ZQi)rrqC$N%D<*+wlgKc2jJj##>x@t3Z2ot`@q`MmWkt9F=M
z;nnHx(@V>bY<j}J1lyfs%<Xeq!NU*0EkAs}=ka;^HUFD0rte>Pnw*!jGn1W}wtK^1
zRy%xQB6Mcohg0uXKDuVzx%2XkXHR9HZ0UIZwuQ3rtA4|YU$RPdXL7fE%WUuYnT3(|
zjfc|U@ASdN&HbsV^x?`Tsj8@eWW%SJTYKKR7zQ)MJumM4)bIFUSMUSM=lbO1*}Vt<
E0ecprk^lez

literal 0
HcmV?d00001

diff --git a/dspace/modules/xmlui/src/main/webapp/themes/Mirage/lib/css/style.css b/dspace/modules/xmlui/src/main/webapp/themes/Mirage/lib/css/style.css
new file mode 100644
index 0000000000000000000000000000000000000000..3540e5fa2c0a91fd8198628adcfac2ccf35ed37c
--- /dev/null
+++ b/dspace/modules/xmlui/src/main/webapp/themes/Mirage/lib/css/style.css
@@ -0,0 +1,1478 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+/*
+ * style.css
+ *
+ * Primary Styles
+ */
+
+/*Font size percentages based on the tables at developer.yahoo.com/yui/fonts/ */
+h1 {
+    font-size: 182%;
+    color: #1F3F5E;
+    text-align: justify;
+}
+
+h2{
+    font-size: 123.1%;
+}
+
+h3 {
+    font-size: 116%;
+}
+
+h4 {
+    font-size: 108%;
+}
+
+h5, h6 {
+    font-size: 100%;
+}
+
+/*fix for firefox in os x, where selects get the incorrect
+height if it's not explicitly set this shouldn't be noticeable in
+other browsers*/
+select {
+    height: 20px;
+}
+
+select.multiple {
+    height: auto;
+}
+
+#ds-header-wrapper {
+    background-color: #1F3F5E;
+    color: white;
+    min-width: 950px;
+}
+
+#ds-header-logo-link {
+    text-decoration: none;
+    cursor: pointer;
+}
+
+#ds-header-logo {
+    float:left;
+    width: 48px;
+    height: 50px;
+    margin-top: 10px;
+    background: url('../../images/dspace-logo-only.png');
+    background-repeat: no-repeat;
+    background-color: transparent;
+    margin-right: 15px;
+}
+
+#ds-header-logo-text {
+    font-size: 400%;
+    color: white;
+    line-height: 70px;
+    font-weight: normal;
+    vertical-align: middle;
+    float: left;
+}
+
+#ds-user-box {
+    right: 0;
+    top: 17px;
+    position: absolute;
+    color: white;
+}
+
+#ds-language-selection {
+    right: 0;
+    top: 40px;
+    position: absolute;
+    color: white;
+}
+
+#ds-user-box a, #ds-language-selection a {
+    color: white;
+}
+
+#ds-trail-wrapper {
+    background-color: #b6c8d9;
+    margin: 0;
+    padding: 0;
+    border-top: 1px solid #9cacba;
+    border-bottom: 1px solid #9cacba;
+    min-width: 950px;
+}
+
+#ds-trail {
+    list-style: none;
+    line-height: 138.5%;
+    margin: 0;
+    padding: 3px 0;
+}
+
+#ds-trail li {
+    display: inline;
+    color: #1F3F5E;
+    margin-right: 5px;
+}
+
+#ds-trail a {
+    color: #1F3F5E;
+}
+
+#no-js-warning,
+#ds-trail,
+#ds-header,
+#ds-footer,
+#ds-content {
+    width: 950px;
+    margin: auto;
+    position: relative;
+}
+
+/*ie6 uses quirks mode for strict xhtml pages, and in quirks mode margin: auto; doesn't center things*/
+.ie6 #no-js-warning-wrapper,
+.ie6 #ds-trail-wrapper,
+.ie6 #ds-header-wrapper,
+.ie6 #ds-footer-wrapper,
+.ie6 #ds-content-wrapper {
+    text-align: center;
+}
+
+.ie6 #ds-trail,
+.ie6 #ds-header,
+.ie6 #ds-footer,
+.ie6 #ds-content {
+    margin: 0;
+    text-align: left;
+}
+
+#ds-footer-wrapper {
+    margin-top: 40px;
+}
+
+#ds-footer {
+    border-top: 1px solid #9CACBA;
+    padding-top: 10px;
+    font-size: 93%;
+    line-height: 1.6em;
+}
+
+#ds-footer-left {
+    float: left;
+}
+
+#ds-footer-right {
+    float:right;
+}
+
+#ds-footer-right span.theme-by{
+    display: inline-block;
+    vertical-align: top;
+}
+
+#ds-footer-logo-link {
+    text-decoration:none;
+    line-height: 40px;
+    cursor: pointer;
+}
+
+#ds-footer-logo {
+    display: inline-block;
+    background: url('../../images/@mirelogo-small.png');
+    background-repeat: no-repeat;
+    width: 79px;
+    height: 40px;
+}
+
+#ds-footer-links {
+    clear: left;
+}
+
+.ie6 #ds-footer-links {
+    display: inline;
+}
+
+/*make transparent PNGs invisible in IE6 until PNG-fix is applied*/
+.ie6 #ds-header-logo,
+.ie6 #ds-footer-logo {
+    visibility: hidden;
+}
+
+
+#ds-body {
+    float: left;
+    width: 675px;
+    padding-top: 10px;
+}
+
+#ds-options-wrapper {
+    float: right;
+    width: 249px;
+    padding-top:10px;
+}
+
+#ds-options {
+    padding: 0;
+}
+
+h1.ds-option-set-head {
+    margin-top: 20px;
+    background-color: #f0f2f5;
+    padding: 3px 10px;
+    border: 1px solid #d8e8eb;
+    border-bottom: none;
+    font-size: 108%;
+}
+
+#ds-search-option-head{
+    margin-top: 0;
+}
+
+div.ds-option-set {
+    border: 1px solid #d8e8eb;
+    border-top: none;
+}
+
+div.ds-option-set ul {
+    list-style: none;
+    margin-left: 10px;
+    padding-top: 5px;
+    padding-bottom: 5px;
+}
+
+div.ds-option-set .ds-sublist-head {
+    font-weight: normal;
+    font-size: 100%;
+}
+
+div.ds-option-set ul.sublist {
+    margin-left: 20px;
+    padding-top: 0;
+    padding-bottom: 0;
+}
+
+div#ds-feed-option li
+{
+    padding-top: 4px;
+}
+
+div#ds-feed-option a
+{
+    padding: 0px 0px 2px 20px;
+}
+
+#ds-search-option {
+    padding: 10px;
+}
+
+#ds-search-form {
+    margin-bottom: 10px;
+}
+
+#ds-search-form input.ds-text-field{
+    width: 169px;
+}
+
+#ds-search-form input.ds-button-field {
+    margin-left: 6px;
+}
+
+#ds-search-form input.ds-text-field,
+#ds-search-form input.ds-button-field{
+    margin-bottom: 10px;
+}
+
+p {
+    margin-bottom: 10px;
+}
+
+#aspect_eperson_EditProfile_list_form,
+.submission fieldset.ds-form-list,
+.administrative fieldset.ds-form-list {
+    margin-bottom: 25px;
+}
+
+.primary {
+    margin-top: 10px;
+    margin-bottom: 30px;
+}
+
+ol {
+    margin: 0;
+    list-style: none;
+}
+
+th,
+td {
+    padding: 5px;
+    vertical-align: middle;
+}
+
+.ds-button-field,
+#aspect_eperson_StartRegistration_list_registration-progress li {
+    background-color: #6d859c;
+    border: 1px solid #1F3F5E;
+    padding: 2px 5px;
+    color: #FFFFFF;
+    font-weight: bold;
+    cursor: pointer;
+}
+
+.ds-button-field[disabled="disabled"],
+.ds-button-field.disabled,
+li.button.disabled input {
+    opacity: 0.35;
+    cursor: auto;
+}
+
+#aspect_eperson_StartRegistration_list_registration-progress li {
+    cursor: default;
+}
+
+#aspect_eperson_StartRegistration_list_registration-progress li.arrow {
+    background-color: inherit;
+    border: none;
+    color: inherit;
+    font-weight: normal;
+}
+
+.ie6 #aspect_eperson_StartRegistration_list_registration-progress li.arrow,
+.ie7 #aspect_eperson_StartRegistration_list_registration-progress li.arrow {
+    background-color: #FFFFFF;
+    color: #444444;
+}
+
+.ie6 #aspect_eperson_StartRegistration_list_registration-progress li.arrow {
+    padding-top: 5px;
+}
+
+ul.ds-progress-list {
+    margin: 0 0 10px 0;
+    padding: 2px 0;
+    text-align: center;
+}
+
+ul.ds-progress-list li {
+    font-weight: bold;
+    overflow: hidden;
+    display: inline;
+    padding: 0;
+    margin: 0;
+    max-width: 400px;
+}
+
+ul.ds-progress-list li.button {
+        padding: 0;
+}
+
+ul.ds-progress-list li.button input.ds-button-field {
+        font-size: 77%;
+}
+
+.ie6 ul.ds-progress-list li.button input.ds-button-field,
+.ie7 ul.ds-progress-list li.button input.ds-button-field {
+    padding-left: 0;
+    padding-right: 0;
+}
+
+ul.ds-progress-list li.current input.ds-button-field,
+#aspect_eperson_StartRegistration_list_registration-progress li.current {
+    background-color: #499c73;
+    border: 1px solid #1f5e3f;
+}
+
+ul.ds-progress-list li.disabled input.ds-button-field
+#aspect_eperson_StartRegistration_list_registration-progress li.disabled {
+    background-color: #F0F2F5;
+    border: 1px solid #D8E8EB;
+    color: #444444;
+    cursor: default;
+}
+
+.ie6 .disabled,
+.ie6 li.disabled input,
+.ie7 .ds-button-field.disabled,
+.ie7 li.button.disabled input,
+.ie8 .ds-button-field.disabled,
+.ie8 li.button.disabled input {
+    filter: progid:DXImageTransform.Microsoft.Alpha(opacity = 50);
+    zoom: 1;
+    cursor: auto;
+}
+
+
+ul.ds-progress-list li.arrow {
+        border: none;
+        background: none;
+        font-size: 116%;
+        font-weight: normal;
+        margin-left: 3px;
+        margin-right: 3px;
+}
+
+.ie6 ul.ds-progress-list li.arrow {
+    height: 25px;
+    width: 25px;
+    margin: 0;
+}
+
+textarea.ds-textarea-field,
+input.ds-text-field,
+input.ds-file-field,
+input.ds-button-field,
+input.ds-password-field {
+    margin-bottom: 5px;
+    margin-top: 5px;
+    font-size: 93%;
+}
+
+textarea.ds-textarea-field,
+input.ds-text-field,
+input.ds-password-field {
+    padding: 3px;
+    border: 1px solid #AAAAAA;
+}
+
+.ie6 input.ds-text-field,
+.ie6 input.ds-password-field {
+    font-size: 85%;
+    height: 22px;
+}
+
+.submission .ds-form-list input.ds-text-field,
+.administrative .ds-form-list input.ds-text-field,
+textarea.ds-textarea-field {
+    width: 500px;
+}
+
+table textarea.ds-textarea-field {
+    width: 400px;
+}
+
+#aspect_administrative_item_EditItemMetadataForm_field_value {
+    width: 570px;
+}
+
+#aspect_administrative_registries_EditMetadataSchema_list_edit-schema-new-field-form .ds-text-field,
+#aspect_administrative_item_EditItemMetadataForm_field_language,
+.ds-composite-component input.ds-text-field {
+    width: auto;
+}
+
+textarea.ds-textarea-field:focus,
+input.ds-text-field:focus,
+input.input.ds-password-field:focus {
+    border-color: #5F9DE4;
+}
+
+/*
+ * Show a blue glow around a focused text field
+ * only target browsers that support rgba colors and boxshadows
+ * see http://www.modernizr.com/docs/
+ */
+.rgba.boxshadow textarea.ds-textarea-field:focus,
+.rgba.boxshadow input.ds-text-field:focus,
+.rgba.boxshadow input.ds-password-field:focus {
+    -moz-box-shadow:0 0 8px rgba(95, 158, 212, 0.5);
+    -webkit-box-shadow:0 0 8px rgba(95, 158, 212, 0.5);
+    box-shadow:0 0 8px rgba(95, 158, 212, 0.5);
+    border-color:rgba(95, 158, 212, 0.75);
+    outline:medium none;
+}
+
+span.error {
+    clear: both;
+    display: block;
+    color: #c22121;
+    font-size: 0.9em;
+    margin-top: 3px;
+}
+
+textarea.ds-textarea-field.error,
+input.ds-text-field.error,
+input.ds-password-field.error {
+    border-color: #c22121;
+    background-color: #fff2f2;
+}
+
+.rgba.boxshadow textarea.ds-textarea-field.error:focus,
+.rgba.boxshadow input.ds-text-field.error:focus,
+.rgba.boxshadow input.ds-password-field.error:focus {
+    -moz-box-shadow:0 0 8px rgba(194, 33, 33, 0.5);
+    -webkit-box-shadow:0 0 8px rgba(194, 33, 33, 0.5);
+    box-shadow:0 0 8px rgba(194, 33, 33, 0.5);
+    border-color:rgba(194, 33, 33, 0.75) !important;
+    outline:medium none;
+}
+
+
+.ds-form-list {
+    margin-top: 15px;
+}
+
+.submission h2,
+.ds-form-list legend{
+    font-size: 182%;
+    margin-bottom: 15px;
+    color: #1F3F5E;
+}
+
+.ds-form-item legend {
+    font-size: 100%;
+    margin:0;
+    color: inherit;
+}
+
+fieldset ol {
+    margin: 0;
+}
+
+li.ds-form-item {
+    list-style: none;
+    margin-bottom: 35px;
+    vertical-align: middle !important;
+    position: relative;
+    clear: left;
+}
+
+li.ds-form-item.last {
+    margin-bottom: 0;
+}
+
+li.ds-form-item .ds-form-label{
+    font-weight: bold;
+    font-size: 123.1%;
+}
+
+li.ds-form-item label.ds-composite-component{
+    display: block;
+    float: left;
+    font-size: 93%;
+    padding:0 8px 0 0;
+}
+
+li.ds-form-item label.ds-composite-component input.ds-text-field{
+    font-size: 100%;
+    width: 242px;
+}
+
+li.ds-form-item .ds-select-field {
+    margin-top: 5px;
+}
+
+.ds-add-button,
+label.ds-composite-component .ds-select-field {
+    margin-top: 6px;
+    margin-bottom: 6px;
+}
+
+li.ds-form-item label.ds-composite-component.last{
+    padding:0;
+}
+
+.ds-add-button {
+    vertical-align: top;
+    margin-left: 8px;
+}
+
+
+.ds-form-content input.ds-button-field {
+    font-size: 93%;
+}
+
+select#aspect_submission_submit_SelectCollectionStep_field_handle {
+    max-width: 350px;
+}
+
+#aspect_submission_StepTransformer_field_dc_date_issued_year,
+#aspect_submission_StepTransformer_field_dc_date_issued_day {
+    width: 50px;
+}
+
+#aspect_submission_StepTransformer_field_dc_identifier_value {
+    width: 130px;
+    margin-bottom: 0;
+}
+
+span.composite-help,
+span.field-help {
+    display: block;
+    font-size: 93%;
+    margin-top: 3px;
+    width: 506px;
+    text-align: justify;
+}
+
+.ds-checkbox-field input,
+.ds-radio-field input {
+    margin-left: 0;
+}
+
+.ds-checkbox-field label,
+.ds-radio-field label {
+    margin-right: 3px;
+}
+/*hide the double label for checkboxes & radio buttons*/
+.ds-checkbox-field legend,
+.ds-radio-field legend {
+    display: none;
+}
+
+.ds-previous-values {
+    margin-top: 10px;
+    clear: both;
+}
+
+#aspect_submission_Submissions_div_submissions .ds-static-div,
+.submission .ds-form-sublist ol {
+    background-color: #fafafa;
+    border: 1px solid #ebebeb;
+    margin-top: 3px;
+    margin-bottom: 30px;
+    padding: 10px;
+}
+
+#aspect_submission_Submissions_div_submissions table,
+#aspect_submission_Submissions_div_submissions table tr,
+#aspect_submission_Submissions_div_submissions table td,
+#aspect_submission_Submissions_div_submissions table th {
+    background-color: #FFFFFF;
+    border: 1px solid #9CACBA;
+}
+
+#aspect_submission_Submissions_div_submissions table tr.ds-table-header-row, 
+#aspect_submission_Submissions_div_submissions table tr.ds-table-header-row th {
+    background-color: #B6C8D9;
+    border: 1px solid #9CACBA;
+    
+}
+
+.submission .ds-form-sublist li.ds-form-item {
+    margin-bottom: 5px;
+}
+
+.submission .ds-form-sublist .ds-form-label {
+    font-weight: bold;
+}
+
+
+.administrative.tabbed ul.horizontal {
+    list-style: none;
+    margin: 15px 0 0;
+    border-bottom: 1px solid #9cacba;
+}
+
+.administrative.tabbed ul.horizontal li{
+    float: left;
+    border: 1px solid #9cacba;
+    padding: 5px;
+    margin-bottom: -1px;
+    margin-right: 7px;
+    border-bottom: none;
+}
+
+.administrative.tabbed ul.horizontal li a{
+    text-decoration: none;
+    color: #444444;
+}
+
+.administrative.tabbed ul.horizontal li.active-tab{
+    background-color: #fafafa;
+    z-index: 1;
+    font-weight: bold;
+}
+
+.pane {
+    padding: 10px;
+    clear: both;
+    background-color: #fafafa;
+    border: 1px solid #9cacba;
+    margin-bottom: 25px;
+    margin-top: 0;
+}
+
+.pane .ds-form-list {
+    margin-top: 0;
+}
+
+.administrative.tabbed .pane {
+    border-top: none;
+}
+
+.pagination,
+.pagination-masked {
+    padding: 7px;
+    background-color: #fafafa;
+    border: 1px solid #ebebeb;
+    line-height: 1em;
+    vertical-align:middle;
+}
+
+.pagination-links {
+    list-style: none;
+    float: right;
+    margin: 0;
+}
+
+.pagination-links li {
+    display: inline;
+    padding-left: 2px;
+    padding-right: 2px;
+}
+
+.current-page-link {
+    font-weight: bold;
+    color: #1F3F5E;
+}
+
+.current-page-link a{
+    color: #1F3F5E;
+}
+
+.pagination-info {
+    float: left;
+    margin:0;
+}
+
+.pagination-masked.top {
+    margin-top: 5px;
+}
+
+.ds-artifact-list {
+    list-style: none;
+    margin: 0;
+    line-height: 153.9%;
+}
+
+.file-wrapper,
+.ds-artifact-item {
+    padding-top: 15px;
+    padding-bottom: 15px;
+}
+
+.ds-artifact-item.collection,
+.ds-artifact-item.community {
+    padding-top: 1px;
+    padding-bottom: 1px;
+}
+
+.community .artifact-title a {
+    font-weight: bold;
+}
+
+.collection .artifact-title a {
+    font-weight: normal;
+}
+
+#aspect_artifactbrowser_CommunityBrowser_div_comunity-browser .short-description, #aspect_discovery_SiteRecentSubmissions_div_site-home .short-description {
+    display: none;
+}
+
+#aspect_artifactbrowser_SimpleSearch_div_search-results li, #aspect_discovery_SimpleSearch_div_search-results li, #aspect_artifactbrowser_AdvancedSearch_div_search-results li {
+    padding-top: 15px;
+    padding-bottom: 15px;
+}
+
+#aspect_artifactbrowser_SimpleSearch_div_search-results ul, #aspect_discovery_SimpleSearch_div_search-results ul, #aspect_artifactbrowser_AdvancedSearch_div_search-results ul {
+    margin-bottom: 25px;
+}
+
+.artifact-title {
+    font-size: 123.1%;
+}
+
+.result-query,
+.artifact-info {
+    color: gray;
+}
+
+.artifact-abstract {
+    text-align: justify;
+}
+
+ul.alphabet {
+    list-style: none;
+    margin: 0;
+}
+
+ul.alphabet li {
+    display:inline;
+}
+
+#aspect_eperson_PasswordLogin_list_password-login .ds-form-item {
+    float: left;
+    margin: 0;
+    margin-right: 25px;
+}
+
+#aspect_eperson_PasswordLogin_list_password-login .ds-form-item a {
+    margin-left: 20px;
+}
+
+#aspect_eperson_PasswordLogin_list_password-login .ds-form-item.last {
+    clear: left;
+}
+
+
+#aspect_eperson_PasswordLogin_list_password-login .ds-form-item.last .ds-form-label{
+    display: none;
+}
+
+td select.ds-select-field {
+    margin-left: 5px;
+}
+
+form.search,
+div.discoverySearchBox
+{
+    background-color: #fafafa;
+    border: 1px solid #ebebeb;
+    padding: 10px;
+    margin-bottom: 15px;
+}
+
+form.search label,
+div.discoverySearchBox label
+{
+    font-weight: bold;
+}
+
+form.search p.ds-paragraph.button-list,
+div.discoverySearchBox p.ds-paragraph.button-list
+{
+    text-align: center;
+    margin: 0;
+}
+
+form.search fieldset,
+div.discoverySearchBox fieldset {
+    margin: 0;
+}
+
+form.search .ds-form-item,
+div.discoverySearchBox .ds-form-item
+{
+    margin: 0;
+    padding-bottom: 5px;
+}
+
+form.search .ds-form-item select,
+div.discoverySearchBox .ds-form-item select
+{
+    margin-top: 0;
+}
+
+form.search label.ds-composite-component .ds-select-field,
+div.discoverySearchBox label.ds-composite-component .ds-select-field
+{
+    margin-top: 6px;
+}
+
+form.search .ds-form-item label,
+div.discoverySearchBox .ds-form-item label
+{
+    font-size: 100%;
+}
+
+form.search .ds-form-content,
+div.discoverySearchBox .ds-form-content
+{
+    display: inline;
+}
+
+form.search table input.ds-text-field,
+div.discoverySearchBox table input.ds-text-field
+{
+   margin: 0;
+}
+
+form.search .field-help,
+div.discoverySearchBox .field-help
+{
+    margin: 3px 0;
+}
+
+.collection .search,
+.community .search {
+    margin-top: 25px;
+}
+
+#aspect_discovery_CollectionSearch_p_search-query,
+#aspect_discovery_CommunitySearch_p_search-query{
+    margin-bottom:0;
+}
+
+.result-query {
+    margin-bottom: 30px;
+}
+
+#aspect_administrative_registries_EditMetadataSchema_table_metadata-schema-edit-existing-fields,
+#aspect_administrative_registries_MetadataRegistryMain_table_metadata-registry-main-table,
+#aspect_administrative_registries_FormatRegistryMain_table_bitstream-format-registry,
+#aspect_submission_Submissions_table_unfinished-submissions,
+#aspect_submission_Submissions_table_submissions-inprogress,
+#aspect_submission_Submissions_table_completed-submissions,
+table.detailtable {
+    margin-top: 10px;
+    margin-bottom: 10px;
+    border-collapse: collapse;
+}
+
+#aspect_administrative_registries_EditMetadataSchema_table_metadata-schema-edit-existing-fields tr,
+#aspect_administrative_registries_MetadataRegistryMain_table_metadata-registry-main-table tr,
+#aspect_administrative_registries_FormatRegistryMain_table_bitstream-format-registry tr,
+#aspect_submission_Submissions_table_unfinished-submissions tr,
+#aspect_submission_Submissions_table_submissions-inprogress tr,
+#aspect_submission_Submissions_table_completed-submissions tr,
+table.detailtable tr {
+    line-height: 1.6em;
+    border: 1px solid #ebebeb;
+}
+
+#aspect_administrative_registries_EditMetadataSchema_table_metadata-schema-edit-existing-fields tr.even,
+#aspect_administrative_registries_MetadataRegistryMain_table_metadata-registry-main-table tr.even,
+#aspect_administrative_registries_FormatRegistryMain_table_bitstream-format-registry tr.even,
+#aspect_submission_Submissions_table_unfinished-submissions tr.even,
+#aspect_submission_Submissions_table_submissions-inprogress tr.even,
+#aspect_submission_Submissions_table_completed-submissions tr.even,
+table.detailtable tr.even {
+    background-color: #fafafa;
+}
+
+#aspect_administrative_registries_EditMetadataSchema_table_metadata-schema-edit-existing-fields td,
+#aspect_administrative_registries_MetadataRegistryMain_table_metadata-registry-main-table td,
+#aspect_administrative_registries_FormatRegistryMain_table_bitstream-format-registry td,
+#aspect_submission_Submissions_table_unfinished-submissions td,
+#aspect_submission_Submissions_table_submissions-inprogress td,
+#aspect_submission_Submissions_table_completed-submissions td,
+table.detailtable td {
+    padding: 5px 10px;
+    text-align: justify;
+    border: 1px solid #ebebeb;
+    vertical-align: top;
+}
+
+#aspect_administrative_registries_EditMetadataSchema_table_metadata-schema-edit-existing-fields tr.ds-table-header-row,
+#aspect_administrative_registries_MetadataRegistryMain_table_metadata-registry-main-table tr.ds-table-header-row,
+#aspect_administrative_registries_FormatRegistryMain_table_bitstream-format-registry tr.ds-table-header-row,
+#aspect_submission_Submissions_table_unfinished-submissions tr.ds-table-header-row,
+#aspect_submission_Submissions_table_submissions-inprogress tr.ds-table-header-row,
+#aspect_submission_Submissions_table_completed-submissions tr.ds-table-header-row {
+    border: none;
+}
+
+
+table.detailtable td.label-cell {
+    font-weight: bold;
+    text-align: left;
+    width: 100px;
+}
+
+div.item-summary-view-metadata h1,
+div.item-summary-view-metadata h2 {
+    line-height: normal;
+}
+
+div.item-summary-view-metadata {
+    text-align: justify;
+    line-height: 161.6%;
+    margin-bottom: 30px;
+}
+
+div.simple-item-view-authors {
+    font-size: 123.1%;
+    font-weight: bold;
+    border-bottom:1px solid #D8E8EB;
+    padding-bottom: 2px;
+    margin-bottom: 20px;
+    text-align: justify;
+}
+
+div.simple-item-view-authors span{
+    text-align: justify;
+}
+
+#aspect_artifactbrowser_ItemViewer_div_item-view h2,
+div.item-summary-view-metadata p.item-view-toggle-bottom,
+div.simple-item-view-description {
+    margin-top: 20px;
+}
+
+#aspect_artifactbrowser_ItemViewer_div_item-view h2,
+div.simple-item-view-description h3{
+    border-bottom:1px solid #D8E8EB;
+    margin-bottom: 3px;
+}
+
+#aspect_artifactbrowser_ItemViewer_div_item-view h2 {
+    margin-bottom: 10px;
+}
+
+div.spacer{
+    height: 15px;
+}
+
+.thumbnail-wrapper,
+.file-metadata,
+.file-link {
+    float: left;
+    margin-right: 15px;
+}
+
+.item-metadata {
+    float: left;
+}
+
+.file-metadata {
+    width: 300px;
+}
+
+.file-metadata span,
+.item-metadata span {
+    float: left;
+}
+
+.item-metadata span.content span {
+    float: none;
+}
+
+.file-metadata span.bold,
+.item-metadata span.bold {
+    width: 80px;
+    clear: left;
+    text-align: right;
+    margin-right: 7px;
+}
+
+#ds-system-wide-alert,
+.notice {
+    padding: 10px;
+    margin: 10px 0;
+    border: 1px solid #bfc221;
+    background-color: #fffff2;
+}
+
+.notice.success
+{
+    border-color: #21c221;
+    background-color: #f2fff2;
+}
+
+#ds-system-wide-alert,
+.notice.failure
+{
+    border-color: #c22121;
+    background-color: #fff2f2;
+}
+
+#ds-system-wide-alert p {
+    margin: 0;
+}
+
+#aspect_artifactbrowser_CommunityViewer_div_community-home h2,
+#aspect_artifactbrowser_CollectionViewer_div_collection-home h2 {
+    margin-top: 30px;
+    border-bottom:1px solid #D8E8EB;
+    margin-bottom: 3px;
+}
+
+.ds-logo-wrapper {
+    display: block;
+}
+
+#aspect_administrative_item_FindItemForm_list_find-item-form .ds-form-item {
+    margin:0;
+}
+
+#aspect_administrative_registries_EditMetadataSchema_div_edit-schema-new-field  .ds-form-item.last {
+    margin-top: -25px;
+}
+
+#no-js-warning {
+    margin-top: 15px;
+    margin-bottom: 10px;
+    text-align: center;
+}
+
+form.discover-search-box{
+    margin-bottom: 10px;
+}
+
+
+form.discover-sort-box select{
+    margin: 0 4px;
+}
+
+.hidden {
+    display:none;
+    visibility:hidden;
+}
+
+.pre {
+    white-space:pre;
+}
+
+.icon-button{
+    padding:4px;
+    cursor: pointer;
+    margin: 2px;
+    background-color: #6D859C;
+    border: 1px solid #1F3F5E;
+    text-indent: -1000px;
+    width: 30px;
+    height: 30px;
+    display:block;
+    /*Required for IE*/
+    font-size: 0;
+    line-height: 0;
+}
+
+.icon-button.arrowUp{
+    background-image: url(../../images/arrow_up_ffffff_16x16.png);
+    background-repeat: no-repeat;
+    background-position: center center;
+}
+
+.icon-button.arrowDown{
+    background-image: url(../../images/arrow_down_ffffff_16x16.png);
+    background-repeat: no-repeat;
+    background-position: center center;
+}
+
+/* FOR CC License */
+span.floatleft {
+	border:none;
+	float:right;
+	display:inline;
+}
+
+/* FOR CC PAGE to GROUP ITEMS horizontally */
+ul.horizontal li span.bold a { color: black; }
+
+/* group items horizontally in a list */
+
+ul.horizontalVanilla
+{
+font-weight: bold;
+list-style-type: none;
+padding: 0px;
+padding-left: 0px;
+padding-bottom: 15px;
+border-left: 1px solid white;
+border-right: 1px solid white;
+margin: 10px -1px 5px -1px;
+width: inherit;
+}
+
+ul.horizontalVanilla li
+{
+float: left;
+height: 100%;
+background-color: rgb(255, 255, 255);
+margin: 2px 2px 0px 2px;
+/* border: 1px solid rgb(240, 240, 210); */
+}
+
+/* Controlled vocabulary support css START*/
+ul.vocabulary {
+    margin-left: 0;
+}
+
+ul.vocabulary,
+ul.vocabulary ul,
+ul.vocabulary li
+{
+    list-style: none;
+}
+
+ul.vocabulary div.vocabulary-node-icon{
+    cursor: pointer;
+    width: 15px;
+    height: 12px;
+    display: inline-block;
+}
+
+ul.vocabulary div.vocabulary-node-icon.vocabulary-doc{
+    background-image: url(../../images/controlledvocabulary/voc_doc_222222.png);
+}
+
+ul.vocabulary div.vocabulary-node-icon.vocabulary-open{
+    background-image: url(../../images/controlledvocabulary/voc_open_222222.png);
+}
+
+ul.vocabulary div.vocabulary-node-icon.vocabulary-closed{
+    background-image: url(../../images/controlledvocabulary/voc_closed_222222.png);
+    background-repeat: no-repeat;
+}
+
+div.vocabulary-container li.error{
+    color: #c22121;
+}
+/* Controlled vocabulary support css END*/
+
+#aspect_administrative_authorization_EditPolicyForm_field_start_date{
+    width: 100px;
+}
+#aspect_administrative_authorization_EditPolicyForm_field_end_date{
+    width: 100px;
+}
+#aspect_administrative_authorization_EditItemPolicies_table_policies-confirm-delete tr,
+#aspect_administrative_authorization_EditItemPolicies_table_policies-confirm-delete td
+{
+    border: 1px solid lightgray;
+}
+
+
+#aspect_administrative_authorization_AdvacedAuthorizationsForm_field_end_date{
+    width: 100px;
+}
+#aspect_administrative_authorization_AdvacedAuthorizationsForm_field_start_date{
+    width: 100px;
+}
+#aspect_submission_StepTransformer_field_embargo_until_date{
+    width: 100px;
+}
+
+#aspect_administrative_item_AddBitstreamForm_field_embargo_until_date{
+    width: 100px;
+}
+
+#aspect_administrative_item_EditBitstreamForm_field_embargo_until_date{
+    width: 100px;
+}
+
+#aspect_submission_StepTransformer_table_policies tr,
+#aspect_submission_StepTransformer_table_policies td
+{
+    border: 1px solid lightgray;
+}
+
+table.detailtable {
+    background-color: #D8E8EB;
+}
+
+table.detailtable th{
+    background-color: #F0F2F5;
+    word-wrap: normal;
+}
+
+table.detailtable td{
+    background-color: #FFFFFF;
+    text-align: right;
+}
+
+
+span.highlight{
+    font-weight: bold;
+}
+
+div.gear-icon{
+    background-image: url('../../images/gear_6D859C_25x25.png');
+}
+
+ul.gear-selection li.gear-option-selected{
+    background: url('../../images/check_606060_15x15.png') no-repeat 3px center;
+}
+
+input#aspect_discovery_SimpleSearch_field_query{
+    width: 565px;
+}
+
+input.search-icon{
+    background-image: url('../../images/search_icon_ffffff_20x20.png');
+    background-repeat: no-repeat;
+    background-position: center center;
+    text-indent: -1000px;
+        /*Css props below are required for IE*/
+    font-size: 0;
+    display:block;
+    line-height: 0;
+}
+
+div#aspect_discovery_SimpleSearch_div_search p.pagination-info{
+    display: none;
+}
+
+div#aspect_discovery_SimpleSearch_div_search .pagination-links{
+    float: left;
+}
+
+table.discovery-filters{
+    width: 100%;
+    background-color: #FFFFFF;
+}
+
+table.discovery-filters tr{
+    border-top: 1px solid #EBEBEB;
+}
+table.discovery-filters td{
+    padding: 0;
+}
+
+table.discovery-filters td.selection{
+    width: 1%;
+}
+
+table.discovery-filters th.new-filter-header{
+    text-align: left;
+    padding-top: 20px;
+}
+
+
+table.discovery-filters td.discovery-filter-input-cell {
+    padding-left: 3px;
+}
+
+
+table.discovery-filters tr.apply-filter{
+    background-color: #FAFAFA;
+}
+
+table.discovery-filters tr.apply-filter input{
+    width: 65px;
+    height: 25px;
+    margin-left: auto;
+    margin-right: auto;
+    font-size: 108%;
+    display: block;
+    margin-top: 10px;
+}
+
+
+table.discovery-filters td.filter-controls{
+    width: 50px;
+}
+
+table.discovery-filters input.filter-control {
+    margin-left: 5px;
+    text-indent: -1000px;
+    background-repeat: no-repeat;
+    background-position: center center;
+    height: 17px;
+    width: 17px;
+    float: left;
+    background-color: transparent;
+    border: none;
+    /*Css props below are required for IE*/
+    font-size: 0;
+    display:block;
+    line-height: 0;
+}
+
+table.discovery-filters input.filter-control.filter-remove{
+    margin-left: 7px;
+    background-image: url('../../images/button_minus.png');
+}
+
+table.discovery-filters input.filter-control.filter-add{
+    background-image: url('../../images/button_plus.png');
+}
+
+table.discovery-filters tr.search-filter.filler
+{
+    background-color: #FAFAFA;
+    height: 25px;
+}
+
+table.discovery-filters th.new-filter-header
+{
+    padding-top: 5px;
+}
+
+
+.searchTime{
+    color: #999999;
+}
+
+.didYouMean{
+    font-size: 18px;
+}
+
+.didYouMean a{
+    font-weight: bold;
+}
+
+.recentSubmissionViewMore {
+    text-align: right;
+    font-size: 100%;
+}
+
+
+/*Sherpa Colour Styles*/
+.sherpaList{
+    list-style-type: none;
+    margin-left: 0;
+    margin-bottom: 20px;
+}
+
+.sherpaLogo{
+    float:left;
+    margin-right:10px;
+    width: 100px;
+    height: 54px;
+}
+
+.sherpaBold{
+    font-weight:bold;
+    float:left;
+    margin-right: 3px;
+}
+
+.green{
+    background-color: #008000;
+    color: #ffffff;
+}
+
+.white{
+    background-color: #ffffff;
+    color: #000000;
+}
+
+.yellow{
+    background-color: #ffff00;
+    color: #000000;
+}
+
+.blue{
+    background-color: #0000ff;
+    color: #ffffff;
+}
+
+.gray{
+    background-color: #aaaaaa;
+    color: #000000;
+}
+
+.sherpaMoreInfo{
+    font-size: 75%;
+}
+
+.sherpaStyle {
+    display: inline;
+    padding: .2em .6em .3em;
+    font-size: 75%;
+    font-weight: 700;
+    line-height: 1;
+    text-align: center;
+    white-space: nowrap;
+    vertical-align: baseline;
+    border-radius: .25em;
+    float:left;
+    border: 1px solid #cccccc;
+    margin-right: 3px;
+}
+
+#impact-altmetric {
+    float:right;
+    margin:0 30px 0 30px;
+}
+
+#impact-plumx {
+    float:right;
+}
+
+.orcid_icon {
+    text-decoration: none;
+    margin-top: -2px;
+}
diff --git a/dspace/modules/xmlui/src/main/webapp/themes/Mirage/lib/xsl/additions.xsl b/dspace/modules/xmlui/src/main/webapp/themes/Mirage/lib/xsl/additions.xsl
new file mode 100644
index 0000000000000000000000000000000000000000..39e5f3452307b86b3b6d4379ec69d52a8feba2ca
--- /dev/null
+++ b/dspace/modules/xmlui/src/main/webapp/themes/Mirage/lib/xsl/additions.xsl
@@ -0,0 +1,312 @@
+<!--
+
+    The contents of this file are subject to the license and copyright
+    detailed in the LICENSE and NOTICE files at the root of the source
+    tree and available online at
+
+    http://www.dspace.org/license/
+
+-->
+<!--
+    Rendering specific to the item display page.
+
+    Author: art.lowel at atmire.com
+    Author: lieven.droogmans at atmire.com
+    Author: ben at atmire.com
+    Author: Alexey Maslov
+
+-->
+
+<xsl:stylesheet
+    xmlns:i18n="http://apache.org/cocoon/i18n/2.1"
+    xmlns:dri="http://di.tamu.edu/DRI/1.0/"
+    xmlns:mets="http://www.loc.gov/METS/"
+    xmlns:dim="http://www.dspace.org/xmlns/dspace/dim"
+    xmlns:xlink="http://www.w3.org/TR/xlink/"
+    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"
+    xmlns="http://www.w3.org/1999/xhtml"
+    xmlns:xalan="http://xml.apache.org/xalan"
+    xmlns:encoder="xalan://java.net.URLEncoder"
+    xmlns:util="org.dspace.app.xmlui.utils.XSLUtils"
+    xmlns:jstring="java.lang.String"
+    xmlns:rights="http://cosimo.stanford.edu/sdr/metsrights/"
+    xmlns:confman="org.dspace.core.ConfigurationManager"
+    exclude-result-prefixes="xalan encoder i18n dri mets dim xlink xsl util jstring rights confman">
+
+    <xsl:output indent="yes"/>
+
+    <xsl:template name="itemSummaryView-DIM-fields">
+        <xsl:param name="clause" select="'1'"/>
+        <xsl:param name="phase" select="'even'"/>
+        <xsl:variable name="otherPhase">
+            <xsl:choose>
+                <xsl:when test="$phase = 'even'">
+                    <xsl:text>odd</xsl:text>
+                </xsl:when>
+                <xsl:otherwise>
+                    <xsl:text>even</xsl:text>
+                </xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+
+        <xsl:choose>
+            <!-- Title row -->
+            <xsl:when test="$clause = 1">
+
+                <xsl:choose>
+                    <xsl:when test="descendant::text() and (count(dim:field[@element='title'][not(@qualifier)]) &gt; 1)">
+                        <!-- display first title as h1 -->
+                        <h1>
+                            <xsl:value-of select="dim:field[@element='title'][not(@qualifier)][1]/node()"/>
+                        </h1>
+                        <div class="simple-item-view-other">
+                            <span class="bold"><i18n:text>xmlui.dri2xhtml.METS-1.0.item-title</i18n:text>:</span>
+                            <span>
+                                <xsl:for-each select="dim:field[@element='title'][not(@qualifier)]">
+                                    <xsl:value-of select="./node()"/>
+                                    <xsl:if test="count(following-sibling::dim:field[@element='title'][not(@qualifier)]) != 0">
+                                        <xsl:text>; </xsl:text>
+                                        <br/>
+                                    </xsl:if>
+                                </xsl:for-each>
+                            </span>
+                        </div>
+                    </xsl:when>
+                    <xsl:when test="dim:field[@element='title'][descendant::text()] and count(dim:field[@element='title'][not(@qualifier)]) = 1">
+                        <h1>
+                            <xsl:value-of select="dim:field[@element='title'][not(@qualifier)][1]/node()"/>
+                        </h1>
+                    </xsl:when>
+                    <xsl:otherwise>
+                        <h1>
+                            <i18n:text>xmlui.dri2xhtml.METS-1.0.no-title</i18n:text>
+                        </h1>
+                    </xsl:otherwise>
+                </xsl:choose>
+                <xsl:call-template name="itemSummaryView-DIM-fields">
+                    <xsl:with-param name="clause" select="($clause + 1)"/>
+                    <xsl:with-param name="phase" select="$otherPhase"/>
+                </xsl:call-template>
+            </xsl:when>
+
+            <!-- Author(s) row -->
+            <xsl:when test="$clause = 2 and (dim:field[@element='contributor'][@qualifier='author' and descendant::text()] or dim:field[@element='creator' and descendant::text()] or dim:field[@element='contributor' and descendant::text()])">
+                <div class="simple-item-view-authors">
+                    <xsl:choose>
+                        <xsl:when test="dim:field[@element='contributor'][@qualifier='author']">
+                            <xsl:for-each select="dim:field[@element='contributor'][@qualifier='author']">
+                                <span>
+                                    <xsl:if test="@authority">
+                                        <xsl:attribute name="class"><xsl:text>ds-dc_contributor_author-authority</xsl:text></xsl:attribute>
+                                    </xsl:if>
+                                    <xsl:choose>
+                                        <xsl:when test="@orcidID">
+                                            <xsl:call-template name="renderDiscovery">
+                                                <xsl:with-param name="value" select="node()"/>
+                                                <xsl:with-param name="orcidID" select="@orcidID"/>
+                                            </xsl:call-template>
+                                            <xsl:call-template name="renderORCID"/>
+                                        </xsl:when>
+                                        <xsl:otherwise>
+                                            <xsl:copy-of select="node()"/>
+                                        </xsl:otherwise>
+                                    </xsl:choose>
+                                </span>
+                                <xsl:if test="count(following-sibling::dim:field[@element='contributor'][@qualifier='author']) != 0">
+                                    <xsl:text>; </xsl:text>
+                                </xsl:if>
+                            </xsl:for-each>
+                        </xsl:when>
+                        <xsl:when test="dim:field[@element='creator']">
+                            <xsl:for-each select="dim:field[@element='creator']">
+                                <xsl:copy-of select="node()"/>
+                                <xsl:if test="count(following-sibling::dim:field[@element='creator']) != 0">
+                                    <xsl:text>; </xsl:text>
+                                </xsl:if>
+                            </xsl:for-each>
+                        </xsl:when>
+                        <xsl:when test="dim:field[@element='contributor']">
+                            <xsl:for-each select="dim:field[@element='contributor']">
+                                <xsl:copy-of select="node()"/>
+                                <xsl:if test="count(following-sibling::dim:field[@element='contributor']) != 0">
+                                    <xsl:text>; </xsl:text>
+                                </xsl:if>
+                            </xsl:for-each>
+                        </xsl:when>
+                        <xsl:otherwise>
+                            <i18n:text>xmlui.dri2xhtml.METS-1.0.no-author</i18n:text>
+                        </xsl:otherwise>
+                    </xsl:choose>
+                </div>
+                <xsl:call-template name="itemSummaryView-DIM-fields">
+                    <xsl:with-param name="clause" select="($clause + 1)"/>
+                    <xsl:with-param name="phase" select="$otherPhase"/>
+                </xsl:call-template>
+            </xsl:when>
+
+            <!-- identifier.uri row -->
+            <xsl:when test="$clause = 3 and (dim:field[@element='identifier' and @qualifier='uri' and descendant::text()])">
+                <div class="simple-item-view-other">
+                    <span class="bold"><i18n:text>xmlui.dri2xhtml.METS-1.0.item-uri</i18n:text>:</span>
+                    <span>
+                        <xsl:for-each select="dim:field[@element='identifier' and @qualifier='uri']">
+                            <a>
+                                <xsl:attribute name="href">
+                                    <xsl:copy-of select="./node()"/>
+                                </xsl:attribute>
+                                <xsl:copy-of select="./node()"/>
+                            </a>
+                            <xsl:if test="count(following-sibling::dim:field[@element='identifier' and @qualifier='uri']) != 0">
+                                <br/>
+                            </xsl:if>
+                        </xsl:for-each>
+                    </span>
+                </div>
+                <xsl:call-template name="itemSummaryView-DIM-fields">
+                    <xsl:with-param name="clause" select="($clause + 1)"/>
+                    <xsl:with-param name="phase" select="$otherPhase"/>
+                </xsl:call-template>
+            </xsl:when>
+
+            <!-- date.issued row -->
+            <xsl:when test="$clause = 4 and (dim:field[@element='date' and @qualifier='issued' and descendant::text()])">
+                <div class="simple-item-view-other">
+                    <span class="bold"><i18n:text>xmlui.dri2xhtml.METS-1.0.item-date</i18n:text>:</span>
+                    <span>
+                        <xsl:for-each select="dim:field[@element='date' and @qualifier='issued']">
+                            <xsl:copy-of select="substring(./node(),1,10)"/>
+                            <xsl:if test="count(following-sibling::dim:field[@element='date' and @qualifier='issued']) != 0">
+                                <br/>
+                            </xsl:if>
+                        </xsl:for-each>
+                    </span>
+                </div>
+                <xsl:call-template name="itemSummaryView-DIM-fields">
+                    <xsl:with-param name="clause" select="($clause + 1)"/>
+                    <xsl:with-param name="phase" select="$otherPhase"/>
+                </xsl:call-template>
+            </xsl:when>
+
+            <!-- Abstract row -->
+            <xsl:when test="$clause = 5 and (dim:field[@element='description' and @qualifier='abstract' and descendant::text()])">
+                <div class="simple-item-view-description">
+                    <h3><i18n:text>xmlui.dri2xhtml.METS-1.0.item-abstract</i18n:text>:</h3>
+                    <div>
+                        <xsl:if test="count(dim:field[@element='description' and @qualifier='abstract']) &gt; 1">
+                            <div class="spacer">&#160;</div>
+                        </xsl:if>
+                        <xsl:for-each select="dim:field[@element='description' and @qualifier='abstract']">
+                            <xsl:choose>
+                                <xsl:when test="node()">
+                                    <xsl:copy-of select="node()"/>
+                                </xsl:when>
+                                <xsl:otherwise>
+                                    <xsl:text>&#160;</xsl:text>
+                                </xsl:otherwise>
+                            </xsl:choose>
+                            <xsl:if test="count(following-sibling::dim:field[@element='description' and @qualifier='abstract']) != 0">
+                                <div class="spacer">&#160;</div>
+                            </xsl:if>
+                        </xsl:for-each>
+                        <xsl:if test="count(dim:field[@element='description' and @qualifier='abstract']) &gt; 1">
+                            <div class="spacer">&#160;</div>
+                        </xsl:if>
+                    </div>
+                </div>
+                <xsl:call-template name="itemSummaryView-DIM-fields">
+                    <xsl:with-param name="clause" select="($clause + 1)"/>
+                    <xsl:with-param name="phase" select="$otherPhase"/>
+                </xsl:call-template>
+            </xsl:when>
+
+            <!-- Description row -->
+            <xsl:when test="$clause = 6 and (dim:field[@element='description' and not(@qualifier) and descendant::text()])">
+                <div class="simple-item-view-description">
+                    <h3 class="bold"><i18n:text>xmlui.dri2xhtml.METS-1.0.item-description</i18n:text>:</h3>
+                    <div>
+                        <xsl:if test="count(dim:field[@element='description' and not(@qualifier)]) &gt; 1 and not(count(dim:field[@element='description' and @qualifier='abstract']) &gt; 1)">
+                            <div class="spacer">&#160;</div>
+                        </xsl:if>
+                        <xsl:for-each select="dim:field[@element='description' and not(@qualifier)]">
+                            <xsl:copy-of select="./node()"/>
+                            <xsl:if test="count(following-sibling::dim:field[@element='description' and not(@qualifier)]) != 0">
+                                <div class="spacer">&#160;</div>
+                            </xsl:if>
+                        </xsl:for-each>
+                        <xsl:if test="count(dim:field[@element='description' and not(@qualifier)]) &gt; 1">
+                            <div class="spacer">&#160;</div>
+                        </xsl:if>
+                    </div>
+                </div>
+                <xsl:call-template name="itemSummaryView-DIM-fields">
+                    <xsl:with-param name="clause" select="($clause + 1)"/>
+                    <xsl:with-param name="phase" select="$otherPhase"/>
+                </xsl:call-template>
+            </xsl:when>
+
+            <xsl:when test="$clause = 7 and $ds_item_view_toggle_url != ''">
+                <p class="ds-paragraph item-view-toggle item-view-toggle-bottom">
+                    <a>
+                        <xsl:attribute name="href"><xsl:value-of select="$ds_item_view_toggle_url"/></xsl:attribute>
+                        <i18n:text>xmlui.ArtifactBrowser.ItemViewer.show_full</i18n:text>
+                    </a>
+                </p>
+            </xsl:when>
+
+            <!-- recurse without changing phase if we didn't output anything -->
+            <xsl:otherwise>
+                <!-- IMPORTANT: This test should be updated if clauses are added! -->
+                <xsl:if test="$clause &lt; 8">
+                    <xsl:call-template name="itemSummaryView-DIM-fields">
+                        <xsl:with-param name="clause" select="($clause + 1)"/>
+                        <xsl:with-param name="phase" select="$phase"/>
+                    </xsl:call-template>
+                </xsl:if>
+            </xsl:otherwise>
+        </xsl:choose>
+
+        <!-- Generate the Creative Commons license information from the file section (DSpace deposit license hidden by default) -->
+        <xsl:apply-templates select="mets:fileSec/mets:fileGrp[@USE='CC-LICENSE']"/>
+    </xsl:template>
+
+    <xsl:template name="renderDiscovery">
+        <xsl:param name="value"/>
+        <xsl:param name="orcidID"/>
+        <a>
+            <xsl:attribute name="href">
+                <xsl:value-of select="$context-path"/>
+                <xsl:text>/discover?filtertype_1=orcidid</xsl:text>
+                <xsl:text>&amp;filter_relational_operator_1=equals&amp;filter_1=</xsl:text>
+                <xsl:value-of select="substring-after($orcidID, confman:getProperty('orcid.connector.url'))"/>
+            </xsl:attribute>
+            <xsl:value-of select="$value"/>
+        </a>
+    </xsl:template>
+
+    <xsl:template name="renderORCID">
+        <a class="orcid_icon" target="_blank" href="{@orcidID}">
+            <xsl:text> </xsl:text>
+            <img src="{$theme-path}/images/orcid_icon.png" alt="cc"/>
+        </a>
+    </xsl:template>
+
+    <xsl:template match="dri:reference" mode="summaryView">
+        <!-- simplified check to verify whether access rights are available in METS -->
+        <xsl:variable name='METSRIGHTS-enabled' select="contains(confman:getProperty('plugin.named.org.dspace.content.crosswalk.DisseminationCrosswalk'), 'METSRIGHTS')" />
+        <xsl:variable name="externalMetadataURL">
+            <xsl:text>cocoon:/</xsl:text>
+            <xsl:value-of select="@url"/>
+            <!-- If this is an Item, display the METSRIGHTS section, so we
+                 know which files have access restrictions.
+                 This requires the METSRightsCrosswalk to be enabled! -->
+            <xsl:if test="@type='DSpace Item' and $METSRIGHTS-enabled">
+                <xsl:text>?rightsMDTypes=METSRIGHTS&amp;requireORCIDCall=true</xsl:text>
+            </xsl:if>
+        </xsl:variable>
+        <!-- This comment just displays the full URL in an HTML comment, for easy reference. -->
+        <xsl:comment> External Metadata URL: <xsl:value-of select="$externalMetadataURL"/> </xsl:comment>
+        <xsl:apply-templates select="document($externalMetadataURL)" mode="summaryView"/>
+        <xsl:apply-templates />
+    </xsl:template>
+
+</xsl:stylesheet>
diff --git a/dspace/pom.xml b/dspace/pom.xml
index 64a5833f804c36edf1b712ee72911e51f74e7903..492e712687721ea3870e0c7c8ad491b10d2c7c89 100644
--- a/dspace/pom.xml
+++ b/dspace/pom.xml
@@ -16,7 +16,7 @@
         <groupId>org.dspace</groupId>
         <artifactId>dspace-parent</artifactId>
         <version>5.10</version>
-        <relativePath>../../../../Downloads/dspace-5.10-release</relativePath>
+        <relativePath>..</relativePath>
     </parent>
 
     <properties>
@@ -29,11 +29,43 @@
             <!-- Filter using the properties file defined by dspace-parent POM -->
             <filter>${filters.file}</filter>
         </filters>
+
+        <resources>
+            <!-- Enumerate filtered files explicitly to avoid issues with other config tech. -->
+            <resource>
+                <directory>${basedir}</directory>
+                <filtering>true</filtering>
+                <includes>
+                    <include>config/default.context.xml</include>
+                    <include>config/dspace.cfg</include>
+                    <include>config/log4j-handle-plugin.properties</include>
+                    <include>config/log4j.properties</include>
+                    <include>config/modules/curate.cfg</include>
+                    <include>config/modules/com.atmire.statistics.oai.cfg</include>
+                    <include>config/modules/solr-statistics.cfg</include>
+                </includes>
+            </resource>
+            <!-- Declare a mutually exclusive resource set for non-filtered files. -->
+            <resource>
+                <directory>${basedir}</directory>
+                <filtering>false</filtering>
+                <excludes>
+                    <exclude>config/default.context.xml</exclude>
+                    <exclude>config/dspace.cfg</exclude>
+                    <exclude>config/log4j-handle-plugin.properties</exclude>
+                    <exclude>config/log4j.properties</exclude>
+                    <exclude>config/modules/curate.cfg</exclude>
+                    <exclude>config/modules/com.atmire.statistics.oai.cfg</exclude>
+                    <exclude>config/modules/solr-statistics.cfg</exclude>
+                </excludes>
+            </resource>
+        </resources>
+
     </build>
 
     <profiles>
 
-        <!-- Build Profile. This builds all Overlay modules for DSpace -->   
+        <!-- Build Profile. This builds all Overlay modules for DSpace -->
         <profile>
             <id>build</id>
             <activation>
@@ -45,7 +77,7 @@
             <!-- Build all Overlay submodules -->
             <modules>
                 <module>modules</module>
-            </modules> 
+            </modules>
         </profile>
 
         <!--
@@ -65,8 +97,8 @@
             </activation>
             <build>
                 <plugins>
-                   <!-- Assemble 'target/dspace-installer' using 'assembly.xml' -->
-                   <plugin>
+                    <!-- Assemble 'target/dspace-installer' using 'assembly.xml' -->
+                    <plugin>
                         <artifactId>maven-assembly-plugin</artifactId>
                         <inherited>false</inherited>
                         <configuration>
@@ -109,7 +141,7 @@
             <properties>
                 <distributions>false</distributions>
             </properties>
-        </profile> 
+        </profile>
 
 
         <!--
@@ -119,57 +151,61 @@
             Instead, a zip/tarball is generated from the parent [dspace-src] directory.
         -->
         <profile>
-           <id>distributions</id>
-           <activation>
-              <!-- Only enabled if "distributions=true" was passed on commandline -->
-              <property>
-                  <name>distributions</name>
-                  <value>true</value>
-              </property>
-           </activation>
-           <build>
-              <plugins>
-                 <plugin>
-                    <artifactId>maven-assembly-plugin</artifactId>
-                    <inherited>false</inherited>
-                    <executions>
-                       <execution>
-                          <inherited>false</inherited>
-                          <configuration>
-                             <descriptors>
-                                <descriptor>src/main/assembly/release.xml</descriptor>
-                                <descriptor>src/main/assembly/src-release.xml</descriptor>
-                             </descriptors>
-                             <tarLongFileMode>gnu</tarLongFileMode>
-                             <finalName>dspace-${project.version}</finalName>
-                          </configuration>
-                          <phase>package</phase>
-                          <goals>
-                             <goal>single</goal>
-                          </goals>
-                       </execution>
-                    </executions>
-                 </plugin>
-              </plugins>
-           </build>
+            <id>distributions</id>
+            <activation>
+                <!-- Only enabled if "distributions=true" was passed on commandline -->
+                <property>
+                    <name>distributions</name>
+                    <value>true</value>
+                </property>
+            </activation>
+            <build>
+                <plugins>
+                    <plugin>
+                        <artifactId>maven-assembly-plugin</artifactId>
+                        <inherited>false</inherited>
+                        <executions>
+                            <execution>
+                                <inherited>false</inherited>
+                                <configuration>
+                                    <descriptors>
+                                        <descriptor>src/main/assembly/release.xml</descriptor>
+                                        <descriptor>src/main/assembly/src-release.xml</descriptor>
+                                    </descriptors>
+                                    <tarLongFileMode>gnu</tarLongFileMode>
+                                    <finalName>dspace-${project.version}</finalName>
+                                </configuration>
+                                <phase>package</phase>
+                                <goals>
+                                    <goal>single</goal>
+                                </goals>
+                            </execution>
+                        </executions>
+                    </plugin>
+                </plugins>
+            </build>
         </profile>
 
     </profiles>
 
     <dependencies>
-    	<!-- This dependency ensures DSpace OAI JAR is added to [dspace]/lib/,
+        <dependency>
+            <groupId>org.dspace.modules</groupId>
+            <artifactId>additions</artifactId>
+        </dependency>
+        <!-- This dependency ensures DSpace OAI JAR is added to [dspace]/lib/,
              so that the 'dspace oai' launcher.xml command works.  -->
-    	<dependency>
+        <dependency>
             <groupId>org.dspace</groupId>
             <artifactId>dspace-oai</artifactId>
             <type>jar</type>
             <classifier>classes</classifier>
-    	</dependency>
+        </dependency>
         <!-- The Servlet API is also needed by the 'dspace oai' launcher.xml
              command. -->
-    	<dependency>
+        <dependency>
             <groupId>javax.servlet</groupId>
             <artifactId>servlet-api</artifactId>
-    	</dependency>
+        </dependency>
     </dependencies>
 </project>
diff --git a/dspace/solr/search/conf/schema.xml b/dspace/solr/search/conf/schema.xml
index 2e12d076bdd08d08ad099dfc86b2dd21723f9fe3..dc7c34a71ebd8f34bc59b29d6b2ea6d926629e1f 100644
--- a/dspace/solr/search/conf/schema.xml
+++ b/dspace/solr/search/conf/schema.xml
@@ -583,6 +583,8 @@
     <dynamicField name="*.year" type="sint" indexed="true" stored="true" multiValued="true" omitNorms="true" />
     <dynamicField name="*_dt" type="date" indexed="true" stored="true" multiValued="false" omitNorms="true"  docValues="true"/>
 
+    <field name="orcid_id" type="string" multiValued="true" indexed="true" stored="true" required="false"/>
+     <copyField source="orcid_id" dest="orcidid_keyword"/>
 
     <!--Used for matching on all other fields -->
      <dynamicField name="*" type="text" multiValued="true"/>
